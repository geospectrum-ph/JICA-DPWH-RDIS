"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[6023],{62408:(M,F,E)=>{function e(M){return null!=r(M)||null!=u(M)}function t(M){return T.test(M)}function n(M){var F;return null!==(F=r(M))&&void 0!==F?F:u(M)}function u(M){const F=new Date(M);return function o(M,F){if(Number.isNaN(M.getTime()))return!1;let E=!0;if(C&&/\d+\W*$/.test(F)){const M=F.match(/[a-zA-Z]{2,}/);if(M){let F=!1,T=0;for(;!F&&T<=M.length;)F=!A.test(M[T]),T++;E=!F}}return E}(F,M)?Number.isNaN(F.getTime())?null:F.getTime()-6e4*F.getTimezoneOffset():null}function r(M){var F,E,A,C;const X=T.exec(M);if(null===X||void 0===X||!X.groups)return null;const O=X.groups,q=+O.year,Z=+O.month-1,z=+O.day,D=+(null!==(F=O.hours)&&void 0!==F?F:"0"),L=+(null!==(E=O.minutes)&&void 0!==E?E:"0"),V=+(null!==(A=O.seconds)&&void 0!==A?A:"0");if(D>23)return null;if(L>59)return null;if(V>59)return null;const K=null!==(C=O.ms)&&void 0!==C?C:"0",J=K?+K.padEnd(3,"0").substring(0,3):0;let Q;if(O.isUTC||!O.offsetSign)Q=Date.UTC(q,Z,z,D,L,V,J);else{const M=+O.offsetHours,F=+O.offsetMinutes;Q=6e4*("+"===O.offsetSign?-1:1)*(60*M+F)+Date.UTC(q,Z,z,D,L,V,J)}return Number.isNaN(Q)?null:Q}E.d(F,{Br:()=>t,Cq:()=>e,_U:()=>n});const T=/^(?:(?<year>-?\d{4,})-(?<month>\d{2})-(?<day>\d{2}))(?:T(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2})(?:\.(?<ms>\d+))?)?(?:(?<isUTC>Z)|(?:(?<offsetSign>\+|-)(?<offsetHours>\d{2}):(?<offsetMinutes>\d{2})))?$/;const A=/^((jan(uary)?)|(feb(ruary)?)|(mar(ch)?)|(apr(il)?)|(may)|(jun(e)?)|(jul(y)?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)|(am)|(pm)|(gmt)|(utc))$/i,C=!Number.isNaN(new Date("technology 10").getTime())},30925:(M,F,E)=>{E.d(F,{w:()=>s});var T=E(16842),A=E(17244),C=E(60964);class s{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9,F=arguments.length>1?arguments[1]:void 0;this._compareMinX=o,this._compareMinY=l,this._toBBox=M=>M,this._maxEntries=Math.max(4,M||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),F&&("function"==typeof F?this._toBBox=F:this._initFormat(F)),this.clear()}destroy(){this.clear(),X.prune(),O.prune(),q.prune(),Z.prune()}all(M){this._all(this._data,M)}search(M,F){let E=this._data;const T=this._toBBox;if(x(M,E))for(X.clear();E;){for(let A=0,C=E.children.length;A<C;A++){const C=E.children[A],O=E.leaf?T(C):C;x(M,O)&&(E.leaf?F(C):_(M,O)?this._all(C,F):X.push(C))}E=X.pop()}}collides(M){let F=this._data;const E=this._toBBox;if(!x(M,F))return!1;for(X.clear();F;){for(let T=0,A=F.children.length;T<A;T++){const A=F.children[T],C=F.leaf?E(A):A;if(x(M,C)){if(F.leaf||_(M,C))return!0;X.push(A)}}F=X.pop()}return!1}load(M){if(!M.length)return this;if(M.length<this._minEntries){for(let F=0,E=M.length;F<E;F++)this.insert(M[F]);return this}let F=this._build(M.slice(0,M.length),0,M.length-1,0);if(this._data.children.length)if(this._data.height===F.height)this._splitRoot(this._data,F);else{if(this._data.height<F.height){const M=this._data;this._data=F,F=M}this._insert(F,this._data.height-F.height-1,!0)}else this._data=F;return this}insert(M){return M&&this._insert(M,this._data.height-1),this}clear(){return this._data=new w([]),this}remove(M){if(!M)return this;let F,E=this._data,A=null,C=0,X=!1;const O=this._toBBox(M);for(q.clear(),Z.clear();E||q.length>0;){var z;if(E||(E=q.pop(),A=q.data[q.length-1],C=null!==(z=Z.pop())&&void 0!==z?z:0,X=!0),E.leaf&&(F=(0,T.qh)(E.children,M,E.children.length,E.indexHint),-1!==F))return E.children.splice(F,1),q.push(E),this._condense(q),this;X||E.leaf||!_(E,O)?A?(C++,E=A.children[C],X=!1):E=null:(q.push(E),Z.push(C),C=0,A=E,E=E.children[0])}return this}toJSON(){return this._data}fromJSON(M){return this._data=M,this}_all(M,F){let E=M;for(O.clear();E;){var T;if(!0===E.leaf)for(const M of E.children)F(M);else O.pushArray(E.children);E=null!==(T=O.pop())&&void 0!==T?T:null}}_build(M,F,E,T){const A=E-F+1;let C=this._maxEntries;if(A<=C){const T=new w(M.slice(F,E+1));return h(T,this._toBBox),T}T||(T=Math.ceil(Math.log(A)/Math.log(C)),C=Math.ceil(A/C**(T-1)));const X=new b([]);X.height=T;const O=Math.ceil(A/C),q=O*Math.ceil(Math.sqrt(C));f(M,F,E,q,this._compareMinX);for(let Z=F;Z<=E;Z+=q){const F=Math.min(Z+q-1,E);f(M,Z,F,O,this._compareMinY);for(let E=Z;E<=F;E+=O){const A=Math.min(E+O-1,F);X.children.push(this._build(M,E,A,T-1))}}return h(X,this._toBBox),X}_chooseSubtree(M,F,E,T){for(;T.push(F),!0!==F.leaf&&T.length-1!==E;){let E,T=1/0,A=1/0;for(let C=0,X=F.children.length;C<X;C++){const X=F.children[C],O=c(X),q=d(M,X)-O;q<A?(A=q,T=O<T?O:T,E=X):q===A&&O<T&&(T=O,E=X)}F=E||F.children[0]}return F}_insert(M,F,E){const T=this._toBBox,A=E?M:T(M);q.clear();const C=this._chooseSubtree(A,this._data,F,q);for(C.children.push(M),r(C,A);F>=0&&q.data[F].children.length>this._maxEntries;)this._split(q,F),F--;this._adjustParentBBoxes(A,q,F)}_split(M,F){const E=M.data[F],T=E.children.length,A=this._minEntries;this._chooseSplitAxis(E,A,T);const C=this._chooseSplitIndex(E,A,T);if(!C)return void console.log("  Error: assertion failed at PooledRBush._split: no valid split index");const X=E.children.splice(C,E.children.length-C),O=E.leaf?new w(X):new b(X);O.height=E.height,h(E,this._toBBox),h(O,this._toBBox),F?M.data[F-1].children.push(O):this._splitRoot(E,O)}_splitRoot(M,F){this._data=new b([M,F]),this._data.height=M.height+1,h(this._data,this._toBBox)}_chooseSplitIndex(M,F,E){let T,A,C;T=A=1/0;for(let X=F;X<=E-F;X++){const F=a(M,0,X,this._toBBox),O=a(M,X,E,this._toBBox),q=u(F,O),Z=c(F)+c(O);q<T?(T=q,C=X,A=Z<A?Z:A):q===T&&Z<A&&(A=Z,C=X)}return C}_chooseSplitAxis(M,F,E){const T=M.leaf?this._compareMinX:o,A=M.leaf?this._compareMinY:l;this._allDistMargin(M,F,E,T)<this._allDistMargin(M,F,E,A)&&M.children.sort(T)}_allDistMargin(M,F,E,T){M.children.sort(T);const A=this._toBBox,C=a(M,0,F,A),X=a(M,E-F,E,A);let O=m(C)+m(X);for(let q=F;q<E-F;q++){const F=M.children[q];r(C,M.leaf?A(F):F),O+=m(C)}for(let q=E-F-1;q>=F;q--){const F=M.children[q];r(X,M.leaf?A(F):F),O+=m(X)}return O}_adjustParentBBoxes(M,F,E){for(let T=E;T>=0;T--)r(F.data[T],M)}_condense(M){for(let F=M.length-1;F>=0;F--){const E=M.data[F];if(0===E.children.length)if(F>0){const A=M.data[F-1],C=A.children;C.splice((0,T.qh)(C,E,C.length,A.indexHint),1)}else this.clear();else h(E,this._toBBox)}}_initFormat(M){const F=["return a"," - b",";"];this._compareMinX=new Function("a","b",F.join(M[0])),this._compareMinY=new Function("a","b",F.join(M[1])),this._toBBox=new Function("a","return {minX: a"+M[0]+", minY: a"+M[1]+", maxX: a"+M[2]+", maxY: a"+M[3]+"};")}}function h(M,F){a(M,0,M.children.length,F,M)}function a(M,F,E,T,A){A||(A=new w([])),A.minX=1/0,A.minY=1/0,A.maxX=-1/0,A.maxY=-1/0;for(let C,X=F;X<E;X++)C=M.children[X],r(A,M.leaf?T(C):C);return A}function r(M,F){M.minX=Math.min(M.minX,F.minX),M.minY=Math.min(M.minY,F.minY),M.maxX=Math.max(M.maxX,F.maxX),M.maxY=Math.max(M.maxY,F.maxY)}function o(M,F){return M.minX-F.minX}function l(M,F){return M.minY-F.minY}function c(M){return(M.maxX-M.minX)*(M.maxY-M.minY)}function m(M){return M.maxX-M.minX+(M.maxY-M.minY)}function d(M,F){return(Math.max(F.maxX,M.maxX)-Math.min(F.minX,M.minX))*(Math.max(F.maxY,M.maxY)-Math.min(F.minY,M.minY))}function u(M,F){const E=Math.max(M.minX,F.minX),T=Math.max(M.minY,F.minY),A=Math.min(M.maxX,F.maxX),C=Math.min(M.maxY,F.maxY);return Math.max(0,A-E)*Math.max(0,C-T)}function _(M,F){return M.minX<=F.minX&&M.minY<=F.minY&&F.maxX<=M.maxX&&F.maxY<=M.maxY}function x(M,F){return F.minX<=M.maxX&&F.minY<=M.maxY&&F.maxX>=M.minX&&F.maxY>=M.minY}function f(M,F,E,T,A){const X=[F,E];for(;X.length;){const F=X.pop(),E=X.pop();if(F-E<=T)continue;const O=E+Math.ceil((F-E)/T/2)*T;(0,C.q)(M,O,E,F,A),X.push(E,O,O,F)}}const X=new A.A,O=new A.A,q=new A.A,Z=new A.A({deallocator:void 0});class Y{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}}class B extends Y{constructor(){super(...arguments),this.height=1,this.indexHint=new T.vW}}class w extends B{constructor(M){super(),this.children=M,this.leaf=!0}}class b extends B{constructor(M){super(),this.children=M,this.leaf=!1}}},14745:(M,F,E)=>{E.d(F,{B:()=>a,GP:()=>s,qg:()=>p});var T=E(4389),A=E(5410);const C={ar:[".",","],bg:[",","\xa0"],bs:[",","."],ca:[",","."],cs:[",","\xa0"],da:[",","."],de:[",","."],"de-ch":[".","\u2019"],el:[",","."],en:[".",","],"en-au":[".",","],es:[",","."],"es-mx":[".",","],et:[",","\xa0"],fi:[",","\xa0"],fr:[",","\u202f"],"fr-ch":[",","\u202f"],he:[".",","],hi:[".",",","#,##,##0.###"],hr:[",","."],hu:[",","\xa0"],id:[",","."],it:[",","."],"it-ch":[".","\u2019"],ja:[".",","],ko:[".",","],lt:[",","\xa0"],lv:[",","\xa0"],mk:[",","."],nb:[",","\xa0"],nl:[",","."],pl:[",","\xa0"],pt:[",","."],"pt-pt":[",","\xa0"],ro:[",","."],ru:[",","\xa0"],sk:[",","\xa0"],sl:[",","."],sr:[",","."],sv:[",","\xa0"],th:[".",","],tr:[",","."],uk:[",","\xa0"],vi:[",","."],zh:[".",","]};function r(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:(0,A.JK)(),F=(M=M.toLowerCase())in C;if(!F){const E=M.split("-");E.length>1&&E[0]in C&&(M=E[0],F=!0),F||(M="en")}const[E,T,X="#,##0.###"]=C[M];return{decimal:E,group:T,pattern:X}}function s(M,F){const E=r((F={...F}).locale);F.customs=E;const T=F.pattern||E.pattern;return isNaN(M)||Math.abs(M)===1/0?null:function o(M,F,E){const T=(E=E||{}).customs.group,A=E.customs.decimal,C=F.split(";"),O=C[0];if((F=C[M<0?1:0]||"-"+O).includes("%"))M*=100;else if(F.includes("\u2030"))M*=1e3;else{if(F.includes("\xa4"))throw new Error("currency notation not supported");if(F.includes("E"))throw new Error("exponential notation not supported")}const q=X,Z=O.match(q);if(!Z)throw new Error("unable to find a number expression in pattern: "+F);return!1===E.fractional&&(E.places=0),F.replace(q,function i(M,F,E){!0===(E=E||{}).places&&(E.places=0),E.places===1/0&&(E.places=6);const T=F.split("."),A="string"==typeof E.places&&E.places.indexOf(",");let C=E.places;A?C=E.places.substring(A+1):+C>=0||(C=(T[1]||[]).length),E.round<0||(M=Number(M.toFixed(Number(C))));const X=String(Math.abs(M)).split("."),O=X[1]||"";if(T[1]||E.places){A&&(E.places=E.places.substring(0,A));const M=void 0!==E.places?E.places:T[1]&&T[1].lastIndexOf("0")+1;+M>O.length&&(X[1]=O.padEnd(Number(M),"0")),+C<O.length&&(X[1]=O.substr(0,Number(C)))}else X[1]&&X.pop();const q=T[0].replace(",","");let Z=q.indexOf("0");-1!==Z&&(Z=q.length-Z,Z>X[0].length&&(X[0]=X[0].padStart(Z,"0")),q.includes("#")||(X[0]=X[0].substr(X[0].length-Z)));let z,D,L=T[0].lastIndexOf(",");if(-1!==L){z=T[0].length-L-1;const M=T[0].substr(0,L);L=M.lastIndexOf(","),-1!==L&&(D=M.length-L-1)}const V=[];for(let K=X[0];K;){const M=K.length-z;V.push(M>0?K.substr(M):K),K=M>0?K.slice(0,M):"",D&&(z=D,D=void 0)}return X[0]=V.reverse().join(E.group||","),X.join(E.decimal||".")}(M,Z[0],{decimal:A,group:T,places:E.places,round:E.round}))}(M,T,F)}const X=/[#0,]*[#0](?:\.0*#*)?/;function a(M){const F=r((M=M||{}).locale),E=M.pattern||F.pattern,A=F.group,C=F.decimal;let O=1;if(E.includes("%"))O/=100;else if(E.includes("\u2030"))O/=1e3;else if(E.includes("\xa4"))throw new Error("currency notation not supported");const q=E.split(";");1===q.length&&q.push("-"+q[0]);const Z=g(q,(F=>(F="(?:"+(0,T.Cj)(F,".")+")").replace(X,(F=>{const E={signed:!1,separator:M.strict?A:[A,""],fractional:M.fractional,decimal:C,exponent:!1},T=F.split(".");let X=M.places;1===T.length&&1!==O&&(T[1]="###"),1===T.length||0===X?E.fractional=!1:(void 0===X&&(X=M.pattern?T[1].lastIndexOf("0")+1:1/0),X&&null==M.fractional&&(E.fractional=!0),!M.places&&+X<T[1].length&&(X+=","+T[1].length),E.places=X);const q=T[0].split(",");return q.length>1&&(E.groupSize=q.pop().length,q.length>1&&(E.groupSize2=q.pop().length)),"("+function u(M){"places"in(M=M||{})||(M.places=1/0),"string"!=typeof M.decimal&&(M.decimal="."),"fractional"in M&&!String(M.places).startsWith("0")||(M.fractional=[!0,!1]),"exponent"in M||(M.exponent=[!0,!1]),"eSigned"in M||(M.eSigned=[!0,!1]);const F=d(M),E=g(M.fractional,(F=>{let E="";return F&&0!==M.places&&(E="\\"+M.decimal,M.places===1/0?E="(?:"+E+"\\d+)?":E+="\\d{"+M.places+"}"),E}),!0);let T=F+E;return E&&(T="(?:(?:"+T+")|(?:"+E+"))"),T+g(M.exponent,(F=>F?"([eE]"+d({signed:M.eSigned})+")":""))}(E)+")"}))),!0);return{regexp:Z.replaceAll(/[\xa0 ]/g,"[\\s\\xa0]"),group:A,decimal:C,factor:O}}function p(M,F){const E=a(F),T=new RegExp("^"+E.regexp+"$").exec(M);if(!T)return NaN;let A=T[1];if(!T[1]){if(!T[2])return NaN;A=T[2],E.factor*=-1}return A=A.replaceAll(new RegExp("["+E.group+"\\s\\xa0]","g"),"").replace(E.decimal,"."),Number(A)*E.factor}function d(M){return"signed"in(M=M||{})||(M.signed=[!0,!1]),"separator"in M?"groupSize"in M||(M.groupSize=3):M.separator="",g(M.signed,(M=>M?"[-+]":""),!0)+g(M.separator,(F=>{if(!F)return"(?:\\d+)";" "===(F=(0,T.Cj)(F))?F="\\s":"\xa0"===F&&(F="\\s\\xa0");const E=M.groupSize,A=M.groupSize2;if(A){const M="(?:0|[1-9]\\d{0,"+(A-1)+"}(?:["+F+"]\\d{"+A+"})*["+F+"]\\d{"+E+"})";return E-A>0?"(?:"+M+"|(?:0|[1-9]\\d{0,"+(E-1)+"}))":M}return"(?:0|[1-9]\\d{0,"+(E-1)+"}(?:["+F+"]\\d{"+E+"})*)"}),!0)}const g=(M,F,E)=>{if(!(M instanceof Array))return F(M);const T=[];for(let A=0;A<M.length;A++)T.push(F(M[A]));return f(T.join("|"),Boolean(E))},f=(M,F)=>"("+(F?"?:":"")+M+")"},77026:(M,F,E)=>{E.d(F,{g:()=>T});const T={convertToGEGeometry:function s(M,F){return null==F?null:M.convertJSONToGeometry(F)},exportPoint:function n(M,F,E){const T=new i(M.getPointX(F),M.getPointY(F),E),A=M.hasZ(F),C=M.hasM(F);return A&&(T.z=M.getPointZ(F)),C&&(T.m=M.getPointM(F)),T},exportPolygon:function o(M,F,E){return new e(M.exportPaths(F),E,M.hasZ(F),M.hasM(F))},exportPolyline:function a(M,F,E){return new h(M.exportPaths(F),E,M.hasZ(F),M.hasM(F))},exportMultipoint:function c(M,F,E){return new r(M.exportPoints(F),E,M.hasZ(F),M.hasM(F))},exportExtent:function m(M,F,E){const T=M.hasZ(F),A=M.hasM(F),C=new x(M.getXMin(F),M.getYMin(F),M.getXMax(F),M.getYMax(F),E);if(T){const E=M.getZExtent(F);C.zmin=E.vmin,C.zmax=E.vmax}if(A){const E=M.getMExtent(F);C.mmin=E.vmin,C.mmax=E.vmax}return C}};class i{constructor(M,F,E){this.x=M,this.y=F,this.spatialReference=E,this.z=void 0,this.m=void 0}}class e{constructor(M,F,E,T){this.rings=M,this.spatialReference=F,this.hasZ=void 0,this.hasM=void 0,E&&(this.hasZ=E),T&&(this.hasM=T)}}class h{constructor(M,F,E,T){this.paths=M,this.spatialReference=F,this.hasZ=void 0,this.hasM=void 0,E&&(this.hasZ=E),T&&(this.hasM=T)}}class r{constructor(M,F,E,T){this.points=M,this.spatialReference=F,this.hasZ=void 0,this.hasM=void 0,E&&(this.hasZ=E),T&&(this.hasM=T)}}class x{constructor(M,F,E,T,A){this.xmin=M,this.ymin=F,this.xmax=E,this.ymax=T,this.spatialReference=A,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}},61816:(M,F,E)=>{E.d(F,{F:()=>o});var T=E(50886),A=E(30925),C=E(88965);const X={minX:0,minY:0,maxX:0,maxY:0};function e(M,F,E){(function t(M){X.minX=M[0],X.minY=M[1],X.maxX=M[2],X.maxY=M[3]})(F),M.search(X,E)}class o{constructor(){this._indexInvalid=!1,this._boundsToLoad=[],this._boundsById=new Map,this._idByBounds=new Map,this._index=new A.w(9,(0,T.A)("esri-csp-restrictions")?M=>({minX:M[0],minY:M[1],maxX:M[2],maxY:M[3]}):["[0]","[1]","[2]","[3]"]),this._loadIndex=()=>{if(this._indexInvalid){const M=new Array(this._idByBounds.size);let F=0;this._idByBounds.forEach(((E,T)=>{M[F++]=T})),this._indexInvalid=!1,this._index.clear(),this._index.load(M)}else this._boundsToLoad.length&&(this._index.load(Array.from(new Set(this._boundsToLoad.filter((M=>this._idByBounds.has(M)))))),this._boundsToLoad.length=0)}}get fullBounds(){if(!this._boundsById.size)return null;const M=(0,C.Ie)();for(const F of this._boundsById.values())F&&(M[0]=Math.min(F[0],M[0]),M[1]=Math.min(F[1],M[1]),M[2]=Math.max(F[2],M[2]),M[3]=Math.max(F[3],M[3]));return M}get valid(){return!this._indexInvalid}clear(){this._indexInvalid=!1,this._boundsToLoad.length=0,this._boundsById.clear(),this._idByBounds.clear(),this._index.clear()}delete(M){const F=this._boundsById.get(M);this._boundsById.delete(M),F&&(this._idByBounds.delete(F),this._indexInvalid||this._index.remove(F))}forEachInBounds(M,F){this._loadIndex(),e(this._index,M,(M=>F(this._idByBounds.get(M))))}get(M){return this._boundsById.get(M)}has(M){return this._boundsById.has(M)}invalidateIndex(){this._indexInvalid||(this._indexInvalid=!0,this._boundsToLoad.length=0)}set(M,F){if(!this._indexInvalid){const F=this._boundsById.get(M);F&&(this._index.remove(F),this._idByBounds.delete(F))}this._boundsById.set(M,F),F&&(this._idByBounds.set(F,M),this._indexInvalid||(this._boundsToLoad.push(F),this._boundsToLoad.length>5e4&&this._loadIndex()))}}},45691:(M,F,E)=>{E.d(F,{A:()=>m});var T=E(16842),A=E(4180),C=E(73067),X=E(89412),O=E(21374),q=E(88965),Z=E(32050),z=E(61816),D=E(23047),L=E(19464);const V=(0,O.vt)();class m{constructor(M){this.geometryInfo=M,this._boundsStore=new z.F,this._featuresById=new Map,this._markedIds=new Set,this.events=new C.A,this.featureAdapter=L.T}get geometryType(){return this.geometryInfo.geometryType}get hasM(){return this.geometryInfo.hasM}get hasZ(){return this.geometryInfo.hasZ}get numFeatures(){return this._featuresById.size}get fullBounds(){return this._boundsStore.fullBounds}get storeStatistics(){let M=0;return this._featuresById.forEach((F=>{null!=F.geometry&&F.geometry.coords&&(M+=F.geometry.coords.length)})),{featureCount:this._featuresById.size,vertexCount:M/(this.hasZ?this.hasM?4:3:this.hasM?3:2)}}getFullExtent(M){if(null==this.fullBounds)return null;const[F,E,T,A]=this.fullBounds;return{xmin:F,ymin:E,xmax:T,ymax:A,spatialReference:(0,D.ag)(M)}}add(M){this._add(M),this._emitChanged()}addMany(M){for(const F of M)this._add(F);this._emitChanged()}upsertMany(M){const F=M.map((M=>this._upsert(M)));return this._emitChanged(),F.filter(T.Ru)}clear(){this._featuresById.clear(),this._boundsStore.clear(),this._emitChanged()}removeById(M){const F=this._featuresById.get(M);return F?(this._remove(F),this._emitChanged(),F):null}removeManyById(M){this._boundsStore.invalidateIndex();for(const F of M){const M=this._featuresById.get(F);M&&this._remove(M)}this._emitChanged()}forEachBounds(M,F){for(const E of M){const M=this._boundsStore.get(E.objectId);M&&F((0,O.Jt)(V,M))}}getFeature(M){return this._featuresById.get(M)}has(M){return this._featuresById.has(M)}forEach(M){this._featuresById.forEach((F=>M(F)))}forEachInBounds(M,F){this._boundsStore.forEachInBounds(M,(M=>{F(this._featuresById.get(M))}))}startMarkingUsedFeatures(){this._boundsStore.invalidateIndex(),this._markedIds.clear()}sweep(){let M=!1;this._featuresById.forEach(((F,E)=>{this._markedIds.has(E)||(M=!0,this._remove(F))})),this._markedIds.clear(),M&&this._emitChanged()}_emitChanged(){this.events.emit("changed",void 0)}_add(M){var F;if(!M)return;const E=M.objectId;if(null==E)return void X.A.getLogger("esri.layers.graphics.data.FeatureStore").error(new A.A("featurestore:invalid-feature","feature id is missing",{feature:M}));const T=this._featuresById.get(E);let C;if(this._markedIds.add(E),T?(M.displayId=T.displayId,C=this._boundsStore.get(E),this._boundsStore.delete(E)):null!=this.onFeatureAdd&&this.onFeatureAdd(M),null===(F=M.geometry)||void 0===F||null===(F=F.coords)||void 0===F||!F.length)return this._boundsStore.set(E,null),void this._featuresById.set(E,M);C=(0,Z.jQ)(null!=C?C:(0,q.vt)(),M.geometry,this.geometryInfo.hasZ,this.geometryInfo.hasM),null!=C&&this._boundsStore.set(E,C),this._featuresById.set(E,M)}_upsert(M){var F;const E=null===M||void 0===M?void 0:M.objectId;if(null==E)return X.A.getLogger("esri.layers.graphics.data.FeatureStore").error(new A.A("featurestore:invalid-feature","feature id is missing",{feature:M})),null;const T=this._featuresById.get(E);if(!T)return this._add(M),M;this._markedIds.add(E);const{geometry:C,attributes:O}=M;for(const A in O)T.attributes[A]=O[A];return C&&(T.geometry=C,this._boundsStore.set(E,null!==(F=(0,Z.jQ)((0,q.vt)(),C,this.geometryInfo.hasZ,this.geometryInfo.hasM))&&void 0!==F?F:null)),T}_remove(M){null!=this.onFeatureRemove&&this.onFeatureRemove(M);const F=M.objectId;return this._markedIds.delete(F),this._boundsStore.delete(F),this._featuresById.delete(F),M}}},23047:(M,F,E)=>{E.d(F,{LQ:()=>y,ag:()=>h,pL:()=>a});var T=E(32050),A=E(41156);const C=new A.A,X=new A.A,O=new A.A,q={esriGeometryPoint:T.DF,esriGeometryPolyline:T.BW,esriGeometryPolygon:T.z5,esriGeometryMultipoint:T.qK};function y(M,F,E){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:M.hasZ,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:M.hasM;if(null==F)return null;const X=M.hasZ&&A,q=M.hasM&&C;if(E){const Z=(0,T.Nl)(O,F,M.hasZ,M.hasM,"esriGeometryPoint",E,A,C);return(0,T.DF)(Z,X,q)}return(0,T.DF)(F,X,q)}function a(M,F,E,A,Z,z){var D,L;let V=arguments.length>6&&void 0!==arguments[6]?arguments[6]:F,K=arguments.length>7&&void 0!==arguments[7]?arguments[7]:E;const J=F&&V,Q=E&&K,$=null!=A?"coords"in A?A:A.geometry:null;if(null==$)return null;if(Z){var W,H;let A=(0,T.kz)(X,$,F,E,M,Z,V,K);return z&&(A=(0,T.Nl)(O,A,J,Q,M,z)),null!==(W=null===(H=q[M])||void 0===H?void 0:H.call(q,A,J,Q))&&void 0!==W?W:null}if(z){var ee,te;const A=(0,T.Nl)(O,$,F,E,M,z,V,K);return null!==(ee=null===(te=q[M])||void 0===te?void 0:te.call(q,A,J,Q))&&void 0!==ee?ee:null}return(0,T.Q4)(C,$,F,E,V,K),null!==(D=null===(L=q[M])||void 0===L?void 0:L.call(q,C,J,Q))&&void 0!==D?D:null}function h(M){return M&&Z in M?JSON.parse(JSON.stringify(M,G)):M}const Z="_geVersion",G=(M,F)=>M!==Z?F:void 0},22786:(M,F,E)=>{E.d(F,{Cv:()=>j,Nk:()=>x,lK:()=>b});var T=E(16842),A=E(81618),C=E(54208),X=E(77026),O=E(78395),q=E(80417);const Z=[0,0];function h(M,F){if(!F)return null;if("x"in F){const E={x:0,y:0};return[E.x,E.y]=M(F.x,F.y,Z),null!=F.z&&(E.z=F.z),null!=F.m&&(E.m=F.m),E}if("xmin"in F){const E={xmin:0,ymin:0,xmax:0,ymax:0};return[E.xmin,E.ymin]=M(F.xmin,F.ymin,Z),[E.xmax,E.ymax]=M(F.xmax,F.ymax,Z),F.hasZ&&(E.zmin=F.zmin,E.zmax=F.zmax,E.hasZ=!0),F.hasM&&(E.mmin=F.mmin,E.mmax=F.mmax,E.hasM=!0),E}return"rings"in F?{rings:l(F.rings,M),hasM:F.hasM,hasZ:F.hasZ}:"paths"in F?{paths:l(F.paths,M),hasM:F.hasM,hasZ:F.hasZ}:"points"in F?{points:f(F.points,M),hasM:F.hasM,hasZ:F.hasZ}:null}function l(M,F){const E=[];for(const T of M)E.push(f(T,F));return E}function f(M,F){const E=[];for(const T of M){const M=F(T[0],T[1],[0,0]);E.push(M),T.length>2&&M.push(T[2]),T.length>3&&M.push(T[3])}return E}async function x(M,F){if(!M||!F)return;const E=Array.isArray(M)?M.map((M=>null!=M.geometry?M.geometry.spatialReference:null)).filter(T.Ru):[M];await(0,C.initializeProjection)(E.map((M=>({source:M,dest:F}))))}const z=h.bind(null,q.je),D=h.bind(null,q.tD);function j(M,F,E,T){if(!M)return M;if(E||(E=F,F=M.spatialReference),!(0,O.fn)(F)||!(0,O.fn)(E)||(0,O.aI)(F,E))return M;if((0,q.y7)(F,E)){const F=(0,O.K8)(E)?z(M):D(M);return F.spatialReference=E,F}return(0,C.projectMany)(X.g,[M],F,E,null,T)[0]}const L=new class _{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(M,F,E,T){var C;if(null===M||void 0===M||!M.length||!F||!E||(0,O.aI)(F,E))return M;const X={geometries:M,inSpatialReference:F,outSpatialReference:E,geographicTransformation:T,resolve:(0,A.Tw)()};return this._jobs.push(X),null!==(C=this._timer)&&void 0!==C||(this._timer=setTimeout(this._process,10)),X.resolve.promise}_process(){this._timer=null;const M=this._jobs.shift();if(!M)return;const{geometries:F,inSpatialReference:E,outSpatialReference:T,resolve:A,geographicTransformation:Z}=M;(0,q.y7)(E,T)?(0,O.K8)(T)?A(F.map(z)):A(F.map(D)):A((0,C.projectMany)(X.g,F,E,T,Z,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}};function b(M,F,E,T){return L.push(M,F,E,T)}},70857:(M,F,E)=>{E.d(F,{GC:()=>S,T2:()=>j,v8:()=>L});var T=E(40530),A=E(49049),C=E(54208),X=E(25076),O=E(31670),q=E(30172),Z=E(78395),z=E(22786);const D=new T.J({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),L=Object.freeze({});async function S(M,F,E){const{outFields:T,orderByFields:A,groupByFieldsForStatistics:C,outStatistics:X}=M;if(T)for(let O=0;O<T.length;O++)T[O]=T[O].trim();if(A)for(let O=0;O<A.length;O++)A[O]=A[O].trim();if(C)for(let O=0;O<C.length;O++)C[O]=C[O].trim();if(X)for(let O=0;O<X.length;O++)X[O].onStatisticField&&(X[O].onStatisticField=X[O].onStatisticField.trim());return M.geometry&&!M.outSR&&(M.outSR=M.geometry.spatialReference),j(M,F,E)}async function j(M,F,T){var C;if(!M)return null;let{where:V}=M;if(M.where=V=null===(C=V)||void 0===C?void 0:C.trim(),(!V||/^1 *= *1$/.test(V)||F&&F===V)&&(M.where=null),!M.geometry)return M;let K=await async function d(M){const{distance:F,units:T}=M,C=M.geometry;if(null==F||"vertexAttributes"in C)return C;const X=C.spatialReference,O=T?D.fromJSON(T):(0,A.Ij)(X),q=X&&((0,Z.EA)(X)||(0,Z.K8)(X))?C:await(0,z.Nk)(X,Z.KK).then((()=>(0,z.Cv)(C,Z.KK)));return(await async function U(){return(await Promise.all([E.e(8300),E.e(6282)]).then(E.bind(E,93901))).geodesicBuffer}())(q.spatialReference,q,F,O)}(M);if(M.distance=0,M.units=null,"esriSpatialRelEnvelopeIntersects"===M.spatialRel){const{spatialReference:F}=M.geometry;K=(0,X.HA)(K),K.spatialReference=F}if(K){var J;await(0,z.Nk)(K.spatialReference,T),K=function x(M,F){const E=M.spatialReference;return w(M,F)&&(0,O.ZC)(M)?{spatialReference:E,rings:[[[M.xmin,M.ymin],[M.xmin,M.ymax],[M.xmax,M.ymax],[M.xmax,M.ymin],[M.xmin,M.ymin]]]}:M}(K,T);const F=(await(0,q.el)((0,O.rS)(K)))[0];if(null==F)throw L;const E="quantizationParameters"in M&&(null===(J=M.quantizationParameters)||void 0===J?void 0:J.tolerance)||"maxAllowableOffset"in M&&M.maxAllowableOffset||0,A=E&&w(K,T)?{densificationStep:8*E}:void 0,C=F.toJSON(),X=(0,z.Cv)(C,C.spatialReference,T,A);if(!X)throw L;X.spatialReference=T,M.geometry=X}return M}function w(M,F){if(!M)return!1;const E=M.spatialReference;return((0,O.ZC)(M)||(0,O.Bi)(M)||(0,O.Rg)(M))&&!(0,Z.aI)(E,F)&&!(0,C.canProjectWithoutEngine)(E,F)}},70564:(M,F,E)=>{E.d(F,{tC:()=>I,c0:()=>P,xt:()=>v});var T=E(4180),A=E(94224),C=E(5522);var X=E(31670),O=E(78395);function n(M,F){return M?F?4:3:F?3:2}function contains_r(M,F,E,T,A,C){const X=n(A,C),{coords:O,lengths:q}=T;if(!q)return!1;for(let Z=0,z=0;Z<q.length;Z++,z+=X)if(!o(M,F,E,O[z],O[z+1]))return!1;return!0}function o(M,F,E,T,A){if(!M)return!1;const C=n(F,E),{coords:X,lengths:O}=M;let q=!1,Z=0;for(const z of O)q=e(q,X,C,Z,z,T,A),Z+=z*C;return q}function e(M,F,E,T,A,C,X){let O=M,q=T;for(let Z=T,z=T+A*E;Z<z;Z+=E){q=Z+E,q===z&&(q=T);const M=F[Z],A=F[Z+1],D=F[q],L=F[q+1];(A<X&&L>=X||L<X&&A>=X)&&M+(X-A)/(L-A)*(D-M)<C&&(O=!O)}return O}var q=E(32050),Z=E(41156),z=E(23047),D=E(22786);const L="unsupported-query",V={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},K={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function v(M,F,T,O,D){if((0,X.Bi)(F)&&"esriGeometryPoint"===T&&("esriSpatialRelIntersects"===M||"esriSpatialRelContains"===M)){const M=(0,q.Ye)(new Z.A,F,!1,!1);return Promise.resolve((F=>function t(M,F,E,T){return o(M,F,E,T.coords[0],T.coords[1])}(M,!1,!1,F)))}if((0,X.Bi)(F)&&"esriGeometryMultipoint"===T){const E=(0,q.Ye)(new Z.A,F,!1,!1);if("esriSpatialRelContains"===M)return Promise.resolve((M=>contains_r(E,!1,!1,M,O,D)))}if((0,X.ZC)(F)&&"esriGeometryPoint"===T&&("esriSpatialRelIntersects"===M||"esriSpatialRelContains"===M))return Promise.resolve((M=>(0,A.qz)(F,(0,z.pL)(T,O,D,M))));if((0,X.ZC)(F)&&"esriGeometryMultipoint"===T&&"esriSpatialRelContains"===M)return Promise.resolve((M=>(0,A.rL)(F,(0,z.pL)(T,O,D,M))));if((0,X.ZC)(F)&&"esriSpatialRelIntersects"===M){const M=function s(M){return"mesh"===M?C.xB:(0,C.xK)(M)}(T);return Promise.resolve((E=>M(F,(0,z.pL)(T,O,D,E))))}return function h(){return Promise.all([E.e(8300),E.e(6282)]).then(E.bind(E,93901))}().then((E=>{const A=E[V[M]].bind(null,F.spatialReference,F);return M=>A((0,z.pL)(T,O,D,M))}))}async function P(M,F,E){const{spatialRel:A,geometry:C}=M;if(C){if(!function G(M){return null!=M&&!0===K.spatialRelationship[M]}(A))throw new T.A(L,"Unsupported query spatial relationship",{query:M});if((0,O.fn)(C.spatialReference)&&(0,O.fn)(E)){var q;if(!function g(M){return null!=M&&!0===K.queryGeometry[(0,X.$B)(M)]}(C))throw new T.A(L,"Unsupported query geometry type",{query:M});if(!function j(M){return null!=M&&!0===K.layerGeometry[M]}(F))throw new T.A(L,"Unsupported layer geometry type",{query:M});if(M.outSR)return(0,D.Nk)(null===(q=M.geometry)||void 0===q?void 0:q.spatialReference,M.outSR)}}}function I(M){if((0,X.ZC)(M))return!0;if((0,X.Bi)(M)){for(const F of M.rings){if(5!==F.length)return!1;if(F[0][0]!==F[1][0]||F[0][0]!==F[4][0]||F[2][0]!==F[3][0]||F[0][1]!==F[3][1]||F[0][1]!==F[4][1]||F[1][1]!==F[2][1])return!1}return!0}return!1}},66174:(M,F,E)=>{async function n(M,F){if(!M)return null;const E=F.featureAdapter,{startTimeField:T,endTimeField:A}=M;let C=Number.POSITIVE_INFINITY,X=Number.NEGATIVE_INFINITY;if(T&&A)await F.forEach((M=>{const F=E.getAttribute(M,T),O=E.getAttribute(M,A);null==F||isNaN(F)||(C=Math.min(C,F)),null==O||isNaN(O)||(X=Math.max(X,O))}));else{const M=T||A;await F.forEach((F=>{const T=E.getAttribute(F,M);null==T||isNaN(T)||(C=Math.min(C,T),X=Math.max(X,T))}))}return{start:C,end:X}}function t(M,F,E){var T,A;if(!F||!M)return null;const{startTimeField:C,endTimeField:X}=M;if(!C&&!X)return null;const{start:O,end:q}=F;if(null===O&&null===q)return null;if(void 0===O&&void 0===q)return()=>!1;const Z=null!==(T=null===(A=E.getAttributeAsTimestamp)||void 0===A?void 0:A.bind(E))&&void 0!==T?T:E.getAttribute.bind(E);return C&&X?function l(M,F,E,T,A){return null!=T&&null!=A?C=>{const X=M(C,F),O=M(C,E);return(null==X||X<=A)&&(null==O||O>=T)}:null!=T?F=>{const A=M(F,E);return null==A||A>=T}:null!=A?E=>{const T=M(E,F);return null==T||T<=A}:void 0}(Z,C,X,O,q):function u(M,F,E,T){return null!=E&&null!=T&&E===T?T=>M(T,F)===E:null!=E&&null!=T?A=>{const C=M(A,F);return null!=C&&C>=E&&C<=T}:null!=E?T=>{const A=M(T,F);return null!=A&&A>=E}:null!=T?E=>{const A=M(E,F);return null!=A&&A<=T}:void 0}(Z,C||X,O,q)}E.d(F,{I:()=>t,W:()=>n})},69405:(M,F,E)=>{E.r(F),E.d(F,{default:()=>P});E(30174);var T=E(53705),A=E(87149),C=E(62408),X=E(4180),O=E(89412),q=E(81618),Z=E(4270),z=E(54208),D=E(77026),L=E(78395),V=E(80417),K=E(57224),J=E(41156),Q=E(45691),$=E(22786),W=E(56103),H=E(14745),ee=E(57022);const te=/^\s*"([\S\s]*)"\s*$/,ne=/""/g,ie="\n",se=[","," ",";","|","\t"];function*u(M,F,E){let T=0;for(;T<=M.length;){const A=M.indexOf(F,T),C=M.substring(T,A>-1?A:void 0);T+=C.length+F.length,E&&!C.trim()||(yield C)}}function csv_c(M){const F=M.includes("\r\n")?"\r\n":ie;return u(M,F,!0)}function d(M,F){return u(M,F,!1)}function csv_f(M,F,E){var T;M=M.trim(),F=null===(T=F)||void 0===T?void 0:T.trim();const A=[],C=Array.from(new Set([null===E||void 0===E?void 0:E.delimiter,...se])).filter((M=>null!=M));for(const q of C){var X;const E=m(M,q).length,T=null!==(X=m(F,q).length)&&void 0!==X?X:E;E>1&&A.push({weight:Math.min(E,T),delimiter:q})}const O=A.sort(((M,F)=>{let{weight:E}=M,{weight:T}=F;return T-E})).map((M=>{let{delimiter:F}=M;return F}));for(const q of O){const F=h(g(M,q).names,null===E||void 0===E?void 0:E.longitudeField,null===E||void 0===E?void 0:E.latitudeField);if(F.longitudeFieldName&&F.latitudeFieldName)return{delimiter:q,locationInfo:F}}return{delimiter:O[0],locationInfo:null}}function csv_a(M,F,E){let T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:()=>Object.create(null);return function*(){const A=csv_c(M);A.next();let C="",X="",O=0,q=T(),Z=0;e:for(const M of A){const A=d(M,E);for(const M of A)if(C+=X+M,X="",O+=p(M),O%2==0){if(O>0){const M=te.exec(C);if(!M){q=T(),Z=0,C="",O=0;continue e}q[F[Z]]=M[1].replaceAll(ne,'"'),Z++}else q[F[Z]]=C,Z++;C="",O=0}else X=E;0===O?(yield q,q=T(),Z=0):X=ie}}()}function g(M,F){const E=m(M,F).filter((M=>null!=M)),T=E.map((M=>(0,ee.rS)(M)));for(let A=T.length-1;A>=0;A--)T[A]||(T.splice(A,1),E.splice(A,1));return{names:T,aliases:E}}function m(M,F){if(null===M||void 0===M||!M.length)return[];const E=[];let T="",A="",C=0;const X=d(M,F);for(const O of X)if(T+=A+O,A="",C+=p(O),C%2==0){if(C>0){const M=te.exec(T);M&&E.push(M[1].replaceAll(ne,'"'))}else E.push(T);T="",C=0}else A=F;return E}function p(M){let F=0,E=0;for(E=M.indexOf('"',E);E>=0;)F++,E=M.indexOf('"',E+1);return F}function h(M,F,E){var T,A;F=null===(T=(0,ee.rS)(F))||void 0===T?void 0:T.toLowerCase(),E=null===(A=(0,ee.rS)(E))||void 0===A?void 0:A.toLowerCase();const C=M.map((M=>M.toLowerCase())),X=F?M[C.indexOf(F)]:null,O=E?M[C.indexOf(E)]:null;return{longitudeFieldName:X||M[C.indexOf(ae.find((M=>C.includes(M))))],latitudeFieldName:O||M[C.indexOf(oe.find((M=>C.includes(M))))]}}function N(M){if(!M.length)return"string";const F=/[^+\-.,0-9]/;return M.map((M=>{if(""!==M){if(!F.test(M)){let F=re(M);if(!isNaN(F))return/[.,]/.test(M)||!Number.isInteger(F)||F>214783647||F<-214783648?"double":"integer";if(M.includes("E")){if(F=Number(M),!Number.isNaN(F))return"double";if(M.includes(",")&&(M=M.replace(",","."),F=Number(M),!Number.isNaN(F)))return"double"}}return(0,C.Cq)(M)?"date":"string"}})).reduce(((M,F)=>void 0===M?F:void 0===F?M:M===F?F:"string"===M||"string"===F?"string":"double"===M||"double"===F?"double":void 0))}const re=function(){const M=(0,H.B)(),F=new RegExp("^"+M.regexp+"$"),E=new RegExp("["+M.group+"\\s\\xa0]","g"),T=M.factor;return A=>{const C=F.exec(A);if(M.factor=T,!C)return NaN;let X=C[1];if(!C[1]){if(!C[2])return NaN;X=C[2],M.factor*=-1}return X=X.replace(E,"").replace(M.decimal,"."),+X*M.factor}}(),oe=["lat","latitude","latitude83","latdecdeg","lat_dd","y","ycenter","point_y"],ae=["lon","lng","long","longitude","longitude83","longdecdeg","long_dd","x","xcenter","point_x"];var le=E(39584),ue=E(8084),ce=E(52994),he=E(98664);const de=(0,le.F0)("esriGeometryPoint"),fe=["csv"],me=[0,0];class k{constructor(M,F){this.x=M,this.y=F}}class P{constructor(){this._queryEngine=null,this._snapshotFeatures=async M=>{const F=await this._fetch(M);return this._createFeatures(F)}}destroy(){var M;null!==(M=this._queryEngine)&&void 0!==M&&M.destroy(),this._queryEngine=null}async load(M){var F;let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._loadOptions=M;const[T]=await Promise.all([this._fetch(E.signal),this._checkProjection(null===M||void 0===M||null===(F=M.parsingOptions)||void 0===F?void 0:F.spatialReference)]),A=function R(M,F){var E,T,A;const C=F.parsingOptions||{},O={delimiter:C.delimiter,layerDefinition:null,locationInfo:{latitudeFieldName:C.latitudeField,longitudeFieldName:C.longitudeField}},q=O.layerDefinition={name:(0,Z.e7)(F.url,fe)||"csv",dateFieldsTimeReference:{timeZoneIANA:ce.n$},drawingInfo:de,geometryType:"esriGeometryPoint",objectIdField:null,fields:[],timeInfo:C.timeInfo,extent:{xmin:Number.POSITIVE_INFINITY,ymin:Number.POSITIVE_INFINITY,xmax:Number.NEGATIVE_INFINITY,ymax:Number.NEGATIVE_INFINITY,spatialReference:C.spatialReference||{wkid:4326}}},z=csv_c(M),D=null===(E=z.next().value)||void 0===E?void 0:E.trim(),L=null===(T=z.next().value)||void 0===T?void 0:T.trim();if(!D)throw new X.A("csv-layer:empty-csv","CSV is empty",{csv:M});const{delimiter:V,locationInfo:K}=csv_f(D,L,C);if(!V)throw new X.A("csv-layer:invalid-delimiter","Unable to detect the delimiter from CSV",{firstLine:D,secondLine:L,parsingOptions:C});if(!K)throw new X.A("csv-layer:location-fields-not-found","Unable to identify latitude and longitude fields from the CSV file",{firstLine:D,secondLine:L,parsingOptions:C});O.locationInfo=K,O.delimiter=V;const{names:J,aliases:Q}=g(D,V),$=function b(M,F,E,T,A){const C=[],X=csv_a(M,E,F),O=[];for(const q of X){if(10===O.length)break;O.push(q)}for(let q=0;q<E.length;q++){const M=E[q],F=T[q];if(M===A.longitudeFieldName||M===A.latitudeFieldName)C.push({name:M,type:"esriFieldTypeDouble",alias:F});else{let E;switch(N(O.map((F=>F[M])))){case"integer":E="esriFieldTypeInteger";break;case"double":E="esriFieldTypeDouble";break;case"date":E="esriFieldTypeDate";break;default:E="esriFieldTypeString"}C.push({name:M,type:E,alias:F,length:(0,ee._b)(E)})}}return C}(M,O.delimiter,J,Q,O.locationInfo);if(null!==(A=C.fields)&&void 0!==A&&A.length){const M=new ue.A(C.fields);for(const F of $){const E=M.get(F.name);E&&Object.assign(F,E)}}if(!$.some((M=>"esriFieldTypeOID"===M.type&&(q.objectIdField=M.name,!0)))){const M={name:"__OBJECTID",alias:"__OBJECTID",type:"esriFieldTypeOID",editable:!1,nullable:!1};q.objectIdField=M.name,$.unshift(M)}q.fields=$;const W=new ue.A(q.fields);if(O.locationInfo&&(O.locationInfo.latitudeFieldName=W.get(O.locationInfo.latitudeFieldName).name,O.locationInfo.longitudeFieldName=W.get(O.locationInfo.longitudeFieldName).name),q.timeInfo){const M=q.timeInfo;if(M.startTimeField){const F=W.get(M.startTimeField);F?(M.startTimeField=F.name,F.type="esriFieldTypeDate"):M.startTimeField=null}if(M.endTimeField){const F=W.get(M.endTimeField);F?(M.endTimeField=F.name,F.type="esriFieldTypeDate"):M.endTimeField=null}if(M.trackIdField){const F=W.get(M.trackIdField);M.trackIdField=F?F.name:null}M.startTimeField||M.endTimeField||(q.timeInfo=null)}return O}(T,M);this._locationInfo=A.locationInfo,this._delimiter=A.delimiter,this._queryEngine=this._createQueryEngine(A);const C=await this._createFeatures(T);this._queryEngine.featureStore.addMany(C);const{fullExtent:O,timeExtent:q}=await this._queryEngine.fetchRecomputedExtents();if(A.layerDefinition.extent=O,q){const{start:M,end:F}=q;A.layerDefinition.timeInfo.timeExtent=[M,F]}return A}async applyEdits(){throw new X.A("csv-layer:editing-not-supported","applyEdits() is not supported on CSVLayer")}async queryFeatures(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(M,F.signal)}async queryFeatureCount(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(M,F.signal)}async queryObjectIds(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(M,F.signal)}async queryExtent(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(M,F.signal)}async querySnapping(M){let F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(M,F.signal)}async refresh(M){var F;this._loadOptions.customParameters=M,null!==(F=this._snapshotTask)&&void 0!==F&&F.abort(),this._snapshotTask=(0,A.UT)(this._snapshotFeatures),this._snapshotTask.promise.then((M=>{this._queryEngine.featureStore.clear(),M&&this._queryEngine.featureStore.addMany(M)}),(M=>{this._queryEngine.featureStore.clear(),(0,q.zf)(M)||O.A.getLogger("esri.layers.CSVLayer").error(new X.A("csv-layer:refresh","An error occurred during refresh",{error:M}))})),await this._waitSnapshotComplete();const{fullExtent:E,timeExtent:T}=await this._queryEngine.fetchRecomputedExtents();return{extent:E,timeExtent:T}}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(M){const{url:F,customParameters:E}=this._loadOptions;if(!F)throw new X.A("csv-layer:invalid-source","url not defined");const A=(0,Z.An)(F);return(await(0,T.A)(A.path,{query:{...A.query,...E},responseType:"text",signal:M})).data}_createQueryEngine(M){const{objectIdField:F,fields:E,extent:T,timeInfo:A}=M.layerDefinition,C=new Q.A({geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1});return new W.d({fieldsIndex:ue.A.fromLayerJSON({fields:E,dateFieldsTimeReference:{timeZoneIANA:ce.n$}}),geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1,timeInfo:A,objectIdField:F,spatialReference:T.spatialReference||{wkid:4326},cacheSpatialQueries:!0,featureStore:C})}async _createFeatures(M){const{latitudeFieldName:F,longitudeFieldName:E}=this._locationInfo,{objectIdField:T,fieldsIndex:A,spatialReference:X}=this._queryEngine;let O=[];const q=[],Z=A.fields.filter((M=>M.name!==T)).map((M=>M.name));let Q=0;const $={};for(const C of A.fields)if("esriFieldTypeOID"!==C.type&&"esriFieldTypeGlobalID"!==C.type){const M=(0,ee.lD)(C);void 0!==M&&($[C.name]=M)}const W=csv_a(M,Z,this._delimiter,(0,le.Vx)($,T));for(const z of W){const M=this._parseCoordinateValue(z[F]),X=this._parseCoordinateValue(z[E]);if(null!=X&&null!=M&&!isNaN(M)&&!isNaN(X)){z[F]=M,z[E]=X;for(const M in z)if(M!==F&&M!==E)if(A.isDateField(M))z[M]=(0,C._U)(z[M]);else if(A.isNumericField(M)){const F=re(z[M]);isNaN(F)?z[M]=null:z[M]=F}z[T]=Q,Q++,O.push(new k(X,M)),q.push(z)}}if(!(0,L.aI)({wkid:4326},X))if((0,L.K8)(X))for(const C of O)[C.x,C.y]=(0,V.je)(C.x,C.y,me);else O=(0,z.projectMany)(D.g,O,he.A.WGS84,X,null,null);const H=[];for(let C=0;C<O.length;C++){const{x:M,y:F}=O[C],E=q[C];E[T]=C+1,H.push(new K.Om(new J.A([],[M,F]),E,null,E[T]))}return H}_parseCoordinateValue(M){if(null==M||""===M)return null;let F=re(M);return(isNaN(F)||Math.abs(F)>181)&&(F=parseFloat(M)),F}async _checkProjection(M){try{await(0,$.Nk)(L.KK,M)}catch{throw new X.A("csv-layer:projection-not-supported","Projection not supported")}}}}}]);
//# sourceMappingURL=6023.bdabf188.chunk.js.map