"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[6211],{76211:(n,e,t)=>{t.r(e),t.d(e,{buffer:()=>L,changeDefaultSpatialReferenceTolerance:()=>X,clearDefaultSpatialReferenceTolerance:()=>Y,clip:()=>y,contains:()=>p,convexHull:()=>j,crosses:()=>m,cut:()=>w,densify:()=>C,difference:()=>E,disjoint:()=>A,distance:()=>d,equals:()=>g,extendedSpatialReferenceInfo:()=>l,flipHorizontal:()=>I,flipVertical:()=>q,generalize:()=>B,geodesicArea:()=>K,geodesicBuffer:()=>P,geodesicDensify:()=>U,geodesicLength:()=>M,intersect:()=>D,intersectLinesToPoints:()=>Q,intersects:()=>h,isSimple:()=>J,nearestCoordinate:()=>T,nearestVertex:()=>V,nearestVertices:()=>z,offset:()=>v,overlaps:()=>O,planarArea:()=>W,planarLength:()=>F,relate:()=>R,rotate:()=>H,simplify:()=>N,symmetricDifference:()=>k,touches:()=>S,union:()=>b,within:()=>x});t(30174);var c=t(80563),_=t(57264),$=t(31670);function r(n){var e;return Array.isArray(n)?null===(e=n[0])||void 0===e?void 0:e.spatialReference:null===n||void 0===n?void 0:n.spatialReference}function a(n){return n?Array.isArray(n)?n.map(a):n.toJSON?n.toJSON():n:n}function i(n){return Array.isArray(n)?n.map((n=>(0,$.rS)(n))):(0,$.rS)(n)}let nn;async function u(){return nn||(nn=(0,c.ho)("geometryEngineWorker",{strategy:"distributed"})),nn}async function s(n,e){return(await u()).invoke("executeGEOperation",{operation:n,parameters:a(e)})}async function f(n,e){const t=await u();return Promise.all(t.broadcast("executeGEOperation",{operation:n,parameters:a(e)}))}function l(n){return s("extendedSpatialReferenceInfo",[n])}async function y(n,e){return i(await s("clip",[r(n),n,e]))}async function w(n,e){return i(await s("cut",[r(n),n,e]))}function p(n,e){return s("contains",[r(n),n,e])}function m(n,e){return s("crosses",[r(n),n,e])}function d(n,e,t){return s("distance",[r(n),n,e,t])}function g(n,e){return s("equals",[r(n),n,e])}function h(n,e){return s("intersects",[r(n),n,e])}function S(n,e){return s("touches",[r(n),n,e])}function x(n,e){return s("within",[r(n),n,e])}function A(n,e){return s("disjoint",[r(n),n,e])}function O(n,e){return s("overlaps",[r(n),n,e])}function R(n,e,t){return s("relate",[r(n),n,e,t])}function J(n){return s("isSimple",[r(n),n])}async function N(n){return i(await s("simplify",[r(n),n]))}async function j(n){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return i(await s("convexHull",[r(n),n,e]))}async function E(n,e){return i(await s("difference",[r(n),n,e]))}async function k(n,e){return i(await s("symmetricDifference",[r(n),n,e]))}async function D(n,e){return i(await s("intersect",[r(n),n,e]))}async function b(n){const e=function o(n,e){let t;return Array.isArray(n)?t=n:(t=[],t.push(n),null!=e&&t.push(e)),t}(n,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null);return i(await s("union",[r(e),e]))}async function v(n,e,t,c,_,$){return i(await s("offset",[r(n),n,e,t,c,_,$]))}async function L(n,e,t){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const _=[r(n),n,e,t,c];return i(await s("buffer",_))}async function P(n,e,t,c,_,$){const nn=[r(n),n,e,t,c,_,$];return i(await s("geodesicBuffer",nn))}async function T(n,e){let t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const c=await s("nearestCoordinate",[r(n),n,e,t]);return{...c,coordinate:_.A.fromJSON(c.coordinate)}}async function V(n,e){const t=await s("nearestVertex",[r(n),n,e]);return{...t,coordinate:_.A.fromJSON(t.coordinate)}}async function z(n,e,t,c){return(await s("nearestVertices",[r(n),n,e,t,c])).map((n=>({...n,coordinate:_.A.fromJSON(n.coordinate)})))}function G(n){var e;return"xmin"in n?n.center:"x"in n?n:null===(e=n.extent)||void 0===e?void 0:e.center}async function H(n,e,t){var c;if(null==n)throw new Z;const _=n.spatialReference;if(null==(t=null!==(c=t)&&void 0!==c?c:G(n)))throw new Z;const $=n.constructor.fromJSON(await s("rotate",[_,n,e,t]));return $.spatialReference=_,$}async function I(n,e){var t;if(null==n)throw new Z;const c=n.spatialReference;if(null==(e=null!==(t=e)&&void 0!==t?t:G(n)))throw new Z;const _=n.constructor.fromJSON(await s("flipHorizontal",[c,n,e]));return _.spatialReference=c,_}async function q(n,e){var t;if(null==n)throw new Z;const c=n.spatialReference;if(null==(e=null!==(t=e)&&void 0!==t?t:G(n)))throw new Z;const _=n.constructor.fromJSON(await s("flipVertical",[c,n,e]));return _.spatialReference=c,_}async function B(n,e,t,c){return i(await s("generalize",[r(n),n,e,t,c]))}async function C(n,e,t){return i(await s("densify",[r(n),n,e,t]))}async function U(n,e,t){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return i(await s("geodesicDensify",[r(n),n,e,t,c]))}function W(n,e){return s("planarArea",[r(n),n,e])}function F(n,e){return s("planarLength",[r(n),n,e])}function K(n,e,t){return s("geodesicArea",[r(n),n,e,t])}function M(n,e,t){return s("geodesicLength",[r(n),n,e,t])}async function Q(n,e){return i(await s("intersectLinesToPoints",[r(n),n,e]))}async function X(n,e){await f("changeDefaultSpatialReferenceTolerance",[n,e])}async function Y(n){await f("clearDefaultSpatialReferenceTolerance",[n])}class Z extends Error{constructor(){super("Illegal Argument Exception")}}}}]);
//# sourceMappingURL=6211.7bbd3f55.chunk.js.map