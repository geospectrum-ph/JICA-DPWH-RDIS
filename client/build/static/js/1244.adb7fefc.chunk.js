"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[1244],{53395:(A,C,M)=>{function n(){return new Float32Array(3)}function t(A){const C=new Float32Array(3);return C[0]=A[0],C[1]=A[1],C[2]=A[2],C}function r(A,C,M){const U=new Float32Array(3);return U[0]=A,U[1]=C,U[2]=M,U}function o(){return n()}function u(){return r(1,1,1)}function c(){return r(1,0,0)}function i(){return r(0,1,0)}function a(){return r(0,0,1)}M.d(C,{fA:()=>r,o8:()=>t,vt:()=>n});const U=o(),T=u(),_=c(),S=i(),x=a();Object.freeze(Object.defineProperty({__proto__:null,ONES:T,UNIT_X:_,UNIT_Y:S,UNIT_Z:x,ZEROS:U,clone:t,create:n,createView:function e(A,C){return new Float32Array(A,C,3)},fromValues:r,ones:u,unitX:c,unitY:i,unitZ:a,zeros:o},Symbol.toStringTag,{value:"Module"}))},3394:(A,C,M)=>{M.d(C,{A:()=>L});var U,T=M(80671),_=M(66004),S=M(57453),x=(M(50886),M(89412),M(99825)),V=M(68682),z=M(61919),k=M(4182),F=M(22123),Z=M(83375),j=M(6493);let D=U=class extends Z.oY{constructor(){super(...arguments),this.description=null,this.label=null,this.minValue=0,this.maxValue=0,this.color=null}clone(){return new U({description:this.description,label:this.label,minValue:this.minValue,maxValue:this.maxValue,color:(0,_.o8)(this.color)})}};(0,T._)([(0,S.MZ)({type:String,json:{write:!0}})],D.prototype,"description",void 0),(0,T._)([(0,S.MZ)({type:String,json:{write:!0}})],D.prototype,"label",void 0),(0,T._)([(0,S.MZ)({type:Number,json:{read:{source:"classMinValue"},write:{target:"classMinValue"}}})],D.prototype,"minValue",void 0),(0,T._)([(0,S.MZ)({type:Number,json:{read:{source:"classMaxValue"},write:{target:"classMaxValue"}}})],D.prototype,"maxValue",void 0),(0,T._)([(0,S.MZ)({type:F.A,json:{type:[j.jz],write:!0}})],D.prototype,"color",void 0),D=U=(0,T._)([(0,V.$)("esri.renderers.support.pointCloud.ColorClassBreakInfo")],D);const B=D;var P;let R=P=class extends z.A{constructor(A){super(A),this.type="point-cloud-class-breaks",this.field=null,this.legendOptions=null,this.fieldTransformType=null,this.colorClassBreakInfos=null}clone(){return new P({...this.cloneProperties(),field:this.field,fieldTransformType:this.fieldTransformType,colorClassBreakInfos:(0,_.o8)(this.colorClassBreakInfos),legendOptions:(0,_.o8)(this.legendOptions)})}};(0,T._)([(0,x.e)({pointCloudClassBreaksRenderer:"point-cloud-class-breaks"})],R.prototype,"type",void 0),(0,T._)([(0,S.MZ)({json:{write:!0},type:String})],R.prototype,"field",void 0),(0,T._)([(0,S.MZ)({type:k.q,json:{write:!0}})],R.prototype,"legendOptions",void 0),(0,T._)([(0,S.MZ)({type:z.A.fieldTransformTypeKebabDict.apiValues,json:{type:z.A.fieldTransformTypeKebabDict.jsonValues,read:z.A.fieldTransformTypeKebabDict.read,write:z.A.fieldTransformTypeKebabDict.write}})],R.prototype,"fieldTransformType",void 0),(0,T._)([(0,S.MZ)({type:[B],json:{write:!0}})],R.prototype,"colorClassBreakInfos",void 0),R=P=(0,T._)([(0,V.$)("esri.renderers.PointCloudClassBreaksRenderer")],R);const L=R},61919:(A,C,M)=>{M.d(C,{A:()=>K});var U,T=M(80671),_=M(40530),S=M(83375),x=M(66004),V=M(57453),z=(M(50886),M(89412),M(68682));M(76761);let k=U=class extends S.oY{constructor(){super(...arguments),this.field=null,this.minValue=0,this.maxValue=255}clone(){return new U({field:this.field,minValue:this.minValue,maxValue:this.maxValue})}};(0,T._)([(0,V.MZ)({type:String,json:{write:!0}})],k.prototype,"field",void 0),(0,T._)([(0,V.MZ)({type:Number,nonNullable:!0,json:{write:!0}})],k.prototype,"minValue",void 0),(0,T._)([(0,V.MZ)({type:Number,nonNullable:!0,json:{write:!0}})],k.prototype,"maxValue",void 0),k=U=(0,T._)([(0,z.$)("esri.renderers.support.pointCloud.ColorModulation")],k);const F=k,Z=new _.J({pointCloudFixedSizeAlgorithm:"fixed-size",pointCloudSplatAlgorithm:"splat"});let j=class extends S.oY{};(0,T._)([(0,V.MZ)({type:Z.apiValues,readOnly:!0,nonNullable:!0,json:{type:Z.jsonValues,read:!1,write:Z.write}})],j.prototype,"type",void 0),j=(0,T._)([(0,z.$)("esri.renderers.support.pointCloud.PointSizeAlgorithm")],j);const D=j;var B,P=M(99825);let R=B=class extends D{constructor(){super(...arguments),this.type="fixed-size",this.size=0,this.useRealWorldSymbolSizes=null}clone(){return new B({size:this.size,useRealWorldSymbolSizes:this.useRealWorldSymbolSizes})}};(0,T._)([(0,P.e)({pointCloudFixedSizeAlgorithm:"fixed-size"})],R.prototype,"type",void 0),(0,T._)([(0,V.MZ)({type:Number,nonNullable:!0,json:{write:!0}})],R.prototype,"size",void 0),(0,T._)([(0,V.MZ)({type:Boolean,json:{write:!0}})],R.prototype,"useRealWorldSymbolSizes",void 0),R=B=(0,T._)([(0,z.$)("esri.renderers.support.pointCloud.PointSizeFixedSizeAlgorithm")],R);const L=R;var N;let Y=N=class extends D{constructor(){super(...arguments),this.type="splat",this.scaleFactor=1}clone(){return new N({scaleFactor:this.scaleFactor})}};(0,T._)([(0,P.e)({pointCloudSplatAlgorithm:"splat"})],Y.prototype,"type",void 0),(0,T._)([(0,V.MZ)({type:Number,value:1,nonNullable:!0,json:{write:!0}})],Y.prototype,"scaleFactor",void 0),Y=N=(0,T._)([(0,z.$)("esri.renderers.support.pointCloud.PointSizeSplatAlgorithm")],Y);const q={key:"type",base:D,typeMap:{"fixed-size":L,splat:Y}},X=(0,_.O)()({pointCloudClassBreaksRenderer:"point-cloud-class-breaks",pointCloudRGBRenderer:"point-cloud-rgb",pointCloudStretchRenderer:"point-cloud-stretch",pointCloudUniqueValueRenderer:"point-cloud-unique-value"});let H=class extends S.oY{constructor(A){super(A),this.type=void 0,this.pointSizeAlgorithm=null,this.colorModulation=null,this.pointsPerInch=10}clone(){return console.warn(".clone() is not implemented for "+this.declaredClass),null}cloneProperties(){return{pointSizeAlgorithm:(0,x.o8)(this.pointSizeAlgorithm),colorModulation:(0,x.o8)(this.colorModulation),pointsPerInch:(0,x.o8)(this.pointsPerInch)}}};(0,T._)([(0,V.MZ)({type:X.apiValues,readOnly:!0,nonNullable:!0,json:{type:X.jsonValues,read:!1,write:X.write}})],H.prototype,"type",void 0),(0,T._)([(0,V.MZ)({types:q,json:{write:!0}})],H.prototype,"pointSizeAlgorithm",void 0),(0,T._)([(0,V.MZ)({type:F,json:{write:!0}})],H.prototype,"colorModulation",void 0),(0,T._)([(0,V.MZ)({json:{write:!0},nonNullable:!0,type:Number})],H.prototype,"pointsPerInch",void 0),H=(0,T._)([(0,z.$)("esri.renderers.PointCloudRenderer")],H),(H||(H={})).fieldTransformTypeKebabDict=new _.J({none:"none",lowFourBit:"low-four-bit",highFourBit:"high-four-bit",absoluteValue:"absolute-value",moduloTen:"modulo-ten"});const K=H},42352:(A,C,M)=>{M.d(C,{A:()=>j});var U,T=M(80671),_=M(66004),S=M(57453),x=(M(50886),M(89412),M(99825)),V=M(68682),z=M(61919),k=M(4182),F=M(29022);let Z=U=class extends z.A{constructor(A){super(A),this.type="point-cloud-stretch",this.field=null,this.legendOptions=null,this.fieldTransformType=null,this.stops=null}clone(){return new U({...this.cloneProperties(),field:(0,_.o8)(this.field),fieldTransformType:(0,_.o8)(this.fieldTransformType),stops:(0,_.o8)(this.stops),legendOptions:(0,_.o8)(this.legendOptions)})}};(0,T._)([(0,x.e)({pointCloudStretchRenderer:"point-cloud-stretch"})],Z.prototype,"type",void 0),(0,T._)([(0,S.MZ)({json:{write:!0},type:String})],Z.prototype,"field",void 0),(0,T._)([(0,S.MZ)({type:k.q,json:{write:!0}})],Z.prototype,"legendOptions",void 0),(0,T._)([(0,S.MZ)({type:z.A.fieldTransformTypeKebabDict.apiValues,json:{type:z.A.fieldTransformTypeKebabDict.jsonValues,read:z.A.fieldTransformTypeKebabDict.read,write:z.A.fieldTransformTypeKebabDict.write}})],Z.prototype,"fieldTransformType",void 0),(0,T._)([(0,S.MZ)({type:[F.A],json:{write:!0}})],Z.prototype,"stops",void 0),Z=U=(0,T._)([(0,V.$)("esri.renderers.PointCloudStretchRenderer")],Z);const j=Z},30473:(A,C,M)=>{M.d(C,{A:()=>L});var U,T=M(80671),_=M(66004),S=M(57453),x=(M(50886),M(89412),M(99825)),V=M(68682),z=M(61919),k=M(4182),F=M(22123),Z=M(83375),j=M(6493);let D=U=class extends Z.oY{constructor(){super(...arguments),this.description=null,this.label=null,this.values=null,this.color=null}clone(){return new U({description:this.description,label:this.label,values:(0,_.o8)(this.values),color:(0,_.o8)(this.color)})}};(0,T._)([(0,S.MZ)({type:String,json:{write:!0}})],D.prototype,"description",void 0),(0,T._)([(0,S.MZ)({type:String,json:{write:!0}})],D.prototype,"label",void 0),(0,T._)([(0,S.MZ)({type:[String],json:{write:!0}})],D.prototype,"values",void 0),(0,T._)([(0,S.MZ)({type:F.A,json:{type:[j.jz],write:!0}})],D.prototype,"color",void 0),D=U=(0,T._)([(0,V.$)("esri.renderers.support.pointCloud.ColorUniqueValueInfo")],D);const B=D;var P;let R=P=class extends z.A{constructor(A){super(A),this.type="point-cloud-unique-value",this.field=null,this.fieldTransformType=null,this.colorUniqueValueInfos=null,this.legendOptions=null}clone(){return new P({...this.cloneProperties(),field:(0,_.o8)(this.field),fieldTransformType:(0,_.o8)(this.fieldTransformType),colorUniqueValueInfos:(0,_.o8)(this.colorUniqueValueInfos),legendOptions:(0,_.o8)(this.legendOptions)})}};(0,T._)([(0,x.e)({pointCloudUniqueValueRenderer:"point-cloud-unique-value"})],R.prototype,"type",void 0),(0,T._)([(0,S.MZ)({json:{write:!0},type:String})],R.prototype,"field",void 0),(0,T._)([(0,S.MZ)({type:z.A.fieldTransformTypeKebabDict.apiValues,json:{type:z.A.fieldTransformTypeKebabDict.jsonValues,read:z.A.fieldTransformTypeKebabDict.read,write:z.A.fieldTransformTypeKebabDict.write}})],R.prototype,"fieldTransformType",void 0),(0,T._)([(0,S.MZ)({type:[B],json:{write:!0}})],R.prototype,"colorUniqueValueInfos",void 0),(0,T._)([(0,S.MZ)({type:k.q,json:{write:!0}})],R.prototype,"legendOptions",void 0),R=P=(0,T._)([(0,V.$)("esri.renderers.PointCloudUniqueValueRenderer")],R);const L=R},61244:(A,C,M)=>{M.r(C),M.d(C,{default:()=>I});var U=M(16842),T=M(49905),_=M(46064),S=M(77912),x=M(54880),V=M(53395),z=M(98664),k=M(33876),F=(M(50886),M(3394)),Z=M(42352),j=M(30473),D=M(48557),B=M(2409);function PointCloudWorkerUtil_c(A,C,M){return null!==A&&void 0!==A&&A.attributeInfo.useElevation?C?function a(A,C){const M=new Float64Array(C);for(let U=0;U<C;U++)M[U]=A[3*U+2];return M}(C,M):null:null!==A&&void 0!==A&&A.attributeInfo.storageInfo?(0,D.m0)(A.attributeInfo.storageInfo,A.buffer,M):null}function d(A){switch(A){default:case null:case"none":return A=>A;case"low-four-bit":return A=>15&A;case"high-four-bit":return A=>(240&A)>>4;case"absolute-value":return A=>Math.abs(A);case"modulo-ten":return A=>A%10}}function p(A){let C=0;for(const M of A||[])C|=1<<M;return C}var P=M(71138);class c{transform(A){const C=this._transform(A),M=[C.points.buffer,C.rgb.buffer];null!=C.pointIdFilterMap&&M.push(C.pointIdFilterMap.buffer);for(const U of C.attributes)"buffer"in U.values&&(0,T.mw)(U.values.buffer)&&U.values.buffer!==C.rgb.buffer&&M.push(U.values.buffer);return Promise.resolve({result:C,transferList:M})}_transform(A){const C=function u(A,C){if(null==A.encoding||""===A.encoding){const M=(0,D.wH)(C,A);if(null==M.vertexAttributes.position)return;const U=(0,D.MA)(C,M.vertexAttributes.position),T=M.header.fields,_=[T.offsetX,T.offsetY,T.offsetZ],S=[T.scaleX,T.scaleY,T.scaleZ],x=U.length/3,V=new Float64Array(3*x);for(let A=0;A<x;A++)V[3*A]=U[3*A]*S[0]+_[0],V[3*A+1]=U[3*A+1]*S[1]+_[1],V[3*A+2]=U[3*A+2]*S[2]+_[2];return V}if("lepcc-xyz"===A.encoding)return(0,B.Me)(C).result}(A.schema,A.geometryBuffer);let M=C.length/3,T=null;const _=new Array,S=PointCloudWorkerUtil_c(A.primaryAttributeData,C,M);null!=A.primaryAttributeData&&S&&_.push({attributeInfo:A.primaryAttributeData.attributeInfo,values:S});const x=PointCloudWorkerUtil_c(A.modulationAttributeData,C,M);null!=A.modulationAttributeData&&x&&_.push({attributeInfo:A.modulationAttributeData.attributeInfo,values:x});let V=function PointCloudWorkerUtil_i(A,C,M,U){var T;const{rendererJSON:_,isRGBRenderer:S}=A;let x=null,V=null;if(C&&S)x=C;else if(C&&"pointCloudUniqueValueRenderer"===(null===_||void 0===_?void 0:_.type)){V=j.A.fromJSON(_);const A=V.colorUniqueValueInfos;x=new Uint8Array(3*U);const M=d(V.fieldTransformType);for(let T=0;T<U;T++){const U=(M?M(C[T]):C[T])+"";for(let C=0;C<A.length;C++)if(A[C].values.includes(U)){x[3*T]=A[C].color.r,x[3*T+1]=A[C].color.g,x[3*T+2]=A[C].color.b;break}}}else if(C&&"pointCloudStretchRenderer"===(null===_||void 0===_?void 0:_.type)){V=Z.A.fromJSON(_);const A=V.stops;x=new Uint8Array(3*U);const M=d(V.fieldTransformType);for(let T=0;T<U;T++){const U=M?M(C[T]):C[T],_=A.length-1;if(U<A[0].value)x[3*T]=A[0].color.r,x[3*T+1]=A[0].color.g,x[3*T+2]=A[0].color.b;else if(U>=A[_].value)x[3*T]=A[_].color.r,x[3*T+1]=A[_].color.g,x[3*T+2]=A[_].color.b;else for(let C=1;C<A.length;C++)if(U<A[C].value){const M=(U-A[C-1].value)/(A[C].value-A[C-1].value);x[3*T]=A[C].color.r*M+A[C-1].color.r*(1-M),x[3*T+1]=A[C].color.g*M+A[C-1].color.g*(1-M),x[3*T+2]=A[C].color.b*M+A[C-1].color.b*(1-M);break}}}else if(C&&"pointCloudClassBreaksRenderer"===(null===_||void 0===_?void 0:_.type)){V=F.A.fromJSON(_);const A=V.colorClassBreakInfos;x=new Uint8Array(3*U);const M=d(V.fieldTransformType);for(let T=0;T<U;T++){const U=M?M(C[T]):C[T];for(let C=0;C<A.length;C++)if(U>=A[C].minValue&&U<=A[C].maxValue){x[3*T]=A[C].color.r,x[3*T+1]=A[C].color.g,x[3*T+2]=A[C].color.b;break}}}else x=new Uint8Array(3*U).fill(255);if(M&&null!==(T=V)&&void 0!==T&&T.colorModulation){const A=V.colorModulation.minValue,C=V.colorModulation.maxValue,T=.3;for(let _=0;_<U;_++){const U=M[_],S=U>=C?1:U<=A?T:T+(1-T)*(U-A)/(C-A);x[3*_]=S*x[3*_],x[3*_+1]=S*x[3*_+1],x[3*_+2]=S*x[3*_+2]}}return x}(A.rendererInfo,S,x,M);if(A.filterInfo&&A.filterInfo.length>0&&null!=A.filterAttributesData){const S=A.filterAttributesData.filter(U.Ru).map((A=>{const U=PointCloudWorkerUtil_c(A,C,M),T={attributeInfo:A.attributeInfo,values:U};return _.push(T),T}));T=new Uint32Array(M),M=function PointCloudWorkerUtil_f(A,C,M,U,T){const _=A.length/3;let S=0;for(let x=0;x<_;x++){let _=!0;for(let A=0;A<U.length&&_;A++){const{filterJSON:C}=U[A],M=T[A].values[x];switch(C.type){case"pointCloudValueFilter":{const A="exclude"===C.mode;C.values.includes(M)===A&&(_=!1);break}case"pointCloudBitfieldFilter":{const A=p(C.requiredSetBits),U=p(C.requiredClearBits);(M&A)===A&&0==(M&U)||(_=!1);break}case"pointCloudReturnFilter":{const A=15&M,U=M>>>4&15,T=U>1,S=1===A,x=A===U;let V=!1;for(const M of C.includedReturns)if("last"===M&&x||"firstOfMany"===M&&S&&T||"lastOfMany"===M&&x&&T||"single"===M&&!T){V=!0;break}V||(_=!1);break}}}_&&(M[S]=x,A[3*S]=A[3*x],A[3*S+1]=A[3*x+1],A[3*S+2]=A[3*x+2],C[3*S]=C[3*x],C[3*S+1]=C[3*x+1],C[3*S+2]=C[3*x+2],S++)}return S}(C,V,T,A.filterInfo,S)}for(const U of A.userAttributesData){const A=PointCloudWorkerUtil_c(U,C,M);_.push({attributeInfo:U.attributeInfo,values:A})}3*M<V.length&&(V=new Uint8Array(V.buffer.slice(0,3*M))),this._applyElevationOffsetInPlace(C,M,A.elevationOffset);const k=this._transformCoordinates(C,M,P.ab.fromData(A.obbData),z.A.fromJSON(A.inSR),z.A.fromJSON(A.outSR));return{obbData:A.obbData,points:k,rgb:V,attributes:_,pointIdFilterMap:T}}_transformCoordinates(A,C,M,U,T){if(!(0,k.projectBuffer)(A,U,0,A,T,0,C))throw new Error("Can't reproject");const S=(0,V.o8)(M.center),z=(0,V.vt)(),F=(0,V.vt)(),Z=(0,V.o8)(M.halfSize);(0,_.Xr)(R,M.quaternion);const j=new Float32Array(3*C);for(let _=0;_<C;_++){let C=3*_;z[0]=A[C]-S[0],z[1]=A[C+1]-S[1],z[2]=A[C+2]-S[2],(0,x.u)(F,z,R),Z[0]=Math.max(Z[0],Math.abs(F[0])),Z[1]=Math.max(Z[1],Math.abs(F[1])),Z[2]=Math.max(Z[2],Math.abs(F[2])),j[C++]=z[0],j[C++]=z[1],j[C]=z[2]}return M.halfSize=Z,j}_applyElevationOffsetInPlace(A,C,M){if(0!==M)for(let U=0;U<C;U++)A[3*U+2]+=M}}const R=(0,S.vt)();function I(){return new c}},48557:(A,C,M)=>{M.d(C,{MA:()=>l,m0:()=>I,qs:()=>p,wH:()=>w});var U=M(4180),T=M(66004),_=M(89412),S=M(2409),x=M(64286);const u=()=>_.A.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function a(A,C,M){let T="",_=0;for(;_<M;){const S=A[C+_];if(S<128)T+=String.fromCharCode(S),_++;else if(S>=192&&S<224){if(_+1>=M)throw new U.A("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");const x=(31&S)<<6|63&A[C+_+1];T+=String.fromCharCode(x),_+=2}else if(S>=224&&S<240){if(_+2>=M)throw new U.A("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const x=(15&S)<<12|(63&A[C+_+1])<<6|63&A[C+_+2];T+=String.fromCharCode(x),_+=3}else{if(!(S>=240&&S<248))throw new U.A("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(_+3>=M)throw new U.A("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const x=(7&S)<<18|(63&A[C+_+1])<<12|(63&A[C+_+2])<<6|63&A[C+_+3];if(x>=65536){const A=55296+(x-65536>>10),C=56320+(1023&x);T+=String.fromCharCode(A,C)}else T+=String.fromCharCode(x);_+=4}}}return T}function s(A,C){const M={byteOffset:0,byteCount:0,fields:Object.create(null)};let U=0;for(let T=0;T<C.length;T++){const _=C[T],S=_.valueType||_.type,x=k[S];M.fields[_.property]=x(A,U),U+=z[S].BYTES_PER_ELEMENT}return M.byteCount=U,M}function f(A,C,M){const T=[];let _,S,x=0;for(S=0;S<A;S+=1){if(_=C[S],_>0){if(T.push(a(M,x,_-1)),0!==M[x+_-1])throw new U.A("string-array-error","Invalid string array: missing null termination.")}else T.push(null);x+=_}return T}function l(A,C){return new(0,z[C.valueType])(A,C.byteOffset,C.count*C.valuesPerElement)}function b(A,C,M){const _=null!=C.header?s(A,C.header):{byteOffset:0,byteCount:0,fields:{count:M}},S={header:_,byteOffset:_.byteCount,byteCount:0,entries:Object.create(null)};let x=_.byteCount;for(let k=0;k<C.ordering.length;k++){var V,z;const A=C.ordering[k],M=(0,T.o8)(C[A]);if(M.count=null!==(V=_.fields.count)&&void 0!==V?V:0,"String"===M.valueType){if(M.byteOffset=x,M.byteCount=_.fields[A+"ByteCount"],"UTF-8"!==M.encoding)throw new U.A("unsupported-encoding","Unsupported String encoding.",{encoding:M.encoding});if(M.timeEncoding&&"ECMA_ISO8601"!==M.timeEncoding)throw new U.A("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:M.timeEncoding})}else{if(!O(M.valueType))throw new U.A("unsupported-value-type","Unsupported binary valueType",{valueType:M.valueType});{const A=E(M.valueType);x+=x%A!=0?A-x%A:0,M.byteOffset=x,M.byteCount=A*M.valuesPerElement*M.count}}x+=null!==(z=M.byteCount)&&void 0!==z?z:0,S.entries[A]=M}return S.byteCount=x-S.byteOffset,S}function y(A,C,M){if(C!==A&&u().error("Invalid ".concat(M," buffer size\n expected: ").concat(A,", actual: ").concat(C,")")),C<A)throw new U.A("buffer-too-small","Binary buffer is too small",{expectedSize:A,actualSize:C})}function w(A,C){const M=s(A,C&&C.header);let U=M.byteCount;const T={isDraco:!1,header:M,byteOffset:M.byteCount,byteCount:0,vertexAttributes:{}},_=M.fields,S=null!=_.vertexCount?_.vertexCount:_.count;for(const k of C.ordering){if(!C.vertexAttributes[k])continue;const A={...C.vertexAttributes[k],byteOffset:U,count:S},M=V[k]||"_"+k;T.vertexAttributes[M]=A,U+=E(A.valueType)*A.valuesPerElement*S}const x=_.faceCount;if(C.faces&&x){T.faces={};for(const A of C.ordering){if(!C.faces[A])continue;const M={...C.faces[A],byteOffset:U,count:x};T.faces[A]=M,U+=E(M.valueType)*M.valuesPerElement*x}}const z=_.featureCount;if(C.featureAttributes&&C.featureAttributeOrder&&z){T.featureAttributes={};for(const A of C.featureAttributeOrder){if(!C.featureAttributes[A])continue;const M={...C.featureAttributes[A],byteOffset:U,count:z};T.featureAttributes[A]=M,U+=("UInt64"===M.valueType?8:E(M.valueType))*M.valuesPerElement*z}}return y(U,A.byteLength,"geometry"),T.byteCount=U-T.byteOffset,T}function p(A,C){return A&&A.compressedAttributes&&"draco"===A.compressedAttributes.encoding?function v(A){const C={isDraco:!0,isLegacy:!1,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const M of A)switch(M){case"position":break;case"normal":C.normal=!0;break;case"uv0":C.uv0=!0;break;case"color":C.color=!0;break;case"uv-region":C.uvRegion=!0;break;case"feature-index":C.featureIndex=!0}return C}(A.compressedAttributes.attributes):A?function g(A){return{isDraco:!1,isLegacy:!1,color:null!=A.color,normal:null!=A.normal,uv0:null!=A.uv0,uvRegion:null!=A.uvRegion,featureIndex:null!=A.faceRange&&null!=A.featureId}}(A):function m(A){const C={isDraco:!1,isLegacy:!0,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const M of A.ordering)if(A.vertexAttributes[M])switch(M){case"position":break;case"normal":C.normal=!0;break;case"color":C.color=!0;break;case"uv0":C.uv0=!0;break;case"region":C.uvRegion=!0}return A.featureAttributes&&A.featureAttributeOrder&&(C.featureIndex=!0),C}(C)}const V={position:x.r.POSITION,normal:x.r.NORMAL,color:x.r.COLOR,uv0:x.r.UV0,region:x.r.UVREGION};function I(A,C,M){if("lepcc-rgb"===A.encoding)return(0,S.mb)(C);if("lepcc-intensity"===A.encoding)return(0,S.Ax)(C);if(null!=A.encoding&&""!==A.encoding)throw new U.A("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");A["attributeByteCounts "]&&!A.attributeByteCounts&&(u().warn("Warning: Trailing space in 'attributeByteCounts '."),A.attributeByteCounts=A["attributeByteCounts "]),"ObjectIds"===A.ordering[0]&&A.hasOwnProperty("objectIds")&&(u().warn("Warning: Case error in objectIds"),A.ordering[0]="objectIds");const T=b(C,A,M);y(T.byteOffset+T.byteCount,C.byteLength,"attribute");const _=T.entries.attributeValues||T.entries.objectIds;if(_){if("String"===_.valueType){const A=T.entries.attributeByteCounts,M=l(C,A),U=function d(A,C){return new Uint8Array(A,C.byteOffset,C.byteCount)}(C,_);return _.timeEncoding?function c(A,C,M){return f(A,C,M).map((A=>{const C=A?Date.parse(A):null;return C&&!Number.isNaN(C)?C:null}))}(A.count,M,U):f(A.count,M,U)}return l(C,_)}throw new U.A("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const z={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},k={Float32:(A,C)=>new DataView(A,0).getFloat32(C,!0),Float64:(A,C)=>new DataView(A,0).getFloat64(C,!0),UInt8:(A,C)=>new DataView(A,0).getUint8(C),Int8:(A,C)=>new DataView(A,0).getInt8(C),UInt16:(A,C)=>new DataView(A,0).getUint16(C,!0),Int16:(A,C)=>new DataView(A,0).getInt16(C,!0),UInt32:(A,C)=>new DataView(A,0).getUint32(C,!0),Int32:(A,C)=>new DataView(A,0).getInt32(C,!0)};function O(A){return z.hasOwnProperty(A)}function E(A){return O(A)?z[A].BYTES_PER_ELEMENT:0}},2409:(A,C,M)=>{M.d(C,{Ax:()=>w,Me:()=>c,mb:()=>u});var U=M(4180);const T=!0,_={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function r(A,C,M){return{identifier:String.fromCharCode.apply(null,new Uint8Array(A,M+_.identifierOffset,_.identifierLength)),version:C.getUint16(M+_.versionOffset,T),checksum:C.getUint32(M+_.checksumOffset,T)}}const S={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function i(A,C){return{sizeLo:A.getUint32(C+S.sizeLo,T),sizeHi:A.getUint32(C+S.sizeHi,T),minX:A.getFloat64(C+S.minX,T),minY:A.getFloat64(C+S.minY,T),minZ:A.getFloat64(C+S.minZ,T),maxX:A.getFloat64(C+S.maxX,T),maxY:A.getFloat64(C+S.maxY,T),maxZ:A.getFloat64(C+S.maxZ,T),errorX:A.getFloat64(C+S.errorX,T),errorY:A.getFloat64(C+S.errorY,T),errorZ:A.getFloat64(C+S.errorZ,T),count:A.getUint32(C+S.count,T),reserved:A.getUint32(C+S.reserved,T)}}function c(A){const C=new DataView(A,0);let M=0;const{identifier:T,version:x}=r(A,C,M);if(M+=_.byteCount,"LEPCC     "!==T)throw new U.A("lepcc-decode-error","Bad identifier");if(x>1)throw new U.A("lepcc-decode-error","Unknown version");const V=i(C,M);if(M+=S.byteCount,V.sizeHi*2**32+V.sizeLo!==A.byteLength)throw new U.A("lepcc-decode-error","Bad size");const z=new Float64Array(3*V.count),k=[],F=[],Z=[],j=[];if(M=s(A,M,k),M=s(A,M,F),M=s(A,M,Z),M=s(A,M,j),M!==A.byteLength)throw new U.A("lepcc-decode-error","Bad length");let D=0,B=0;for(let U=0;U<k.length;U++){B+=k[U];let A=0;for(let C=0;C<F[U];C++){A+=Z[D];const C=j[D];z[3*D]=Math.min(V.maxX,V.minX+2*V.errorX*A),z[3*D+1]=Math.min(V.maxY,V.minY+2*V.errorY*B),z[3*D+2]=Math.min(V.maxZ,V.minZ+2*V.errorZ*C),D++}}return{errorX:V.errorX,errorY:V.errorY,errorZ:V.errorZ,result:z}}function s(A,C,M){const U=[];C=d(A,C,U);const T=[];for(let _=0;_<U.length;_++){T.length=0,C=d(A,C,T);for(let A=0;A<T.length;A++)M.push(T[A]+U[_])}return C}function d(A,C,M){const _=new DataView(A,C),S=_.getUint8(0),x=31&S,V=!!(32&S),z=(192&S)>>6;let k=0;if(0===z)k=_.getUint32(1,T),C+=5;else if(1===z)k=_.getUint16(1,T),C+=3;else{if(2!==z)throw new U.A("lepcc-decode-error","Bad count type");k=_.getUint8(1),C+=2}if(V)throw new U.A("lepcc-decode-error","LUT not implemented");const F=Math.ceil(k*x/8),Z=new Uint8Array(A,C,F);let j=0,D=0,B=0;const P=-1>>>32-x;for(let U=0;U<k;U++){for(;D<x;)j|=Z[B]<<D,D+=8,B+=1;M[U]=j&P,j>>>=x,D-=x,D+x>32&&(j|=Z[B-1]>>8-D)}return C+B}const x={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function a(A,C){return{sizeLo:A.getUint32(C+x.sizeLo,T),sizeHi:A.getUint32(C+x.sizeHi,T),count:A.getUint32(C+x.count,T),colorMapCount:A.getUint16(C+x.colorMapCount,T),lookupMethod:A.getUint8(C+x.lookupMethod),compressionMethod:A.getUint8(C+x.compressionMethod)}}function u(A){const C=new DataView(A,0);let M=0;const{identifier:T,version:S}=r(A,C,M);if(M+=_.byteCount,"ClusterRGB"!==T)throw new U.A("lepcc-decode-error","Bad identifier");if(S>1)throw new U.A("lepcc-decode-error","Unknown version");const V=a(C,M);if(M+=x.byteCount,V.sizeHi*2**32+V.sizeLo!==A.byteLength)throw new U.A("lepcc-decode-error","Bad size");if((2===V.lookupMethod||1===V.lookupMethod)&&0===V.compressionMethod){if(3*V.colorMapCount+V.count+M!==A.byteLength||V.colorMapCount>256)throw new U.A("lepcc-decode-error","Bad count");const C=new Uint8Array(A,M,3*V.colorMapCount),T=new Uint8Array(A,M+3*V.colorMapCount,V.count),_=new Uint8Array(3*V.count);for(let A=0;A<V.count;A++){const M=T[A];_[3*A]=C[3*M],_[3*A+1]=C[3*M+1],_[3*A+2]=C[3*M+2]}return _}if(0===V.lookupMethod&&0===V.compressionMethod){if(3*V.count+M!==A.byteLength||0!==V.colorMapCount)throw new U.A("lepcc-decode-error","Bad count");return new Uint8Array(A,M).slice()}if(V.lookupMethod<=2&&1===V.compressionMethod){if(M+3!==A.byteLength||1!==V.colorMapCount)throw new U.A("lepcc-decode-error","Bad count");const T=C.getUint8(M),_=C.getUint8(M+1),S=C.getUint8(M+2),x=new Uint8Array(3*V.count);for(let A=0;A<V.count;A++)x[3*A]=T,x[3*A+1]=_,x[3*A+2]=S;return x}throw new U.A("lepcc-decode-error","Bad method "+V.lookupMethod+","+V.compressionMethod)}const V={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function h(A,C){return{sizeLo:A.getUint32(C+V.sizeLo,T),sizeHi:A.getUint32(C+V.sizeHi,T),count:A.getUint32(C+V.count,T),scaleFactor:A.getUint16(C+V.scaleFactor,T),bitsPerPoint:A.getUint8(C+V.bitsPerPoint),reserved:A.getUint8(C+V.reserved)}}function w(A){const C=new DataView(A,0);let M=0;const{identifier:T,version:S}=r(A,C,M);if(M+=_.byteCount,"Intensity "!==T)throw new U.A("lepcc-decode-error","Bad identifier");if(S>1)throw new U.A("lepcc-decode-error","Unknown version");const x=h(C,M);if(M+=V.byteCount,x.sizeHi*2**32+x.sizeLo!==A.byteLength)throw new U.A("lepcc-decode-error","Bad size");const z=new Uint16Array(x.count);if(8===x.bitsPerPoint){if(x.count+M!==A.byteLength)throw new U.A("lepcc-decode-error","Bad size");const C=new Uint8Array(A,M,x.count);for(let A=0;A<x.count;A++)z[A]=C[A]*x.scaleFactor}else if(16===x.bitsPerPoint){if(2*x.count+M!==A.byteLength)throw new U.A("lepcc-decode-error","Bad size");const C=new Uint16Array(A,M,x.count);for(let A=0;A<x.count;A++)z[A]=C[A]*x.scaleFactor}else{const C=[];if(d(A,M,C)!==A.byteLength)throw new U.A("lepcc-decode-error","Bad size");for(let A=0;A<x.count;A++)z[A]=C[A]*x.scaleFactor}return z}}}]);
//# sourceMappingURL=1244.adb7fefc.chunk.js.map