"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[4137],{28999:(e,t,r)=>{r.d(t,{r:()=>u});var s=r(80671),h=r(18763),l=r(57453),p=(r(50886),r(89412),r(76761),r(68682));const d={visible:"visibleSublayers"};let u=class extends h.A{constructor(e){super(e),this.scale=0}set layer(e){this._get("layer")!==e&&(this._set("layer",e),this.removeHandles("layer"),e&&this.addHandles([e.sublayers.on("change",(()=>this.notifyChange("visibleSublayers"))),e.on("wms-sublayer-update",(e=>this.notifyChange(d[e.propertyName])))],"layer"))}get layers(){return this.visibleSublayers.filter((e=>{let{name:t}=e;return t})).map((e=>{let{name:t}=e;return t})).join()}get version(){this.commitProperty("layers");const e=this.layer;return e&&e.commitProperty("imageTransparency"),(this._get("version")||0)+1}get visibleSublayers(){const{layer:e,scale:t}=this,r=null===e||void 0===e?void 0:e.sublayers,s=[],o=e=>{const{minScale:r,maxScale:h,sublayers:l,visible:p}=e;p&&(0===t||(0===r||t<=r)&&(0===h||t>=h))&&(l?l.forEach(o):s.push(e))};return null!==r&&void 0!==r&&r.forEach(o),s}toJSON(){const{layer:e,layers:t}=this,{imageFormat:r,imageTransparency:s,version:h}=e;return{format:r,request:"GetMap",service:"WMS",styles:"",transparent:s?"TRUE":"FALSE",version:h,layers:t}}};(0,s._)([(0,l.MZ)()],u.prototype,"layer",null),(0,s._)([(0,l.MZ)({readOnly:!0})],u.prototype,"layers",null),(0,s._)([(0,l.MZ)({type:Number})],u.prototype,"scale",void 0),(0,s._)([(0,l.MZ)({readOnly:!0})],u.prototype,"version",null),(0,s._)([(0,l.MZ)({readOnly:!0})],u.prototype,"visibleSublayers",null),u=(0,s._)([(0,p.$)("esri.layers.support.ExportWMSImageParameters")],u)},94101:(e,t,r)=>{r.d(t,{l:()=>a});var s=r(82262),h=r(21847),l=r(231);class a extends l.A{constructor(){super(...arguments),this._hasCrossfade=!1}get requiresDedicatedFBO(){return super.requiresDedicatedFBO||this._hasCrossfade}beforeRender(e){super.beforeRender(e),this._manageFade()}prepareRenderPasses(e){const t=e.registerRenderPass({name:"bitmap",brushes:[s.d.bitmap],target:()=>this.children,drawPhase:h.S5.MAP});return[...super.prepareRenderPasses(e),t]}_manageFade(){this.children.reduce(((e,t)=>e+(t.inFadeTransition?1:0)),0)>=2?(this.children.forEach((e=>e.blendFunction="additive")),this._hasCrossfade=!0):(this.children.forEach((e=>e.blendFunction="standard")),this._hasCrossfade=!1)}}},64137:(e,t,r)=>{r.r(t),r.d(t,{default:()=>P});var s=r(80671),h=r(89412),l=r(35598),p=r(81618),d=r(63390),u=r(57453),c=(r(50886),r(76761),r(68682)),y=r(84661),g=r(94101),f=r(86083),v=r(75811),x=r(27012),_=r(59995),w=r(4180),M=r(32277),b=r(28999);const m=e=>{let t=class extends e{initialize(){this.exportImageParameters=new b.r({layer:this.layer})}destroy(){this.exportImageParameters=(0,l.pR)(this.exportImageParameters)}get exportImageVersion(){var e;return null!==(e=this.exportImageParameters)&&void 0!==e&&e.commitProperty("version"),this.commitProperty("timeExtent"),(this._get("exportImageVersion")||0)+1}async fetchPopupFeaturesAtLocation(e,t){const{layer:r}=this;if(!e)throw new w.A("wmslayerview:fetchPopupFeatures","Nothing to fetch without area",{layer:r});const{popupEnabled:s}=r;if(!s)throw new w.A("wmslayerview:fetchPopupFeatures","popupEnabled should be true",{popupEnabled:s});const h=this.createFetchPopupFeaturesQuery(e);if(!h)return[];const{extent:l,width:d,height:u,x:c,y:y}=h;if(!(l&&d&&u))throw new w.A("wmslayerview:fetchPopupFeatures","WMSLayer does not support fetching features.",{extent:l,width:d,height:u});const g=await r.fetchFeatureInfo(l,d,u,c,y);return(0,p.Te)(t),g}};return(0,s._)([(0,u.MZ)()],t.prototype,"exportImageParameters",void 0),(0,s._)([(0,u.MZ)({readOnly:!0})],t.prototype,"exportImageVersion",null),(0,s._)([(0,u.MZ)()],t.prototype,"layer",void 0),(0,s._)([(0,u.MZ)(M.ui)],t.prototype,"timeExtent",void 0),t=(0,s._)([(0,c.$)("esri.layers.mixins.WMSLayerView")],t),t};let S=class extends(m((0,_.A)((0,f.e)(x.A)))){constructor(){super(...arguments),this.bitmapContainer=new g.l}supportsSpatialReference(e){return this.layer.serviceSupportsSpatialReference(e)}update(e){this.strategy.update(e).catch((e=>{(0,p.zf)(e)||h.A.getLogger(this).error(e)}))}attach(){const{layer:e}=this,{imageMaxHeight:t,imageMaxWidth:r}=e;this.bitmapContainer=new g.l,this.container.addChild(this.bitmapContainer),this.strategy=new v.A({container:this.bitmapContainer,fetchSource:this.fetchImage.bind(this),requestUpdate:this.requestUpdate.bind(this),imageMaxHeight:t,imageMaxWidth:r,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1}),this.addAttachHandles((0,d.wB)((()=>this.exportImageVersion),(()=>this.requestUpdate())))}detach(){this.strategy=(0,l.pR)(this.strategy),this.container.removeAllChildren()}moveStart(){}viewChange(){}moveEnd(){this.requestUpdate()}createFetchPopupFeaturesQuery(e){const{view:t,bitmapContainer:r}=this,{x:s,y:h}=e,{spatialReference:l}=t;let p,d=0,u=0;if(r.children.some((e=>{const{width:t,height:r,resolution:c,x:g,y:f}=e,v=g+c*t,x=f-c*r;return s>=g&&s<=v&&h<=f&&h>=x&&(p=new y.A({xmin:g,ymin:x,xmax:v,ymax:f,spatialReference:l}),d=t,u=r,!0)})),!p)return null;const c=p.width/d,g=Math.round((s-p.xmin)/c),f=Math.round((p.ymax-h)/c);return{extent:p,width:d,height:u,x:g,y:f}}async doRefresh(){this.requestUpdate()}isUpdating(){return this.strategy.updating||this.updateRequested}fetchImage(e,t,r,s){return this.layer.fetchImageBitmap(e,t,r,{timeExtent:this.timeExtent,...s})}};(0,s._)([(0,u.MZ)()],S.prototype,"strategy",void 0),(0,s._)([(0,u.MZ)()],S.prototype,"updating",void 0),S=(0,s._)([(0,c.$)("esri.views.2d.layers.WMSLayerView2D")],S);const P=S},75811:(e,t,r)=>{r.d(t,{A:()=>Z});var s=r(80671),h=r(18763),l=(r(50886),r(81618)),p=r(57453),d=(r(89412),r(76761),r(68682)),u=r(88965),c=r(78395),y=r(22179);const g=Math.PI/180;function n(e){return e*g}function o(e,t){const r=n(t.rotation),s=Math.abs(Math.cos(r)),h=Math.abs(Math.sin(r)),[l,p]=t.size;return e[0]=Math.round(p*h+l*s),e[1]=Math.round(p*s+l*h),e}var f=r(82804),v=r(63801),x=r(67685);const _=(0,u.vt)(),w=[0,0],M=new x.A(0,0,0,0),b=2048,S=2048,P=!1,R=!1,E=!1;let A=class extends h.A{constructor(e){super(e),this._imagePromise=null,this.bitmaps=[],this.hidpi=E,this.imageMaxWidth=b,this.imageMaxHeight=S,this.imageRotationSupported=P,this.imageNormalizationSupported=R,this.update=(0,l.sg)((async(e,t)=>{var r,s;if((0,l.Te)(t),!e.stationary||this.destroyed)return;const h=e.state,p=(0,c.Vp)(h.spatialReference),d=this.hidpi?e.pixelRatio:1,u=this.imageNormalizationSupported&&h.worldScreenWidth&&h.worldScreenWidth<h.size[0],y=null!==(r=this.imageMaxWidth)&&void 0!==r?r:0,g=null!==(s=this.imageMaxHeight)&&void 0!==s?s:0;u?(w[0]=h.worldScreenWidth,w[1]=h.size[1]):this.imageRotationSupported?(w[0]=h.size[0],w[1]=h.size[1]):o(w,h);const f=Math.floor(w[0]*d)>y||Math.floor(w[1]*d)>g,v=p&&(h.extent.xmin<p.valid[0]||h.extent.xmax>p.valid[1]),x=!this.imageNormalizationSupported&&v,_=!f&&!x,b=this.imageRotationSupported?h.rotation:0,S=this.container.children.slice();if(_){const e=u?h.paddedViewState.center:h.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(h,w,e,h.resolution,b,d,t)}else{let e=Math.min(y,g);x&&(e=Math.min(h.worldScreenWidth,e)),this._imagePromise=this._tiledExport(h,e,d,t)}try{var P;const e=null!==(P=await this._imagePromise)&&void 0!==P?P:[];(0,l.Te)(t);const r=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=e;for(const t of S)e.includes(t)||r.push(t.fadeOut().then((()=>{t.remove(),t.destroy()})));for(const t of e)r.push(t.fadeIn());await Promise.all(r)}catch(M){this._imagePromise=null,(0,l.QP)(M)}}),5e3),this.updateExports=(0,l.sg)((async e=>{const t=[];for(const r of this.container.children){if(!r.visible||!r.stage)return;t.push(e(r).then((()=>{r.invalidateTexture(),r.requestRender()})))}this._imagePromise=(0,l.Lx)(t).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((e=>e.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(e,t,r,s,h,p){const d=await this.fetchSource(e,Math.floor(t*h),Math.floor(r*h),{rotation:s,pixelRatio:h,signal:p});(0,l.Te)(p);const u=new f.mb(null,!0);return u.x=e.xmin,u.y=e.ymax,u.resolution=e.width/t,u.rotation=s,u.pixelRatio=h,u.opacity=0,this.container.addChild(u),await u.setSourceAsync(d,p),(0,l.Te)(p),u}async _singleExport(e,t,r,s,h,l,p){!function viewStateUtils_a(e,t,r,s){const[h,l]=t,[p,d]=s,u=.5*r;return e[0]=h-u*p,e[1]=l-u*d,e[2]=h+u*p,e[3]=l+u*d,e}(_,r,s,t);const d=(0,u.w1)(_,e.spatialReference);return[await this._export(d,t[0],t[1],h,l,p)]}_tiledExport(e,t,r,s){const h=y.A.create({size:t,spatialReference:e.spatialReference,scales:[e.scale]}),l=new v.A(h),p=l.getTileCoverage(e);if(!p)return null;const d=[];return p.forEach(((h,p,c,y)=>{M.set(h,p,c,0),l.getTileBounds(_,M);const g=(0,u.w1)(_,e.spatialReference);d.push(this._export(g,t,t,0,r,s).then((e=>(0!==y&&(M.set(h,p,c,y),l.getTileBounds(_,M),e.x=_[0],e.y=_[3]),e))))})),Promise.all(d)}};(0,s._)([(0,p.MZ)()],A.prototype,"_imagePromise",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"bitmaps",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"container",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"fetchSource",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"hidpi",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"imageMaxWidth",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"imageMaxHeight",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"imageRotationSupported",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"imageNormalizationSupported",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"requestUpdate",void 0),(0,s._)([(0,p.MZ)()],A.prototype,"updating",null),A=(0,s._)([(0,d.$)("esri.views.2d.layers.support.ExportStrategy")],A);const Z=A},59995:(e,t,r)=>{r.d(t,{A:()=>i});var s=r(80671),h=r(89412),l=r(81618),p=r(63390),d=(r(50886),r(76761),r(4180),r(68682));const i=e=>{let t=class extends e{initialize(){this.addHandles((0,p.on)((()=>this.layer),"refresh",(e=>{this.doRefresh(e.dataChanged).catch((e=>{(0,l.zf)(e)||h.A.getLogger(this).error(e)}))})),"RefreshableLayerView")}};return t=(0,s._)([(0,d.$)("esri.layers.mixins.RefreshableLayerView")],t),t}}}]);
//# sourceMappingURL=4137.7e90f6b5.chunk.js.map