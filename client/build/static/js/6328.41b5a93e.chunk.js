"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[6328],{62408:(M,R,F)=>{function e(M){return null!=r(M)||null!=u(M)}function t(M){return E.test(M)}function n(M){var R;return null!==(R=r(M))&&void 0!==R?R:u(M)}function u(M){const R=new Date(M);return function o(M,R){if(Number.isNaN(M.getTime()))return!1;let F=!0;if(A&&/\d+\W*$/.test(R)){const M=R.match(/[a-zA-Z]{2,}/);if(M){let R=!1,E=0;for(;!R&&E<=M.length;)R=!T.test(M[E]),E++;F=!R}}return F}(R,M)?Number.isNaN(R.getTime())?null:R.getTime()-6e4*R.getTimezoneOffset():null}function r(M){var R,F,T,A;const C=E.exec(M);if(null===C||void 0===C||!C.groups)return null;const Z=C.groups,X=+Z.year,N=+Z.month-1,q=+Z.day,D=+(null!==(R=Z.hours)&&void 0!==R?R:"0"),z=+(null!==(F=Z.minutes)&&void 0!==F?F:"0"),k=+(null!==(T=Z.seconds)&&void 0!==T?T:"0");if(D>23)return null;if(z>59)return null;if(k>59)return null;const L=null!==(A=Z.ms)&&void 0!==A?A:"0",Q=L?+L.padEnd(3,"0").substring(0,3):0;let K;if(Z.isUTC||!Z.offsetSign)K=Date.UTC(X,N,q,D,z,k,Q);else{const M=+Z.offsetHours,R=+Z.offsetMinutes;K=6e4*("+"===Z.offsetSign?-1:1)*(60*M+R)+Date.UTC(X,N,q,D,z,k,Q)}return Number.isNaN(K)?null:K}F.d(R,{Br:()=>t,Cq:()=>e,_U:()=>n});const E=/^(?:(?<year>-?\d{4,})-(?<month>\d{2})-(?<day>\d{2}))(?:T(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2})(?:\.(?<ms>\d+))?)?(?:(?<isUTC>Z)|(?:(?<offsetSign>\+|-)(?<offsetHours>\d{2}):(?<offsetMinutes>\d{2})))?$/;const T=/^((jan(uary)?)|(feb(ruary)?)|(mar(ch)?)|(apr(il)?)|(may)|(jun(e)?)|(jul(y)?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)|(am)|(pm)|(gmt)|(utc))$/i,A=!Number.isNaN(new Date("technology 10").getTime())},30925:(M,R,F)=>{F.d(R,{w:()=>s});var E=F(16842),T=F(17244),A=F(60964);class s{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9,R=arguments.length>1?arguments[1]:void 0;this._compareMinX=o,this._compareMinY=l,this._toBBox=M=>M,this._maxEntries=Math.max(4,M||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),R&&("function"==typeof R?this._toBBox=R:this._initFormat(R)),this.clear()}destroy(){this.clear(),C.prune(),Z.prune(),X.prune(),N.prune()}all(M){this._all(this._data,M)}search(M,R){let F=this._data;const E=this._toBBox;if(x(M,F))for(C.clear();F;){for(let T=0,A=F.children.length;T<A;T++){const A=F.children[T],Z=F.leaf?E(A):A;x(M,Z)&&(F.leaf?R(A):_(M,Z)?this._all(A,R):C.push(A))}F=C.pop()}}collides(M){let R=this._data;const F=this._toBBox;if(!x(M,R))return!1;for(C.clear();R;){for(let E=0,T=R.children.length;E<T;E++){const T=R.children[E],A=R.leaf?F(T):T;if(x(M,A)){if(R.leaf||_(M,A))return!0;C.push(T)}}R=C.pop()}return!1}load(M){if(!M.length)return this;if(M.length<this._minEntries){for(let R=0,F=M.length;R<F;R++)this.insert(M[R]);return this}let R=this._build(M.slice(0,M.length),0,M.length-1,0);if(this._data.children.length)if(this._data.height===R.height)this._splitRoot(this._data,R);else{if(this._data.height<R.height){const M=this._data;this._data=R,R=M}this._insert(R,this._data.height-R.height-1,!0)}else this._data=R;return this}insert(M){return M&&this._insert(M,this._data.height-1),this}clear(){return this._data=new w([]),this}remove(M){if(!M)return this;let R,F=this._data,T=null,A=0,C=!1;const Z=this._toBBox(M);for(X.clear(),N.clear();F||X.length>0;){var q;if(F||(F=X.pop(),T=X.data[X.length-1],A=null!==(q=N.pop())&&void 0!==q?q:0,C=!0),F.leaf&&(R=(0,E.qh)(F.children,M,F.children.length,F.indexHint),-1!==R))return F.children.splice(R,1),X.push(F),this._condense(X),this;C||F.leaf||!_(F,Z)?T?(A++,F=T.children[A],C=!1):F=null:(X.push(F),N.push(A),A=0,T=F,F=F.children[0])}return this}toJSON(){return this._data}fromJSON(M){return this._data=M,this}_all(M,R){let F=M;for(Z.clear();F;){var E;if(!0===F.leaf)for(const M of F.children)R(M);else Z.pushArray(F.children);F=null!==(E=Z.pop())&&void 0!==E?E:null}}_build(M,R,F,E){const T=F-R+1;let A=this._maxEntries;if(T<=A){const E=new w(M.slice(R,F+1));return h(E,this._toBBox),E}E||(E=Math.ceil(Math.log(T)/Math.log(A)),A=Math.ceil(T/A**(E-1)));const C=new b([]);C.height=E;const Z=Math.ceil(T/A),X=Z*Math.ceil(Math.sqrt(A));f(M,R,F,X,this._compareMinX);for(let N=R;N<=F;N+=X){const R=Math.min(N+X-1,F);f(M,N,R,Z,this._compareMinY);for(let F=N;F<=R;F+=Z){const T=Math.min(F+Z-1,R);C.children.push(this._build(M,F,T,E-1))}}return h(C,this._toBBox),C}_chooseSubtree(M,R,F,E){for(;E.push(R),!0!==R.leaf&&E.length-1!==F;){let F,E=1/0,T=1/0;for(let A=0,C=R.children.length;A<C;A++){const C=R.children[A],Z=c(C),X=d(M,C)-Z;X<T?(T=X,E=Z<E?Z:E,F=C):X===T&&Z<E&&(E=Z,F=C)}R=F||R.children[0]}return R}_insert(M,R,F){const E=this._toBBox,T=F?M:E(M);X.clear();const A=this._chooseSubtree(T,this._data,R,X);for(A.children.push(M),r(A,T);R>=0&&X.data[R].children.length>this._maxEntries;)this._split(X,R),R--;this._adjustParentBBoxes(T,X,R)}_split(M,R){const F=M.data[R],E=F.children.length,T=this._minEntries;this._chooseSplitAxis(F,T,E);const A=this._chooseSplitIndex(F,T,E);if(!A)return void console.log("  Error: assertion failed at PooledRBush._split: no valid split index");const C=F.children.splice(A,F.children.length-A),Z=F.leaf?new w(C):new b(C);Z.height=F.height,h(F,this._toBBox),h(Z,this._toBBox),R?M.data[R-1].children.push(Z):this._splitRoot(F,Z)}_splitRoot(M,R){this._data=new b([M,R]),this._data.height=M.height+1,h(this._data,this._toBBox)}_chooseSplitIndex(M,R,F){let E,T,A;E=T=1/0;for(let C=R;C<=F-R;C++){const R=a(M,0,C,this._toBBox),Z=a(M,C,F,this._toBBox),X=u(R,Z),N=c(R)+c(Z);X<E?(E=X,A=C,T=N<T?N:T):X===E&&N<T&&(T=N,A=C)}return A}_chooseSplitAxis(M,R,F){const E=M.leaf?this._compareMinX:o,T=M.leaf?this._compareMinY:l;this._allDistMargin(M,R,F,E)<this._allDistMargin(M,R,F,T)&&M.children.sort(E)}_allDistMargin(M,R,F,E){M.children.sort(E);const T=this._toBBox,A=a(M,0,R,T),C=a(M,F-R,F,T);let Z=m(A)+m(C);for(let X=R;X<F-R;X++){const R=M.children[X];r(A,M.leaf?T(R):R),Z+=m(A)}for(let X=F-R-1;X>=R;X--){const R=M.children[X];r(C,M.leaf?T(R):R),Z+=m(C)}return Z}_adjustParentBBoxes(M,R,F){for(let E=F;E>=0;E--)r(R.data[E],M)}_condense(M){for(let R=M.length-1;R>=0;R--){const F=M.data[R];if(0===F.children.length)if(R>0){const T=M.data[R-1],A=T.children;A.splice((0,E.qh)(A,F,A.length,T.indexHint),1)}else this.clear();else h(F,this._toBBox)}}_initFormat(M){const R=["return a"," - b",";"];this._compareMinX=new Function("a","b",R.join(M[0])),this._compareMinY=new Function("a","b",R.join(M[1])),this._toBBox=new Function("a","return {minX: a"+M[0]+", minY: a"+M[1]+", maxX: a"+M[2]+", maxY: a"+M[3]+"};")}}function h(M,R){a(M,0,M.children.length,R,M)}function a(M,R,F,E,T){T||(T=new w([])),T.minX=1/0,T.minY=1/0,T.maxX=-1/0,T.maxY=-1/0;for(let A,C=R;C<F;C++)A=M.children[C],r(T,M.leaf?E(A):A);return T}function r(M,R){M.minX=Math.min(M.minX,R.minX),M.minY=Math.min(M.minY,R.minY),M.maxX=Math.max(M.maxX,R.maxX),M.maxY=Math.max(M.maxY,R.maxY)}function o(M,R){return M.minX-R.minX}function l(M,R){return M.minY-R.minY}function c(M){return(M.maxX-M.minX)*(M.maxY-M.minY)}function m(M){return M.maxX-M.minX+(M.maxY-M.minY)}function d(M,R){return(Math.max(R.maxX,M.maxX)-Math.min(R.minX,M.minX))*(Math.max(R.maxY,M.maxY)-Math.min(R.minY,M.minY))}function u(M,R){const F=Math.max(M.minX,R.minX),E=Math.max(M.minY,R.minY),T=Math.min(M.maxX,R.maxX),A=Math.min(M.maxY,R.maxY);return Math.max(0,T-F)*Math.max(0,A-E)}function _(M,R){return M.minX<=R.minX&&M.minY<=R.minY&&R.maxX<=M.maxX&&R.maxY<=M.maxY}function x(M,R){return R.minX<=M.maxX&&R.minY<=M.maxY&&R.maxX>=M.minX&&R.maxY>=M.minY}function f(M,R,F,E,T){const C=[R,F];for(;C.length;){const R=C.pop(),F=C.pop();if(R-F<=E)continue;const Z=F+Math.ceil((R-F)/E/2)*E;(0,A.q)(M,Z,F,R,T),C.push(F,Z,Z,R)}}const C=new T.A,Z=new T.A,X=new T.A,N=new T.A({deallocator:void 0});class Y{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}}class B extends Y{constructor(){super(...arguments),this.height=1,this.indexHint=new E.vW}}class w extends B{constructor(M){super(),this.children=M,this.leaf=!0}}class b extends B{constructor(M){super(),this.children=M,this.leaf=!1}}},77026:(M,R,F)=>{F.d(R,{g:()=>E});const E={convertToGEGeometry:function s(M,R){return null==R?null:M.convertJSONToGeometry(R)},exportPoint:function n(M,R,F){const E=new i(M.getPointX(R),M.getPointY(R),F),T=M.hasZ(R),A=M.hasM(R);return T&&(E.z=M.getPointZ(R)),A&&(E.m=M.getPointM(R)),E},exportPolygon:function o(M,R,F){return new e(M.exportPaths(R),F,M.hasZ(R),M.hasM(R))},exportPolyline:function a(M,R,F){return new h(M.exportPaths(R),F,M.hasZ(R),M.hasM(R))},exportMultipoint:function c(M,R,F){return new r(M.exportPoints(R),F,M.hasZ(R),M.hasM(R))},exportExtent:function m(M,R,F){const E=M.hasZ(R),T=M.hasM(R),A=new x(M.getXMin(R),M.getYMin(R),M.getXMax(R),M.getYMax(R),F);if(E){const F=M.getZExtent(R);A.zmin=F.vmin,A.zmax=F.vmax}if(T){const F=M.getMExtent(R);A.mmin=F.vmin,A.mmax=F.vmax}return A}};class i{constructor(M,R,F){this.x=M,this.y=R,this.spatialReference=F,this.z=void 0,this.m=void 0}}class e{constructor(M,R,F,E){this.rings=M,this.spatialReference=R,this.hasZ=void 0,this.hasM=void 0,F&&(this.hasZ=F),E&&(this.hasM=E)}}class h{constructor(M,R,F,E){this.paths=M,this.spatialReference=R,this.hasZ=void 0,this.hasM=void 0,F&&(this.hasZ=F),E&&(this.hasM=E)}}class r{constructor(M,R,F,E){this.points=M,this.spatialReference=R,this.hasZ=void 0,this.hasM=void 0,F&&(this.hasZ=F),E&&(this.hasM=E)}}class x{constructor(M,R,F,E,T){this.xmin=M,this.ymin=R,this.xmax=F,this.ymax=E,this.spatialReference=T,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}},61816:(M,R,F)=>{F.d(R,{F:()=>o});var E=F(50886),T=F(30925),A=F(88965);const C={minX:0,minY:0,maxX:0,maxY:0};function e(M,R,F){(function t(M){C.minX=M[0],C.minY=M[1],C.maxX=M[2],C.maxY=M[3]})(R),M.search(C,F)}class o{constructor(){this._indexInvalid=!1,this._boundsToLoad=[],this._boundsById=new Map,this._idByBounds=new Map,this._index=new T.w(9,(0,E.A)("esri-csp-restrictions")?M=>({minX:M[0],minY:M[1],maxX:M[2],maxY:M[3]}):["[0]","[1]","[2]","[3]"]),this._loadIndex=()=>{if(this._indexInvalid){const M=new Array(this._idByBounds.size);let R=0;this._idByBounds.forEach(((F,E)=>{M[R++]=E})),this._indexInvalid=!1,this._index.clear(),this._index.load(M)}else this._boundsToLoad.length&&(this._index.load(Array.from(new Set(this._boundsToLoad.filter((M=>this._idByBounds.has(M)))))),this._boundsToLoad.length=0)}}get fullBounds(){if(!this._boundsById.size)return null;const M=(0,A.Ie)();for(const R of this._boundsById.values())R&&(M[0]=Math.min(R[0],M[0]),M[1]=Math.min(R[1],M[1]),M[2]=Math.max(R[2],M[2]),M[3]=Math.max(R[3],M[3]));return M}get valid(){return!this._indexInvalid}clear(){this._indexInvalid=!1,this._boundsToLoad.length=0,this._boundsById.clear(),this._idByBounds.clear(),this._index.clear()}delete(M){const R=this._boundsById.get(M);this._boundsById.delete(M),R&&(this._idByBounds.delete(R),this._indexInvalid||this._index.remove(R))}forEachInBounds(M,R){this._loadIndex(),e(this._index,M,(M=>R(this._idByBounds.get(M))))}get(M){return this._boundsById.get(M)}has(M){return this._boundsById.has(M)}invalidateIndex(){this._indexInvalid||(this._indexInvalid=!0,this._boundsToLoad.length=0)}set(M,R){if(!this._indexInvalid){const R=this._boundsById.get(M);R&&(this._index.remove(R),this._idByBounds.delete(R))}this._boundsById.set(M,R),R&&(this._idByBounds.set(R,M),this._indexInvalid||(this._boundsToLoad.push(R),this._boundsToLoad.length>5e4&&this._loadIndex()))}}},45691:(M,R,F)=>{F.d(R,{A:()=>m});var E=F(16842),T=F(4180),A=F(73067),C=F(89412),Z=F(21374),X=F(88965),N=F(32050),q=F(61816),D=F(23047),z=F(19464);const k=(0,Z.vt)();class m{constructor(M){this.geometryInfo=M,this._boundsStore=new q.F,this._featuresById=new Map,this._markedIds=new Set,this.events=new A.A,this.featureAdapter=z.T}get geometryType(){return this.geometryInfo.geometryType}get hasM(){return this.geometryInfo.hasM}get hasZ(){return this.geometryInfo.hasZ}get numFeatures(){return this._featuresById.size}get fullBounds(){return this._boundsStore.fullBounds}get storeStatistics(){let M=0;return this._featuresById.forEach((R=>{null!=R.geometry&&R.geometry.coords&&(M+=R.geometry.coords.length)})),{featureCount:this._featuresById.size,vertexCount:M/(this.hasZ?this.hasM?4:3:this.hasM?3:2)}}getFullExtent(M){if(null==this.fullBounds)return null;const[R,F,E,T]=this.fullBounds;return{xmin:R,ymin:F,xmax:E,ymax:T,spatialReference:(0,D.ag)(M)}}add(M){this._add(M),this._emitChanged()}addMany(M){for(const R of M)this._add(R);this._emitChanged()}upsertMany(M){const R=M.map((M=>this._upsert(M)));return this._emitChanged(),R.filter(E.Ru)}clear(){this._featuresById.clear(),this._boundsStore.clear(),this._emitChanged()}removeById(M){const R=this._featuresById.get(M);return R?(this._remove(R),this._emitChanged(),R):null}removeManyById(M){this._boundsStore.invalidateIndex();for(const R of M){const M=this._featuresById.get(R);M&&this._remove(M)}this._emitChanged()}forEachBounds(M,R){for(const F of M){const M=this._boundsStore.get(F.objectId);M&&R((0,Z.Jt)(k,M))}}getFeature(M){return this._featuresById.get(M)}has(M){return this._featuresById.has(M)}forEach(M){this._featuresById.forEach((R=>M(R)))}forEachInBounds(M,R){this._boundsStore.forEachInBounds(M,(M=>{R(this._featuresById.get(M))}))}startMarkingUsedFeatures(){this._boundsStore.invalidateIndex(),this._markedIds.clear()}sweep(){let M=!1;this._featuresById.forEach(((R,F)=>{this._markedIds.has(F)||(M=!0,this._remove(R))})),this._markedIds.clear(),M&&this._emitChanged()}_emitChanged(){this.events.emit("changed",void 0)}_add(M){var R;if(!M)return;const F=M.objectId;if(null==F)return void C.A.getLogger("esri.layers.graphics.data.FeatureStore").error(new T.A("featurestore:invalid-feature","feature id is missing",{feature:M}));const E=this._featuresById.get(F);let A;if(this._markedIds.add(F),E?(M.displayId=E.displayId,A=this._boundsStore.get(F),this._boundsStore.delete(F)):null!=this.onFeatureAdd&&this.onFeatureAdd(M),null===(R=M.geometry)||void 0===R||null===(R=R.coords)||void 0===R||!R.length)return this._boundsStore.set(F,null),void this._featuresById.set(F,M);A=(0,N.jQ)(null!=A?A:(0,X.vt)(),M.geometry,this.geometryInfo.hasZ,this.geometryInfo.hasM),null!=A&&this._boundsStore.set(F,A),this._featuresById.set(F,M)}_upsert(M){var R;const F=null===M||void 0===M?void 0:M.objectId;if(null==F)return C.A.getLogger("esri.layers.graphics.data.FeatureStore").error(new T.A("featurestore:invalid-feature","feature id is missing",{feature:M})),null;const E=this._featuresById.get(F);if(!E)return this._add(M),M;this._markedIds.add(F);const{geometry:A,attributes:Z}=M;for(const T in Z)E.attributes[T]=Z[T];return A&&(E.geometry=A,this._boundsStore.set(F,null!==(R=(0,N.jQ)((0,X.vt)(),A,this.geometryInfo.hasZ,this.geometryInfo.hasM))&&void 0!==R?R:null)),E}_remove(M){null!=this.onFeatureRemove&&this.onFeatureRemove(M);const R=M.objectId;return this._markedIds.delete(R),this._boundsStore.delete(R),this._featuresById.delete(R),M}}},23047:(M,R,F)=>{F.d(R,{LQ:()=>y,ag:()=>h,pL:()=>a});var E=F(32050),T=F(41156);const A=new T.A,C=new T.A,Z=new T.A,X={esriGeometryPoint:E.DF,esriGeometryPolyline:E.BW,esriGeometryPolygon:E.z5,esriGeometryMultipoint:E.qK};function y(M,R,F){let T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:M.hasZ,A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:M.hasM;if(null==R)return null;const C=M.hasZ&&T,X=M.hasM&&A;if(F){const N=(0,E.Nl)(Z,R,M.hasZ,M.hasM,"esriGeometryPoint",F,T,A);return(0,E.DF)(N,C,X)}return(0,E.DF)(R,C,X)}function a(M,R,F,T,N,q){var D,z;let k=arguments.length>6&&void 0!==arguments[6]?arguments[6]:R,L=arguments.length>7&&void 0!==arguments[7]?arguments[7]:F;const Q=R&&k,K=F&&L,W=null!=T?"coords"in T?T:T.geometry:null;if(null==W)return null;if(N){var $,J;let T=(0,E.kz)(C,W,R,F,M,N,k,L);return q&&(T=(0,E.Nl)(Z,T,Q,K,M,q)),null!==($=null===(J=X[M])||void 0===J?void 0:J.call(X,T,Q,K))&&void 0!==$?$:null}if(q){var H,V;const T=(0,E.Nl)(Z,W,R,F,M,q,k,L);return null!==(H=null===(V=X[M])||void 0===V?void 0:V.call(X,T,Q,K))&&void 0!==H?H:null}return(0,E.Q4)(A,W,R,F,k,L),null!==(D=null===(z=X[M])||void 0===z?void 0:z.call(X,A,Q,K))&&void 0!==D?D:null}function h(M){return M&&N in M?JSON.parse(JSON.stringify(M,G)):M}const N="_geVersion",G=(M,R)=>M!==N?R:void 0},22786:(M,R,F)=>{F.d(R,{Cv:()=>j,Nk:()=>x,lK:()=>b});var E=F(16842),T=F(81618),A=F(54208),C=F(77026),Z=F(78395),X=F(80417);const N=[0,0];function h(M,R){if(!R)return null;if("x"in R){const F={x:0,y:0};return[F.x,F.y]=M(R.x,R.y,N),null!=R.z&&(F.z=R.z),null!=R.m&&(F.m=R.m),F}if("xmin"in R){const F={xmin:0,ymin:0,xmax:0,ymax:0};return[F.xmin,F.ymin]=M(R.xmin,R.ymin,N),[F.xmax,F.ymax]=M(R.xmax,R.ymax,N),R.hasZ&&(F.zmin=R.zmin,F.zmax=R.zmax,F.hasZ=!0),R.hasM&&(F.mmin=R.mmin,F.mmax=R.mmax,F.hasM=!0),F}return"rings"in R?{rings:l(R.rings,M),hasM:R.hasM,hasZ:R.hasZ}:"paths"in R?{paths:l(R.paths,M),hasM:R.hasM,hasZ:R.hasZ}:"points"in R?{points:f(R.points,M),hasM:R.hasM,hasZ:R.hasZ}:null}function l(M,R){const F=[];for(const E of M)F.push(f(E,R));return F}function f(M,R){const F=[];for(const E of M){const M=R(E[0],E[1],[0,0]);F.push(M),E.length>2&&M.push(E[2]),E.length>3&&M.push(E[3])}return F}async function x(M,R){if(!M||!R)return;const F=Array.isArray(M)?M.map((M=>null!=M.geometry?M.geometry.spatialReference:null)).filter(E.Ru):[M];await(0,A.initializeProjection)(F.map((M=>({source:M,dest:R}))))}const q=h.bind(null,X.je),D=h.bind(null,X.tD);function j(M,R,F,E){if(!M)return M;if(F||(F=R,R=M.spatialReference),!(0,Z.fn)(R)||!(0,Z.fn)(F)||(0,Z.aI)(R,F))return M;if((0,X.y7)(R,F)){const R=(0,Z.K8)(F)?q(M):D(M);return R.spatialReference=F,R}return(0,A.projectMany)(C.g,[M],R,F,null,E)[0]}const z=new class _{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(M,R,F,E){var A;if(null===M||void 0===M||!M.length||!R||!F||(0,Z.aI)(R,F))return M;const C={geometries:M,inSpatialReference:R,outSpatialReference:F,geographicTransformation:E,resolve:(0,T.Tw)()};return this._jobs.push(C),null!==(A=this._timer)&&void 0!==A||(this._timer=setTimeout(this._process,10)),C.resolve.promise}_process(){this._timer=null;const M=this._jobs.shift();if(!M)return;const{geometries:R,inSpatialReference:F,outSpatialReference:E,resolve:T,geographicTransformation:N}=M;(0,X.y7)(F,E)?(0,Z.K8)(E)?T(R.map(q)):T(R.map(D)):T((0,A.projectMany)(C.g,R,F,E,N,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}};function b(M,R,F,E){return z.push(M,R,F,E)}},70857:(M,R,F)=>{F.d(R,{GC:()=>S,T2:()=>j,v8:()=>z});var E=F(40530),T=F(49049),A=F(54208),C=F(25076),Z=F(31670),X=F(30172),N=F(78395),q=F(22786);const D=new E.J({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),z=Object.freeze({});async function S(M,R,F){const{outFields:E,orderByFields:T,groupByFieldsForStatistics:A,outStatistics:C}=M;if(E)for(let Z=0;Z<E.length;Z++)E[Z]=E[Z].trim();if(T)for(let Z=0;Z<T.length;Z++)T[Z]=T[Z].trim();if(A)for(let Z=0;Z<A.length;Z++)A[Z]=A[Z].trim();if(C)for(let Z=0;Z<C.length;Z++)C[Z].onStatisticField&&(C[Z].onStatisticField=C[Z].onStatisticField.trim());return M.geometry&&!M.outSR&&(M.outSR=M.geometry.spatialReference),j(M,R,F)}async function j(M,R,E){var A;if(!M)return null;let{where:k}=M;if(M.where=k=null===(A=k)||void 0===A?void 0:A.trim(),(!k||/^1 *= *1$/.test(k)||R&&R===k)&&(M.where=null),!M.geometry)return M;let L=await async function d(M){const{distance:R,units:E}=M,A=M.geometry;if(null==R||"vertexAttributes"in A)return A;const C=A.spatialReference,Z=E?D.fromJSON(E):(0,T.Ij)(C),X=C&&((0,N.EA)(C)||(0,N.K8)(C))?A:await(0,q.Nk)(C,N.KK).then((()=>(0,q.Cv)(A,N.KK)));return(await async function U(){return(await Promise.all([F.e(8300),F.e(6282)]).then(F.bind(F,93901))).geodesicBuffer}())(X.spatialReference,X,R,Z)}(M);if(M.distance=0,M.units=null,"esriSpatialRelEnvelopeIntersects"===M.spatialRel){const{spatialReference:R}=M.geometry;L=(0,C.HA)(L),L.spatialReference=R}if(L){var Q;await(0,q.Nk)(L.spatialReference,E),L=function x(M,R){const F=M.spatialReference;return w(M,R)&&(0,Z.ZC)(M)?{spatialReference:F,rings:[[[M.xmin,M.ymin],[M.xmin,M.ymax],[M.xmax,M.ymax],[M.xmax,M.ymin],[M.xmin,M.ymin]]]}:M}(L,E);const R=(await(0,X.el)((0,Z.rS)(L)))[0];if(null==R)throw z;const F="quantizationParameters"in M&&(null===(Q=M.quantizationParameters)||void 0===Q?void 0:Q.tolerance)||"maxAllowableOffset"in M&&M.maxAllowableOffset||0,T=F&&w(L,E)?{densificationStep:8*F}:void 0,A=R.toJSON(),C=(0,q.Cv)(A,A.spatialReference,E,T);if(!C)throw z;C.spatialReference=E,M.geometry=C}return M}function w(M,R){if(!M)return!1;const F=M.spatialReference;return((0,Z.ZC)(M)||(0,Z.Bi)(M)||(0,Z.Rg)(M))&&!(0,N.aI)(F,R)&&!(0,A.canProjectWithoutEngine)(F,R)}},70564:(M,R,F)=>{F.d(R,{tC:()=>I,c0:()=>P,xt:()=>v});var E=F(4180),T=F(94224),A=F(5522);var C=F(31670),Z=F(78395);function n(M,R){return M?R?4:3:R?3:2}function contains_r(M,R,F,E,T,A){const C=n(T,A),{coords:Z,lengths:X}=E;if(!X)return!1;for(let N=0,q=0;N<X.length;N++,q+=C)if(!o(M,R,F,Z[q],Z[q+1]))return!1;return!0}function o(M,R,F,E,T){if(!M)return!1;const A=n(R,F),{coords:C,lengths:Z}=M;let X=!1,N=0;for(const q of Z)X=e(X,C,A,N,q,E,T),N+=q*A;return X}function e(M,R,F,E,T,A,C){let Z=M,X=E;for(let N=E,q=E+T*F;N<q;N+=F){X=N+F,X===q&&(X=E);const M=R[N],T=R[N+1],D=R[X],z=R[X+1];(T<C&&z>=C||z<C&&T>=C)&&M+(C-T)/(z-T)*(D-M)<A&&(Z=!Z)}return Z}var X=F(32050),N=F(41156),q=F(23047),D=F(22786);const z="unsupported-query",k={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},L={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function v(M,R,E,Z,D){if((0,C.Bi)(R)&&"esriGeometryPoint"===E&&("esriSpatialRelIntersects"===M||"esriSpatialRelContains"===M)){const M=(0,X.Ye)(new N.A,R,!1,!1);return Promise.resolve((R=>function t(M,R,F,E){return o(M,R,F,E.coords[0],E.coords[1])}(M,!1,!1,R)))}if((0,C.Bi)(R)&&"esriGeometryMultipoint"===E){const F=(0,X.Ye)(new N.A,R,!1,!1);if("esriSpatialRelContains"===M)return Promise.resolve((M=>contains_r(F,!1,!1,M,Z,D)))}if((0,C.ZC)(R)&&"esriGeometryPoint"===E&&("esriSpatialRelIntersects"===M||"esriSpatialRelContains"===M))return Promise.resolve((M=>(0,T.qz)(R,(0,q.pL)(E,Z,D,M))));if((0,C.ZC)(R)&&"esriGeometryMultipoint"===E&&"esriSpatialRelContains"===M)return Promise.resolve((M=>(0,T.rL)(R,(0,q.pL)(E,Z,D,M))));if((0,C.ZC)(R)&&"esriSpatialRelIntersects"===M){const M=function s(M){return"mesh"===M?A.xB:(0,A.xK)(M)}(E);return Promise.resolve((F=>M(R,(0,q.pL)(E,Z,D,F))))}return function h(){return Promise.all([F.e(8300),F.e(6282)]).then(F.bind(F,93901))}().then((F=>{const T=F[k[M]].bind(null,R.spatialReference,R);return M=>T((0,q.pL)(E,Z,D,M))}))}async function P(M,R,F){const{spatialRel:T,geometry:A}=M;if(A){if(!function G(M){return null!=M&&!0===L.spatialRelationship[M]}(T))throw new E.A(z,"Unsupported query spatial relationship",{query:M});if((0,Z.fn)(A.spatialReference)&&(0,Z.fn)(F)){var X;if(!function g(M){return null!=M&&!0===L.queryGeometry[(0,C.$B)(M)]}(A))throw new E.A(z,"Unsupported query geometry type",{query:M});if(!function j(M){return null!=M&&!0===L.layerGeometry[M]}(R))throw new E.A(z,"Unsupported layer geometry type",{query:M});if(M.outSR)return(0,D.Nk)(null===(X=M.geometry)||void 0===X?void 0:X.spatialReference,M.outSR)}}}function I(M){if((0,C.ZC)(M))return!0;if((0,C.Bi)(M)){for(const R of M.rings){if(5!==R.length)return!1;if(R[0][0]!==R[1][0]||R[0][0]!==R[4][0]||R[2][0]!==R[3][0]||R[0][1]!==R[3][1]||R[0][1]!==R[4][1]||R[1][1]!==R[2][1])return!1}return!0}return!1}},66174:(M,R,F)=>{async function n(M,R){if(!M)return null;const F=R.featureAdapter,{startTimeField:E,endTimeField:T}=M;let A=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY;if(E&&T)await R.forEach((M=>{const R=F.getAttribute(M,E),Z=F.getAttribute(M,T);null==R||isNaN(R)||(A=Math.min(A,R)),null==Z||isNaN(Z)||(C=Math.max(C,Z))}));else{const M=E||T;await R.forEach((R=>{const E=F.getAttribute(R,M);null==E||isNaN(E)||(A=Math.min(A,E),C=Math.max(C,E))}))}return{start:A,end:C}}function t(M,R,F){var E,T;if(!R||!M)return null;const{startTimeField:A,endTimeField:C}=M;if(!A&&!C)return null;const{start:Z,end:X}=R;if(null===Z&&null===X)return null;if(void 0===Z&&void 0===X)return()=>!1;const N=null!==(E=null===(T=F.getAttributeAsTimestamp)||void 0===T?void 0:T.bind(F))&&void 0!==E?E:F.getAttribute.bind(F);return A&&C?function l(M,R,F,E,T){return null!=E&&null!=T?A=>{const C=M(A,R),Z=M(A,F);return(null==C||C<=T)&&(null==Z||Z>=E)}:null!=E?R=>{const T=M(R,F);return null==T||T>=E}:null!=T?F=>{const E=M(F,R);return null==E||E<=T}:void 0}(N,A,C,Z,X):function u(M,R,F,E){return null!=F&&null!=E&&F===E?E=>M(E,R)===F:null!=F&&null!=E?T=>{const A=M(T,R);return null!=A&&A>=F&&A<=E}:null!=F?E=>{const T=M(E,R);return null!=T&&T>=F}:null!=E?F=>{const T=M(F,R);return null!=T&&T<=E}:void 0}(N,A||C,Z,X)}F.d(R,{I:()=>t,W:()=>n})},33314:(M,R,F)=>{F.d(R,{H:()=>n,L:()=>E});const E=1;function n(M,R){let F=0;for(const T of R){var E;const R=null===(E=T.attributes)||void 0===E?void 0:E[M];"number"==typeof R&&isFinite(R)&&(F=Math.max(F,R))}return F}},79830:(M,R,F)=>{F.r(R),F.d(R,{default:()=>S});var E=F(4180),T=F(31670),A=F(78395),C=F(32050),Z=F(33314),X=F(45691),N=F(22786),q=F(56103),D=F(39584),z=F(67818),k=F(8084),L=F(68471),Q=F(57022),K=F(52994);const W=A.KK,$={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:A.KK},J={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function O(M){return(0,T.fT)(M)?null!=M.z:!!M.hasZ}function w(M){return(0,T.fT)(M)?null!=M.m:!!M.hasM}class S{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){var M;null!==(M=this._queryEngine)&&void 0!==M&&M.destroy(),this._queryEngine=this._createDefaultAttributes=null}async load(M){var R;const F=[],{features:T}=M,A=this._inferLayerProperties(T,M.fields),C=M.fields||[],z=null!=M.hasM?M.hasM:!!A.hasM,H=null!=M.hasZ?M.hasZ:!!A.hasZ,V=!M.spatialReference&&!A.spatialReference,ee=V?W:M.spatialReference||A.spatialReference,te=V?$:null,ne=M.geometryType||A.geometryType,ie=!ne;let se=M.objectIdField||A.objectIdField,re=M.timeInfo;const oe=new k.A(C);if(!ie&&(V&&F.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!ne))throw new E.A("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!se)throw new E.A("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(A.objectIdField&&se!==A.objectIdField&&(F.push({name:"feature-layer:duplicated-oid-field",message:'Provided objectIdField "'.concat(se,'" doesn\'t match the field name "').concat(A.objectIdField,'", found in the provided fields')}),se=A.objectIdField),se&&!A.objectIdField){const M=oe.get(se);M?(se=M.name,M.type="esriFieldTypeOID",M.editable=!1,M.nullable=!1):C.unshift({alias:se,name:se,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const Z of C){if(null==Z.name&&(Z.name=Z.alias),null==Z.alias&&(Z.alias=Z.name),!Z.name)throw new E.A("feature-layer:invalid-field-name","field name is missing",{field:Z});if(Z.name===se&&(Z.type="esriFieldTypeOID"),!L.m.jsonValues.includes(Z.type))throw new E.A("feature-layer:invalid-field-type",'invalid type for field "'.concat(Z.name,'"'),{field:Z});null==Z.length&&(Z.length=(0,Q._b)(Z))}const ae={};for(const E of C)if("esriFieldTypeOID"!==E.type&&"esriFieldTypeGlobalID"!==E.type){const M=(0,Q.lD)(E);void 0!==M&&(ae[E.name]=M)}if(re){if(re.startTimeField){const M=oe.get(re.startTimeField);M?(re.startTimeField=M.name,M.type="esriFieldTypeDate"):re.startTimeField=null}if(re.endTimeField){const M=oe.get(re.endTimeField);M?(re.endTimeField=M.name,M.type="esriFieldTypeDate"):re.endTimeField=null}if(re.trackIdField){const M=oe.get(re.trackIdField);M?re.trackIdField=M.name:(re.trackIdField=null,F.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:re}}))}re.startTimeField||re.endTimeField||(F.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:re}}),re=null)}const le=oe.dateFields.length?{timeZoneIANA:null!==(R=M.dateFieldsTimeZone)&&void 0!==R?R:K.n$}:null;this._createDefaultAttributes=(0,D.Vx)(ae,se);const ue={warnings:F,featureErrors:[],layerDefinition:{...J,drawingInfo:(0,D.F0)(ne),templates:(0,D.e2)(ae),extent:te,geometryType:ne,objectIdField:se,fields:C,hasZ:H,hasM:z,timeInfo:re,dateFieldsTimeReference:le},assignedObjectIds:{}};if(this._queryEngine=new q.d({fieldsIndex:k.A.fromLayerJSON({fields:C,timeInfo:re,dateFieldsTimeReference:le}),geometryType:ne,hasM:z,hasZ:H,objectIdField:se,spatialReference:ee,featureStore:new X.A({geometryType:ne,hasM:z,hasZ:H}),timeInfo:re,cacheSpatialQueries:!0}),null===T||void 0===T||!T.length)return this._nextObjectId=Z.L,ue;const de=(0,Z.H)(se,T);return this._nextObjectId=de+1,await(0,N.Nk)(T,ee),this._loadInitialFeatures(ue,T)}async applyEdits(M){const{spatialReference:R,geometryType:F}=this._queryEngine;return await Promise.all([(0,z.$1)(R,F),(0,N.Nk)(M.adds,R),(0,N.Nk)(M.updates,R)]),this._applyEdits(M)}queryFeatures(M){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this._queryEngine.executeQuery(M,R.signal)}queryFeatureCount(M){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this._queryEngine.executeQueryForCount(M,R.signal)}queryObjectIds(M){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this._queryEngine.executeQueryForIds(M,R.signal)}queryExtent(M){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this._queryEngine.executeQueryForExtent(M,R.signal)}querySnapping(M){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this._queryEngine.executeQueryForSnapping(M,R.signal)}_inferLayerProperties(M,R){let F,E,A=null,C=null,Z=null;for(const X of M){const M=X.geometry;if(null!=M&&(A||(A=(0,T.$B)(M)),C||(C=M.spatialReference),null==F&&(F=O(M)),null==E&&(E=w(M)),A&&C&&null!=F&&null!=E))break}if(R&&R.length){let M=null;R.some((R=>{const F="esriFieldTypeOID"===R.type,E=!R.type&&R.name&&"objectid"===R.name.toLowerCase();return M=R,F||E}))&&(Z=M.name)}return{geometryType:A,spatialReference:C,objectIdField:Z,hasM:E,hasZ:F}}async _loadInitialFeatures(M,R){const{geometryType:F,hasM:E,hasZ:A,objectIdField:Z,spatialReference:X,featureStore:q,fieldsIndex:D}=this._queryEngine,k=[];for(const C of R){if(null!=C.uid&&(M.assignedObjectIds[C.uid]=-1),C.geometry&&F!==(0,T.$B)(C.geometry)){M.featureErrors.push((0,z.Yx)("Incorrect geometry type."));continue}const R=this._createDefaultAttributes(),E=(0,z.MB)(D,R,C.attributes,!0);E?M.featureErrors.push(E):(this._assignObjectId(R,C.attributes,!0),C.attributes=R,null!=C.uid&&(M.assignedObjectIds[C.uid]=C.attributes[Z]),null!=C.geometry&&(C.geometry=(0,N.Cv)(C.geometry,C.geometry.spatialReference,X)),k.push(C))}q.addMany((0,C.Di)([],k,F,A,E,Z));const{fullExtent:L,timeExtent:Q}=await this._queryEngine.fetchRecomputedExtents();if(M.layerDefinition.extent=L,Q){const{start:R,end:F}=Q;M.layerDefinition.timeInfo.timeExtent=[R,F]}return M}async _applyEdits(M){const{adds:R,updates:F,deletes:E}=M,T={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(null!==R&&void 0!==R&&R.length&&this._applyAddEdits(T,R),null!==F&&void 0!==F&&F.length&&this._applyUpdateEdits(T,F),null!==E&&void 0!==E&&E.length){for(const M of E)T.deleteResults.push((0,z.bP)(M));this._queryEngine.featureStore.removeManyById(E)}const{fullExtent:A,timeExtent:C}=await this._queryEngine.fetchRecomputedExtents();return{extent:A,timeExtent:C,featureEditResults:T}}_applyAddEdits(M,R){const{addResults:F}=M,{geometryType:E,hasM:A,hasZ:Z,objectIdField:X,spatialReference:q,featureStore:D,fieldsIndex:k}=this._queryEngine,L=[];for(const C of R){if(C.geometry&&E!==(0,T.$B)(C.geometry)){F.push((0,z.Yx)("Incorrect geometry type."));continue}const R=this._createDefaultAttributes(),A=(0,z.MB)(k,R,C.attributes);if(A)F.push(A);else{if(this._assignObjectId(R,C.attributes),C.attributes=R,null!=C.uid){const R=C.attributes[X];M.uidToObjectId[C.uid]=R}if(null!=C.geometry){var Q;const M=null!==(Q=C.geometry.spatialReference)&&void 0!==Q?Q:q;C.geometry=(0,N.Cv)((0,z.CR)(C.geometry,M),M,q)}L.push(C),F.push((0,z.bP)(C.attributes[X]))}}D.addMany((0,C.Di)([],L,E,Z,A,X))}_applyUpdateEdits(M,R){let{updateResults:F}=M;const{geometryType:E,hasM:A,hasZ:Z,objectIdField:X,spatialReference:q,featureStore:D,fieldsIndex:k}=this._queryEngine;for(const Q of R){const{attributes:M,geometry:R}=Q,K=null===M||void 0===M?void 0:M[X];if(null==K){F.push((0,z.Yx)("Identifier field ".concat(X," missing")));continue}if(!D.has(K)){F.push((0,z.Yx)("Feature with object id ".concat(K," missing")));continue}const W=(0,C.oN)(D.getFeature(K),E,Z,A);if(null!=R){var L;if(E!==(0,T.$B)(R)){F.push((0,z.Yx)("Incorrect geometry type."));continue}const M=null!==(L=R.spatialReference)&&void 0!==L?L:q;W.geometry=(0,N.Cv)((0,z.CR)(R,M),M,q)}if(M){const R=(0,z.MB)(k,W.attributes,M);if(R){F.push(R);continue}}D.add((0,C.E2)(W,E,Z,A,X)),F.push((0,z.bP)(K))}}_assignObjectId(M,R){let F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=this._queryEngine.objectIdField;F&&R&&isFinite(R[E])?M[E]=R[E]:M[E]=this._nextObjectId++}}},67818:(M,R,F)=>{F.d(R,{$1:()=>j,CR:()=>y,MB:()=>p,Yx:()=>f,bP:()=>d});var E=F(62408),T=F(78395),A=F(57022);class u{constructor(){this.code=null,this.description=null}}class c{constructor(M){this.error=new u,this.globalId=null,this.objectId=null,this.success=!1,this.uniqueId=null,this.error.description=M}}function f(M){return new c(M)}class a{constructor(M){this.globalId=null,this.success=!0,this.objectId=this.uniqueId=M}}function d(M){return new a(M)}const C=new Set;function p(M,R,F){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];C.clear();for(const Z in F){const T=M.get(Z);if(!T)continue;const X=g(T,F[Z]);if(C.add(T.name),T&&(E||T.editable)){const M=(0,A.CJ)(T,X);if(M)return f((0,A.uo)(M,T,X));R[T.name]=X}}for(const A of null!==(T=null===M||void 0===M?void 0:M.requiredFields)&&void 0!==T?T:[]){var T;if(!C.has(A.name))return f('missing required field "'.concat(A.name,'"'))}return null}function g(M,R){let F=R;return(0,A.WA)(M)&&"string"==typeof R?F=parseFloat(R):(0,A.yM)(M)&&null!=R&&"string"!=typeof R?F=String(R):(0,A.vE)(M)&&"string"==typeof R&&(F=(0,E._U)(R)),(0,A.WX)(F)}let Z;function y(M,R){if(!M||!(0,T.fn)(R))return M;if("rings"in M||"paths"in M){if(null==Z)throw new TypeError("geometry engine not loaded");return Z.simplify(R,M)}return M}async function j(M,R){!(0,T.fn)(M)||"esriGeometryPolygon"!==R&&"esriGeometryPolyline"!==R||await async function w(){return null==Z&&(Z=await Promise.all([F.e(8300),F.e(3901)]).then(F.bind(F,93901))),Z}()}}}]);
//# sourceMappingURL=6328.41b5a93e.chunk.js.map