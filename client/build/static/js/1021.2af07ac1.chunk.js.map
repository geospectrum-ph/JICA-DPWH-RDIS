{"version":3,"file":"static/js/1021.2af07ac1.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/src/utils/form.tsx","../node_modules/@esri/calcite-components/dist/components/src/utils/interactive.tsx","../node_modules/@esri/calcite-components/dist/components/src/utils/browser.ts","../node_modules/@esri/calcite-components/dist/components/src/utils/label.ts"],"sourcesContent":["import { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\nimport { FunctionalComponent, h } from \"@stencil/core\";\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nexport const componentsWithInputEvent = [\n  \"calcite-input\",\n  \"calcite-input-number\",\n  \"calcite-input-text\",\n  \"calcite-text-area\",\n];\n\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nexport function getClearValidationEventName(componentTag: string): string {\n  const componentTagCamelCase = componentTag\n    .split(\"-\")\n    .map((part: string, index: number) =>\n      index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`,\n    )\n    .join(\"\");\n\n  const clearValidationEvent = `${componentTagCamelCase}${\n    componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"\n  }`;\n\n  return clearValidationEvent;\n}\n\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\n\n/**\n * Defines interface for form owning components.\n *\n * Allows calling submit/reset methods on the form.\n */\nexport interface FormOwner {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * The ID of the form to associate with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  form: string;\n\n  /**\n   * The form this component is associated with.\n   *\n   * @internal\n   */\n  formEl: HTMLFormElement;\n}\n\n/**\n * Defines interface for form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface FormComponent<T = any> extends FormOwner {\n  /**\n   * When true, this component's value will not be submitted in the form.\n   */\n  disabled: boolean;\n\n  /**\n   * When true, form submit requests will enforce field requirement.\n   *\n   * @todo remove optional in follow-up PR\n   */\n  required?: boolean;\n\n  /**\n   * The name used to submit the value to the associated form.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  name: string;\n\n  /**\n   * This form component's value.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  value: T;\n\n  /**\n   * The initial value for this form component.\n   *\n   * When the form is reset, the value will be set to this property.\n   */\n  defaultValue: T;\n\n  /**\n   * Hook for components to provide custom form reset behavior.\n   */\n  onFormReset?(): void;\n\n  /**\n   * Hook for components to sync _extra_ props on the hidden input form element used for form-submitting.\n   *\n   * Note: The following props are set by default: disabled, hidden, name, required, value.\n   */\n  syncHiddenFormInput?(input: HTMLInputElement): void;\n}\n\n/**\n * Defines interface for checkable form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface CheckableFormComponent<T = any> extends FormComponent<T> {\n  /**\n   * For boolean-valued components, this property defines whether the associated value is submitted to the form or not.\n   */\n  checked: boolean;\n\n  /**\n   * The initial checked value for this form component.\n   *\n   * When the form is reset, the checked property will be set to this value.\n   */\n  defaultChecked: boolean;\n}\n\nfunction isCheckable(component: FormComponent): component is CheckableFormComponent {\n  return \"checked\" in component;\n}\n\nconst onFormResetMap = new WeakMap<HTMLElement, FormComponent[\"onFormReset\"]>();\nconst formComponentSet = new WeakSet<HTMLElement>();\n\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(\n  form: HTMLFormElement,\n  formComponentEl: HTMLElement,\n): boolean {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(\n    formComponentEl.parentElement,\n    \"[form]\",\n  );\n\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n\n  let hasRegisteredFormComponentParent = false;\n\n  form.addEventListener(\n    formComponentRegisterEventName,\n    (event) => {\n      hasRegisteredFormComponentParent = event\n        .composedPath()\n        .some((element) => formComponentSet.has(element as HTMLElement));\n      event.stopPropagation();\n    },\n    { once: true },\n  );\n\n  formComponentEl.dispatchEvent(\n    new CustomEvent(formComponentRegisterEventName, {\n      bubbles: true,\n      composed: true,\n    }),\n  );\n\n  return hasRegisteredFormComponentParent;\n}\n\nfunction clearFormValidation(component: HTMLCalciteInputElement | FormComponent): void {\n  \"status\" in component && (component.status = \"idle\");\n  \"validationIcon\" in component && (component.validationIcon = false);\n  \"validationMessage\" in component && (component.validationMessage = \"\");\n}\n\nfunction setInvalidFormValidation(\n  component: HTMLCalciteInputElement | FormComponent,\n  message: string,\n): void {\n  \"status\" in component && (component.status = \"invalid\");\n\n  \"validationIcon\" in component && !component.validationIcon && (component.validationIcon = true);\n\n  \"validationMessage\" in component &&\n    !component.validationMessage &&\n    (component.validationMessage = message);\n}\n\nfunction displayValidationMessage(event: Event) {\n  // target is the hidden input, which is slotted in the actual form component\n  const hiddenInput = event?.target as HTMLInputElement;\n\n  // not necessarily a calcite-input, but we don't have an HTMLCalciteFormElement type\n  const formComponent = hiddenInput?.parentElement as HTMLCalciteInputElement;\n\n  const componentTag = formComponent?.nodeName?.toLowerCase();\n  const componentTagParts = componentTag?.split(\"-\");\n\n  if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n    return;\n  }\n\n  // prevent the browser from showing the native validation popover\n  event?.preventDefault();\n\n  setInvalidFormValidation(formComponent, hiddenInput?.validationMessage);\n\n  if (formComponent?.validationMessage !== hiddenInput?.validationMessage) {\n    return;\n  }\n\n  const clearValidationEvent = getClearValidationEventName(componentTag);\n  formComponent.addEventListener(clearValidationEvent, () => clearFormValidation(formComponent), {\n    once: true,\n  });\n}\n\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component: FormOwner): boolean {\n  const { formEl } = component;\n\n  if (!formEl) {\n    return false;\n  }\n\n  formEl.addEventListener(\"invalid\", displayValidationMessage, true);\n  formEl.requestSubmit();\n  formEl.removeEventListener(\"invalid\", displayValidationMessage, true);\n\n  requestAnimationFrame(() => {\n    const invalidEls = formEl.querySelectorAll(\"[status=invalid]\");\n\n    // focus the first invalid element that has a validation message\n    for (const el of invalidEls) {\n      if ((el as HTMLCalciteInputElement)?.validationMessage) {\n        (el as HTMLCalciteInputElement)?.setFocus();\n        break;\n      }\n    }\n  });\n\n  return true;\n}\n\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component: FormOwner): void {\n  component.formEl?.reset();\n}\n\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm<T>(component: FormComponent<T>): void {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component: FormOwner): HTMLFormElement | null {\n  const { el, form } = component;\n\n  return form\n    ? queryElementRoots<HTMLFormElement>(el, { id: form })\n    : closestElementCrossShadowBoundary<HTMLFormElement>(el, \"form\");\n}\n\nfunction onFormReset<T>(this: FormComponent<T>): void {\n  clearFormValidation(this);\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n\n  this.value = this.defaultValue;\n}\n\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm<T>(component: FormComponent<T>): void {\n  const { el, formEl } = component;\n\n  if (!formEl) {\n    return;\n  }\n\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet<T>(component: FormComponent<T>, value: any): void {\n  component.defaultValue = value;\n}\n\nexport const internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\n\nconst hiddenInputInputHandler = (event: Event) => {\n  event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\n\nconst removeHiddenInputChangeEventListener = (input: HTMLInputElement) =>\n  input.removeEventListener(\"input\", hiddenInputInputHandler);\n\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component: FormComponent): void {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n\n  const inputs = el.querySelectorAll<HTMLInputElement>(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n\n  const values = Array.isArray(value) ? value : [value];\n  const extra: any[] = [];\n  const seen = new Set<any>();\n\n  inputs.forEach((input) => {\n    const valueMatch = values.find(\n      (val) =>\n        /* intentional non-strict equality check */\n        val == input.value,\n    );\n\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    } else {\n      extra.push(input);\n    }\n  });\n\n  let docFrag: DocumentFragment;\n\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n\n    let input = extra.pop();\n\n    if (!input) {\n      input = ownerDocument!.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n\n    if (!docFrag) {\n      docFrag = ownerDocument!.createDocumentFragment();\n    }\n\n    docFrag.append(input);\n\n    // emits when hidden input is autofilled\n    input.addEventListener(\"input\", hiddenInputInputHandler);\n\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\n\nfunction defaultSyncHiddenFormInput(\n  component: FormComponent,\n  input: HTMLInputElement,\n  value: string,\n): void {\n  const { defaultValue, disabled, form, name, required } = component;\n\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  } else {\n    input.removeAttribute(\"form\");\n  }\n\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  } else {\n    input.value = value || \"\";\n  }\n\n  component.syncHiddenFormInput?.(input);\n}\n\ninterface HiddenFormInputSlotProps {\n  component: FormComponent;\n}\n\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot: FunctionalComponent<HiddenFormInputSlotProps> = ({\n  component,\n}) => {\n  syncHiddenFormInput(component);\n\n  return <slot name={hiddenFormInputSlotName} />;\n};\n","import { getUserAgentString } from \"./browser\";\nimport { JSXAttributes } from \"@stencil/core/internal\";\nimport { FunctionalComponent, h, VNode } from \"@stencil/core\";\n\nexport interface InteractiveComponent {\n  /**\n   * The host element.\n   */\n  readonly el: InteractiveHTMLElement;\n\n  /**\n   * When true, prevents user interaction.\n   *\n   * Notes:\n   *\n   * This prop should use the @Prop decorator and reflect.\n   * The `disabled` Sass mixin must be added to the component's stylesheet.\n   */\n  disabled: boolean;\n}\n\n/**\n * Exported for testing purposes only.\n *\n * @internal\n */\nexport type InteractiveHTMLElement = HTMLElement & Pick<InteractiveComponent, \"disabled\">;\n\n// ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\nconst isFirefox = /firefox/i.test(getUserAgentString());\n\ntype ParentElement<T extends HTMLElement = HTMLElement> = T | null;\n\nconst disabledElementToParent: WeakMap<InteractiveHTMLElement, ParentElement> | null = isFirefox\n  ? new WeakMap()\n  : null;\n\nfunction interceptedClick(): void {\n  const { disabled } = this as InteractiveHTMLElement;\n\n  if (!disabled) {\n    HTMLElement.prototype.click.call(this);\n  }\n}\n\nfunction onPointerDown(event: PointerEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (isFirefox && !disabledElementToParent.get(interactiveElement)) {\n    return;\n  }\n\n  const { disabled } = interactiveElement;\n\n  if (disabled) {\n    // prevent click from moving focus on host\n    event.preventDefault();\n  }\n}\n\nconst nonBubblingWhenDisabledMouseEvents = [\"mousedown\", \"mouseup\", \"click\"];\n\nfunction onNonBubblingWhenDisabledMouseEvent(event: MouseEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (isFirefox && !disabledElementToParent.get(interactiveElement)) {\n    return;\n  }\n\n  // prevent disallowed mouse events from being emitted on the disabled host (per https://github.com/whatwg/html/issues/5886)\n  // ⚠ we generally avoid stopping propagation of events, but this is needed to adhere to the intended spec changes above ⚠\n  if (interactiveElement.disabled) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n}\n\nconst captureOnlyOptions = { capture: true } as const;\n\n/**\n * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.\n *\n * This should be used in the `componentDidRender` lifecycle hook.\n *\n * **Notes**\n *\n * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.\n * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error\n *\n * @param component\n */\nexport function updateHostInteraction(component: InteractiveComponent): void {\n  if (component.disabled) {\n    component.el.setAttribute(\"aria-disabled\", \"true\");\n\n    if (component.el.contains(document.activeElement)) {\n      (document.activeElement as HTMLElement).blur();\n    }\n\n    blockInteraction(component);\n\n    return;\n  }\n\n  restoreInteraction(component);\n\n  component.el.removeAttribute(\"aria-disabled\");\n}\n\nfunction blockInteraction(component: InteractiveComponent): void {\n  component.el.click = interceptedClick;\n\n  if (isFirefox) {\n    const currentParent = getParentElement(component);\n    const trackedParent = disabledElementToParent.get(component.el);\n\n    if (trackedParent !== currentParent) {\n      removeInteractionListeners(trackedParent);\n      disabledElementToParent.set(component.el, currentParent);\n    }\n\n    addInteractionListeners(disabledElementToParent.get(component.el));\n    return;\n  }\n\n  addInteractionListeners(component.el);\n}\n\nfunction addInteractionListeners(element: HTMLElement): void {\n  if (!element) {\n    // this early return path is only applicable to Firefox\n    return;\n  }\n\n  element.addEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.addEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\nfunction getParentElement(component: InteractiveComponent): ParentElement {\n  return (\n    component.el.parentElement || component.el\n  ); /* assume element is host if it has no parent when connected */\n}\n\nfunction restoreInteraction(component: InteractiveComponent): void {\n  delete component.el.click; // fallback on HTMLElement.prototype.click\n\n  if (isFirefox) {\n    removeInteractionListeners(disabledElementToParent.get(component.el));\n    disabledElementToParent.delete(component.el);\n    return;\n  }\n\n  removeInteractionListeners(component.el);\n}\n\nfunction removeInteractionListeners(element: HTMLElement): void {\n  if (!element) {\n    // this early return path is only applicable to Firefox\n    return;\n  }\n\n  element.removeEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.removeEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\n/**\n * This utility helps disable components consistently in Firefox.\n *\n * It needs to be called in `connectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nexport function connectInteractive(component: InteractiveComponent): void {\n  if (!component.disabled || !isFirefox) {\n    return;\n  }\n\n  blockInteraction(component);\n}\n\n/**\n * This utility restores interactivity to disabled components consistently in Firefox.\n *\n * It needs to be called in `disconnectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nexport function disconnectInteractive(component: InteractiveComponent): void {\n  if (!isFirefox) {\n    return;\n  }\n\n  restoreInteraction(component);\n}\n\nexport interface InteractiveContainerOptions extends JSXAttributes {\n  disabled: boolean;\n}\n\nexport const CSS = {\n  container: \"interaction-container\",\n};\n\nexport function InteractiveContainer(\n  { disabled }: InteractiveContainerOptions,\n  children: VNode[],\n): FunctionalComponent {\n  return (\n    <div class={CSS.container} inert={disabled}>\n      {...children}\n    </div>\n  );\n}\n","import { Build } from \"@stencil/core\";\n\ninterface NavigatorUAData {\n  brands: Array<{ brand: string; version: string }>;\n  mobile: boolean;\n  platform: string;\n}\n\nfunction getUserAgentData(): NavigatorUAData | undefined {\n  return (navigator as any).userAgentData;\n}\n\nexport function getUserAgentString(): string {\n  if (!Build.isBrowser) {\n    return \"\";\n  }\n\n  const uaData = getUserAgentData();\n\n  return uaData?.brands\n    ? uaData.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \")\n    : navigator.userAgent;\n}\n","import { closestElementCrossShadowBoundary, isBefore, queryElementRoots } from \"./dom\";\nimport { componentOnReady } from \"./component\";\n\nexport interface LabelableComponent {\n  /**\n   * When true, disabled prevents interaction.\n   */\n  disabled: boolean;\n\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * Text label.\n   */\n  label?: string;\n\n  /**\n   * The label this component is associated with.\n   */\n  labelEl: HTMLCalciteLabelElement;\n\n  /**\n   * Hook for components to provide custom label click behavior.\n   */\n  onLabelClick: (event: CustomEvent<any>) => void;\n}\n\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nexport const labelClickEvent = \"calciteInternalLabelClick\";\nexport const labelConnectedEvent = \"calciteInternalLabelConnected\";\nexport const labelDisconnectedEvent = \"calciteInternalLabelDisconnected\";\n\nconst labelTagName = \"calcite-label\";\nconst labelToLabelables = new WeakMap<HTMLCalciteLabelElement, LabelableComponent[]>();\nconst onLabelClickMap = new WeakMap<HTMLCalciteLabelElement, typeof onLabelClick>();\nconst onLabelConnectedMap = new WeakMap<LabelableComponent, typeof onLabelConnected>();\nconst onLabelDisconnectedMap = new WeakMap<LabelableComponent, typeof onLabelDisconnected>();\nconst unlabeledComponents = new Set<LabelableComponent>();\n\nconst findLabelForComponent = (componentEl: HTMLElement): HTMLCalciteLabelElement | null => {\n  const { id } = componentEl;\n\n  const forLabel =\n    id && (queryElementRoots(componentEl, { selector: `${labelTagName}[for=\"${id}\"]` }) as HTMLCalciteLabelElement);\n\n  if (forLabel) {\n    return forLabel;\n  }\n\n  const parentLabel = closestElementCrossShadowBoundary<HTMLCalciteLabelElement>(componentEl, labelTagName);\n\n  if (\n    !parentLabel ||\n    // labelable components within other custom elements are not considered labelable\n    hasAncestorCustomElements(parentLabel, componentEl)\n  ) {\n    return null;\n  }\n\n  return parentLabel;\n};\n\nfunction hasAncestorCustomElements(label: HTMLCalciteLabelElement, componentEl: HTMLElement): boolean {\n  let traversedElements: HTMLElement[];\n  const customElementAncestorCheckEventType = \"custom-element-ancestor-check\";\n\n  const listener = (event: CustomEvent) => {\n    event.stopImmediatePropagation();\n    const composedPath = event.composedPath() as HTMLElement[];\n    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));\n  };\n\n  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });\n\n  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));\n  label.removeEventListener(customElementAncestorCheckEventType, listener);\n\n  const ancestorCustomElements = traversedElements\n    .filter((el) => el !== componentEl && el !== label)\n    .filter((el) => el.tagName?.includes(\"-\"));\n\n  return ancestorCustomElements.length > 0;\n}\n\n/**\n * Helper to set up label interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  const labelEl = findLabelForComponent(component.el);\n\n  if (\n    (onLabelClickMap.has(labelEl) && labelEl === component.labelEl) ||\n    (!labelEl && unlabeledComponents.has(component))\n  ) {\n    return;\n  }\n\n  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);\n\n  if (labelEl) {\n    component.labelEl = labelEl;\n\n    const labelables = labelToLabelables.get(labelEl) || [];\n    labelables.push(component);\n    labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));\n\n    if (!onLabelClickMap.has(component.labelEl)) {\n      onLabelClickMap.set(component.labelEl, onLabelClick);\n      component.labelEl.addEventListener(labelClickEvent, onLabelClick);\n    }\n\n    unlabeledComponents.delete(component);\n    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);\n    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);\n  } else if (!unlabeledComponents.has(component)) {\n    boundOnLabelDisconnected();\n    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  }\n}\n/**\n * Helper to tear down label interactions on disconnectedCallback on labelable components.\n *\n * @param component\n */\nexport function disconnectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  unlabeledComponents.delete(component);\n  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  onLabelConnectedMap.delete(component);\n  onLabelDisconnectedMap.delete(component);\n\n  if (!component.labelEl) {\n    return;\n  }\n\n  const labelables = labelToLabelables.get(component.labelEl);\n\n  if (labelables.length === 1) {\n    component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));\n    onLabelClickMap.delete(component.labelEl);\n  }\n\n  labelToLabelables.set(\n    component.labelEl,\n    labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder),\n  );\n\n  component.labelEl = null;\n}\n\nfunction sortByDOMOrder(a: LabelableComponent, b: LabelableComponent): number {\n  return isBefore(a.el, b.el) ? -1 : 1;\n}\n\n/**\n * Helper to get the label text from a component.\n *\n * @param component\n */\nexport function getLabelText(component: LabelableComponent): string {\n  return component.label || component.labelEl?.textContent?.trim() || \"\";\n}\n\nfunction onLabelClick(this: HTMLCalciteLabelElement, event: CustomEvent<{ sourceEvent: MouseEvent }>): void {\n  const labelClickTarget = event.detail.sourceEvent.target as HTMLElement;\n  const labelables = labelToLabelables.get(this);\n  const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);\n  const labelableChildClicked = labelables.includes(clickedLabelable);\n\n  if (labelableChildClicked) {\n    // no need to forward click as labelable will receive focus\n    return;\n  }\n\n  const firstLabelable = labelables[0];\n\n  if (firstLabelable.disabled) {\n    return;\n  }\n\n  firstLabelable.onLabelClick(event);\n}\n\nfunction onLabelConnected(this: LabelableComponent): void {\n  if (unlabeledComponents.has(this)) {\n    connectLabel(this);\n  }\n}\n\nfunction onLabelDisconnected(this: LabelableComponent): void {\n  unlabeledComponents.add(this);\n  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);\n  onLabelConnectedMap.set(this, boundOnLabelConnected);\n  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);\n}\n\n/**\n * Helper to associate an explicit label (i.e., using `for`) with a labelable component that does not have an associated label.\n *\n * @param label - the label element\n */\nexport async function associateExplicitLabelToUnlabeledComponent(label: HTMLCalciteLabelElement): Promise<void> {\n  await componentOnReady(label);\n\n  const alreadyLabeled = labelToLabelables.has(label);\n\n  if (alreadyLabeled) {\n    return;\n  }\n\n  const forComponentEl = label.ownerDocument?.getElementById(label.for);\n\n  if (!forComponentEl) {\n    return;\n  }\n\n  requestAnimationFrame(() => {\n    for (const labelable of unlabeledComponents) {\n      if (labelable.el === forComponentEl) {\n        connectLabel(labelable);\n        break;\n      }\n    }\n  });\n}\n"],"names":["componentsWithInputEvent","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","clearFormValidation","status","validationIcon","validationMessage","displayValidationMessage","event","_formComponent$nodeNa","hiddenInput","target","formComponent","parentElement","componentTag","nodeName","toLowerCase","componentTagParts","split","length","preventDefault","setInvalidFormValidation","message","clearValidationEvent","getClearValidationEventName","componentTagCamelCase","map","part","index","concat","toUpperCase","slice","join","includes","addEventListener","once","submitForm","formEl","requestSubmit","removeEventListener","requestAnimationFrame","invalidEls","querySelectorAll","el","setFocus","resetForm","_component$formEl","reset","connectForm","value","associatedForm","findAssociatedForm","hasRegisteredFormComponentParent","form","formComponentEl","closestElementCrossShadowBoundary","formComponentRegisterEventName","composedPath","some","element","has","stopPropagation","dispatchEvent","CustomEvent","bubbles","composed","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","id","this","disconnectForm","get","delete","internalHiddenInputInputEvent","hiddenInputInputHandler","removeHiddenInputChangeEventListener","input","defaultSyncHiddenFormInput","_component$syncHidden","disabled","name","required","tabIndex","setAttribute","removeAttribute","syncHiddenFormInput","call","HiddenFormInputSlot","_ref","ownerDocument","inputs","forEach","remove","values","Array","isArray","extra","seen","Set","docFrag","valueMatch","find","val","push","pop","createElement","slot","createDocumentFragment","append","h","isFirefox","test","getUserAgentString","Build","isBrowser","uaData","getUserAgentData","navigator","userAgentData","brands","brand","version","userAgent","disabledElementToParent","interceptedClick","HTMLElement","prototype","click","onPointerDown","interactiveElement","nonBubblingWhenDisabledMouseEvents","onNonBubblingWhenDisabledMouseEvent","stopImmediatePropagation","captureOnlyOptions","capture","updateHostInteraction","contains","document","activeElement","blur","blockInteraction","restoreInteraction","currentParent","getParentElement","trackedParent","removeInteractionListeners","addInteractionListeners","connectInteractive","disconnectInteractive","CSS","container","InteractiveContainer","_ref2","children","class","inert","labelClickEvent","labelConnectedEvent","labelDisconnectedEvent","labelTagName","labelToLabelables","onLabelClickMap","onLabelConnectedMap","onLabelDisconnectedMap","unlabeledComponents","findLabelForComponent","componentEl","forLabel","selector","parentLabel","hasAncestorCustomElements","label","traversedElements","customElementAncestorCheckEventType","listener","indexOf","ancestorCustomElements","filter","_el$tagName","tagName","connectLabel","labelEl","boundOnLabelDisconnected","onLabelDisconnected","labelables","sort","sortByDOMOrder","onLabelClick","disconnectLabel","labelable","a","b","isBefore","getLabelText","_component$labelEl","textContent","trim","labelClickTarget","detail","sourceEvent","clickedLabelable","firstLabelable","onLabelConnected","boundOnLabelConnected","async","associateExplicitLabelToUnlabeledComponent","_label$ownerDocument","componentOnReady","forComponentEl","getElementById","for"],"sourceRoot":""}