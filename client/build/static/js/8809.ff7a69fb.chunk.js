"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[8809],{90301:(S,I,k)=>{k.d(I,{y:()=>i});const E=new(k(69742).A);function i(S){if(null==S)return["",!1];if(!E.hasBidiChar(S))return[S,!1];let I;return I="rtl"===E.checkContextual(S)?"IDNNN":"ICNNN",[E.bidiTransform(S,I,"VLYSN"),!0]}},77480:(S,I,k)=>{k.d(I,{Al:()=>c,NZ:()=>i,Vb:()=>G,af:()=>u,rK:()=>f});var E=k(61272);const G="arial-unicode-ms",F="woff2",N=new Map,D=new Set;class o{constructor(S,I){this.fontFace=S,this.promise=I}}async function c(S){const I=f(S),k=N.get(I);if(k)return k.promise;const G=new FontFace(S.family,"url('".concat(E.A.fontsUrl,"/woff2/").concat(I,".").concat(F,"') format('").concat(F,"')"),{style:S.style,weight:S.weight}),X=document.fonts;if(X.has(G)&&"loading"===G.status)return G.loaded;const et=G.load().then((()=>(X.add(G),G)));return N.set(I,new o(G,et)),D.add(G),et}function i(S){return D.has(S)}function u(S){if(!S)return G;const I=S.toLowerCase().split(" ").join("-");switch(I){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return I}}function f(S){const I=function l(S){if(!S.weight)return"";switch(S.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}(S)+function d(S){if(!S.style)return"";switch(S.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}(S);return u(S.family)+(I.length>0?I:"-regular")}},33303:(S,I,k)=>{k.d(I,{z:()=>a});var E=k(66004),G=k(46164),F=k(31670),N=k(41156);class a{static fromOptimized(S,I){let k=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;return(new p).initialize(S,I,k,E,G)}static fromJSON(S){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const[E,G]=u(S);return(new d).initialize(E,G,I,k,1)}static fromOptimizedCIM(S,I){let k=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;return(new m).initialize(S,I,k,E,G)}static fromJSONCIM(S){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const[G,F]=u(S);return(new y).initialize(G,F,I,k,E)}static fromFeatureSetReader(S){const I=S.readGeometryForDisplay(),k=S.geometryType;return I&&k?this.fromOptimized(I,k):null}static fromFeatureSetReaderCIM(S){const I=S.readGeometryForDisplay(),k=S.geometryType;return I&&k?this.fromOptimizedCIM(I,k):null}static createEmptyOptimized(S){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return(new p).initialize(new N.A,S,I,k,E)}static createEmptyJSON(S){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return(new d).initialize([],S,I,k,1)}static createEmptyOptimizedCIM(S){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return(new m).initialize(new N.A,S,I,k,E)}static createEmptyJSONCIM(S){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2],E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return(new y).initialize([],S,I,k,E)}asJSON(){const S=(0,G.x)(this);return"esriGeometryEnvelope"===this.geometryType?{xmin:S[0][0][0],ymin:S[0][0][1],xmax:S[0][2][0],ymax:S[0][2][1]}:"esriGeometryMultipoint"===this.geometryType?{points:S.flat()}:"esriGeometryPoint"===this.geometryType?{x:S[0][0][0],y:S[0][0][1]}:"esriGeometryPolygon"===this.geometryType?{rings:S}:{paths:S}}getCurrentRingArea(){if(this.pathSize<3)return 0;let S,I,k=0;if(this.seekPathStart(),!this.nextPoint())return 0;S=this.x,I=this.y;const E=S,G=I;for(;this.nextPoint();)k+=(S-this.x)*(I+this.y),S=this.x,I=this.y;return k+=(S-E)*(I+G),-.5*k}invertY(){this.yFactor*=-1}}class p extends a{constructor(){super(...arguments),this._end=-1}initialize(S,I,k,E,G){return this.hasZ=k,this.hasM=E,this.geometryType=I,this._stride=2+Number(k)+Number(E),this._geometry=S,this._pathIndex=-1,this._pathOffset=0,this._pointOffset=-this._stride,this._end=-1,this.yFactor=G,this}reset(){this.initialize(this._geometry,this.geometryType,this.hasZ,this.hasM,this.yFactor)}seekPath(S){if(S>=0&&S<this.totalSize){if(this._pathIndex<S)for(;this._pathIndex<S&&this.nextPath(););else if(this._pathIndex>S)for(;this._pathIndex>S&&this.prevPath(););return!0}return!1}seekPathStart(){this._pointOffset=this._pathOffset-this._stride}seekPathEnd(){this._pointOffset=this._end}seekInPath(S){const I=this._pathOffset+S*this._stride;return I>=0&&I<this._end&&(this._pointOffset=I,!0)}nextPoint(){return(this._pointOffset+=this._stride)<this._end}prevPoint(){return(this._pointOffset-=this._stride)>=this._pathOffset}nextPath(){return!(this.pathIndex>=this.totalSize-1)&&(this._pathIndex>=0&&(this._pathOffset+=this._stride*this.pathSize),this._pathIndex++,this._pointOffset=this._pathOffset-this._stride,this._end=this._pointOffset+this._stride+this._stride*this.pathSize,!0)}prevPath(){return!(this.pathIndex<=0)&&(this._pathIndex--,this._end=this._pathOffset,this._pathOffset-=this._stride*this.pathSize,this._pointOffset=this._pathOffset-this._stride,!0)}pathLength(){const S=this._end,I=this._stride,k=this._geometry.coords;let E=0;for(let G=this._pathOffset+I;G<S;G+=I){const S=k[G-I],F=k[G-I+1],N=k[G]-S,D=k[G+1]-F;E+=Math.sqrt(N*N+D*D)}return E}startPath(){this._geometry.lengths.push(0)}pushPath(S){this.startPath(),this.pushPoints(S)}pushPoint(S){for(let I=0;I<this._stride;++I)this._geometry.coords.push(S[I]);this._geometry.lengths[this.totalSize-1]++}pushXY(S,I){this._geometry.coords.push(S,I),this._geometry.lengths[this.totalSize-1]++}pushPoints(S){for(const I of S)for(let S=0;S<this._stride;++S)this._geometry.coords.push(I[S]);this._geometry.lengths[this.totalSize-1]+=S.length}pushCursor(S){const I=S.asOptimized();this._geometry.coords.push(...I.coords),this._geometry.lengths.push(...I.lengths)}asOptimized(){const S=this._geometry.clone();if(1!==this.yFactor)for(let I=1;I<S.coords.length;I+=this._stride)S.coords[I]*=this.yFactor;return"esriGeometryPoint"===this.geometryType&&(S.lengths.length=0),S}isClosed(){const S=this._geometry.coords,I=this._pathOffset,k=this._end-this._stride;for(let E=0;E<this._stride;E++)if(S[I+E]!==S[k+E])return!1;return!0}clone(){return(new p).initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._geometry.isPoint?1:this._geometry.lengths.reduce(((S,I)=>S+I))}get pathSize(){const{lengths:S}=this._geometry;return this._pathIndex<0||this._pathIndex>S.length-1?0:this._geometry.isPoint?1:S[this._pathIndex]}get totalSize(){return this._geometry.lengths.length}get x(){return this._geometry.coords[this._pointOffset]}set x(S){this._geometry.coords[this._pointOffset]=S}get y(){return this.yFactor*this._geometry.coords[this._pointOffset+1]}set y(S){this._geometry.coords[this._pointOffset+1]=this.yFactor*S}get z(){return this._geometry.coords[this._pointOffset+2]}set z(S){this._geometry.coords[this._pointOffset+2]=S}get m(){const S=this.hasZ?3:2;return this._geometry.coords[this._pointOffset+S]}set m(S){this._geometry.coords[this._pointOffset+3]=S}get pathIndex(){return this._pathIndex}get _coordIndex(){return this._pointOffset/this._stride}}function _(S){const I=[S.x,S.y];return S.z&&I.push(S.z),S.m&&I.push(S.m),I}function u(S){return(0,F.Bi)(S)?[S.rings,"esriGeometryPolygon"]:(0,F.Rg)(S)?[S.paths,"esriGeometryPolyline"]:(0,F.U9)(S)?[[S.points],"esriGeometryMultipoint"]:(0,F.ZC)(S)?[[[[S.xmin,S.ymin],[S.xmin,S.ymax],[S.xmax,S.ymax],[S.xmax,S.ymin],[S.xmin,S.ymin]]],"esriGeometryEnvelope"]:(0,F.fT)(S)?[[[_(S)]],"esriGeometryPoint"]:[[],"esriGeometryPolyline"]}class d extends a{initialize(S,I,k,E,G){return this._paths=S,this.geometryType=I,this.hasZ=k,this.hasM=E,this._pathIndex=this._pointIndex=-1,this.yFactor=G,this._mIndex=this.hasZ?3:2,this}reset(){this._pathIndex=this._pointIndex=-1}seekPath(S){return this._pathIndex=S,this._pointIndex=-1,S>=0&&S<this.totalSize&&(this._currentPath=this._paths[S],!0)}seekPathStart(){this._pointIndex=-1}seekPathEnd(){this._pointIndex=this._currentPath.length}seekInPath(S){return S>=0&&S<this._currentPath.length&&(this._pointIndex=S,this._currentPoint=this._currentPath[this._pointIndex],!0)}nextPoint(){return this._currentPoint=this._currentPath[++this._pointIndex],this._pointIndex<this._currentPath.length}prevPoint(){return this._currentPoint=this._currentPath[--this._pointIndex],this._pointIndex>=0}nextPath(){return this._pointIndex=-1,this._currentPath=this._paths[++this._pathIndex],this._pathIndex<this.totalSize}prevPath(){return this.pathIndex>0&&(this._pointIndex=-1,this._pathIndex--,this._currentPath=this._paths[this._pathIndex],!0)}pathLength(){const S=this._currentPath.length,I=this._currentPath;let k=0;for(let E=1;E<S;E++){const S=I[E-1],G=I[E],F=S[0],N=S[1],D=G[0]-F,X=G[1]-N;k+=Math.sqrt(D*D+X*X)}return k}startPath(){this._paths.push([])}pushPath(S){this._paths.push(S)}pushPoint(S){this._paths[this.totalSize-1].push(S)}pushXY(S,I){this._paths[this.totalSize-1].push([S,I])}pushPoints(S){this._paths[this.totalSize-1].push(...S)}pushCursor(S){const I=(0,G.x)(S);for(const k of I)this.pushPath(k)}asOptimized(){const S=new N.A;if("esriGeometryPoint"===this.geometryType)S.coords.push(...this._paths[0][0]),S.lengths.length=0;else for(const I of this._paths){for(const k of I)S.coords.push(k[0]),S.coords.push(k[1]*this.yFactor),this.hasZ&&S.coords.push(k[2]),this.hasM&&S.coords.push(k[this._mIndex]);S.lengths.push(I.length)}return S}isClosed(){const S=this._currentPath[0],I=this._currentPath[this._currentPath.length-1];for(let k=0;k<S.length;k++)if(S[k]!==I[k])return!1;return!0}clone(){return(new d).initialize((0,E.o8)(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._paths.map((S=>S.length)).reduce(((S,I)=>S+I))}get pathSize(){return this._pathIndex<0||this._pathIndex>this.totalSize-1?-1:this._paths[this._pathIndex].length}get totalSize(){return this._paths.length}get x(){return this._currentPoint[0]}set x(S){this._currentPoint[0]=S}get y(){return this.yFactor*this._currentPoint[1]}set y(S){this._currentPoint[1]=this.yFactor*S}get z(){return this._currentPoint[2]}set z(S){this._currentPoint[2]=S}get m(){return this._currentPoint[this._mIndex]}set m(S){this._currentPoint[this._mIndex]=S}get pathIndex(){return this._pathIndex}}class m extends p{initialize(S,I,k,E,G){return super.initialize(S,I,k,E,G),this._controlPoints||(this._controlPoints=this._controlPoints=new Array(this.totalSize).fill(void 0).map((S=>new Set))),this}startPath(){super.startPath(),this._controlPoints.push(new Set)}clone(){const S=(new m).initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor);return S._controlPoints=this._controlPoints,S}setControlPoint(){this._controlPoints[this.pathIndex].add(this._coordIndex)}getControlPoint(){return this._controlPoints[this.pathIndex].has(this._coordIndex)}setControlPointAt(S){this._controlPoints[this.pathIndex].add(S)}getControlPointAt(S){return this._controlPoints[this.pathIndex].has(S)}}class y extends d{initialize(S,I,k,E,G){return super.initialize(S,I,k,E,G)}clone(){return(new y).initialize((0,E.o8)(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}setControlPoint(){this._paths[this.pathIndex][this._pointIndex][4]=1}getControlPoint(){return 1===this._paths[this.pathIndex][this._pointIndex][4]}setControlPointAt(S){this._paths[this.pathIndex][S][4]=1}getControlPointAt(S){return 1===this._paths[this.pathIndex][S][4]}}},61693:(S,I,k)=>{k.d(I,{d:()=>l});var E=k(88965),G=k(12439),F=k(61077),N=k(78966),D=k(5522);const X=222045e-19;function l(S){if(0===S.totalSize)return null;const I=(0,G.z8)(S);if(!I)return null;const k=4*(Math.abs(I[0])+Math.abs(I[2])+Math.abs(I[1])+Math.abs(I[3])+1)*X;let N=0,D=0;S.reset();for(let E=0;S.nextPath();E++){const I=S.getCurrentRingArea();I>D&&(D=I,N=E)}if(S.seekPath(N),0===S.pathSize)return null;S.seekPathStart();const et=(0,G.B$)(S);if(Math.abs(D)<=2*k*k)return[(et[0]+et[2])/2,(et[1]+et[3])/2];S.seekPathStart();const st=(0,F.w2)(S,(0,E.vt)());if(null===st)return null;if(S.totalPoints<4)return st;const it=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],nt=[NaN,NaN,NaN,NaN],ot=[NaN,NaN,NaN,NaN];let at=!1,ht=f(st,S,!0);0===ht.distance&&(at=!0,it[0][0]=st[0],it[0][1]=st[1],ht=f(st,S,!1)),nt[0]=ht.distance,ot[0]=0;const lt=[NaN,NaN];let ct=!1,ut=.25,_t=-1,ft=NaN;do{if(ft=NaN,it[1]=h(S,w(et[0],et[2],ut),k,I),isNaN(it[1][0])||isNaN(it[1][1])||(ht=f(it[1],S,!1),ft=ht.distance),!isNaN(ft)&&ft>k&&u(it[1],S))ct=!0,nt[1]=ft,ot[1]=p(it[1],st);else if(!isNaN(ft)&&ft>_t&&(_t=ft,lt[0]=it[1][0],lt[1]=it[1][1]),ut-=.01,ut<.1){if(!(_t>=0))break;ct=!0,nt[1]=_t,it[1][0]=lt[0],it[1][1]=lt[1],ot[1]=p(it[1],st)}}while(!ct);ct=!1,ut=.5,_t=-1;let dt=.01,pt=1;do{if(ft=NaN,it[2]=h(S,w(et[0],et[2],ut),k,I),isNaN(it[2][0])||isNaN(it[2][1])||(ht=f(it[2],S,!1),ft=ht.distance),!isNaN(ft)&&ft>k&&u(it[2],S))ct=!0,nt[2]=ft,ot[2]=p(it[2],st);else if(!isNaN(ft)&&ft>_t)_t=ft,lt[0]=it[2][0],lt[1]=it[2][1];else if(ft>_t&&(_t=ft,lt[0]=it[2][0],lt[1]=it[2][1]),ut=.5+dt*pt,dt+=.01,pt*=-1,ut<.3||ut>.7){if(!(_t>=0))break;ct=!0,nt[2]=_t,it[2][0]=lt[0],it[2][1]=lt[1],ot[2]=p(it[2],st)}}while(!ct);ct=!1,ut=.75,_t=-1;do{if(ft=NaN,it[3]=h(S,w(et[0],et[2],ut),k,I),isNaN(it[3][0])||isNaN(it[3][1])||(ht=f(it[3],S,!1),ft=ht.distance),!isNaN(ft)&&ft>k&&u(it[3],S))ct=!0,nt[3]=ft,ot[3]=p(it[3],st);else if(ft>_t&&(_t=ft,lt[0]=it[3][0],lt[1]=it[3][1]),ut+=.01,ut>.9){if(!(_t>=0))break;ct=!0,nt[3]=_t,it[3][0]=lt[0],it[3][1]=lt[1],ot[3]=p(it[3],st)}}while(!ct);const mt=[0,1,2,3],gt=at?0:1;let yt;for(let E=gt;E<4;E++)for(let S=gt;S<3;S++){const I=ot[S],k=ot[S+1];C(I,k)>0&&(yt=mt[S],mt[S]=mt[S+1],mt[S+1]=yt,ot[S]=k,ot[S+1]=I)}let Pt=gt,xt=0,Mt=0;for(let E=gt;E<4;E++){switch(E){case 0:Mt=2*nt[mt[E]];break;case 1:Mt=1.66666666*nt[mt[E]];break;case 2:Mt=1.33333333*nt[mt[E]];break;case 3:Mt=nt[mt[E]]}Mt>xt&&(xt=Mt,Pt=mt[E])}return it[Pt]}function u(S,I){let k,E,G,F,N=0;for(I.reset();I.nextPath()&&I.nextPoint();)for(k=I.x,E=I.y;I.nextPoint();k=G,E=F)G=I.x,F=I.y,E>S[1]!=F>S[1]&&((G-k)*(S[1]-E)-(F-E)*(S[0]-k)>0?N++:N--);return 0!==N}function f(S,I,k){if(k&&u(S,I))return{coord:S,distance:0};let E=1/0,G=0,F=0,D=[0,0],X=[0,0];const et=[0,0];for(I.reset();I.nextPath()&&I.nextPoint();)if(!(I.pathSize<2))for(D[0]=I.x,D[1]=I.y;I.nextPoint();D=X){X=[I.x,I.y],(0,N.gR)(et,S,D,X);const k=p(S,et);k<E&&(E=k,G=et[0],F=et[1])}return{coord:[G,F],distance:Math.sqrt(E)}}function h(S,I,k,G){const F=[I,0];let N=1/0,X=1/0,et=!1,st=!1;const it=[[I,G[1]-1],[I,G[3]+1]],nt=[0,0],ot=[0,0],at=[0,0],ht=[[0,0],[0,0]],lt=(0,E.vt)();for(S.reset();S.nextPath()&&S.nextPoint();)if(!(S.pathSize<2))for(ht[0][0]=S.x,ht[0][1]=S.y;S.nextPoint();ht[0][0]=ht[1][0],ht[0][1]=ht[1][1]){if(ht[1][0]=S.x,ht[1][1]=S.y,null===x(lt,ht))continue;if(ot[0]=it[0][0],ot[1]=it[0][1],at[0]=it[1][0],at[1]=it[1][1],0===M(lt,ot,at))continue;if(!(0,D.Ql)(it[0],it[1],ht[0],ht[1],nt))continue;const I=nt[1];N>X?I<N&&(N=I,et=!0):I<X&&(X=I,st=!0)}return et&&st?F[1]=(N+X)/2:F[0]=F[1]=NaN,F}function x(S,I){if(I.length<2)return null;S||(S=(0,E.vt)());const[k,G]=I[0],[F,N]=I[1];return S[0]=Math.min(k,F),S[1]=Math.min(G,N),S[2]=Math.max(k,F),S[3]=Math.max(G,N),S}const et=1,st=4,it=3,nt=12;function M(S,I,k){let E=b(I,S),G=b(k,S);const F=S[0],N=S[1],D=S[2],X=S[3];if(E&G)return 0;if(!(E|G))return 4;const ot=(E?1:0)|(G?2:0);do{const ot=k[0]-I[0],at=k[1]-I[1];if(ot>at)E&it?(E&et?(I[1]+=at*(F-I[0])/ot,I[0]=F):(I[1]+=at*(D-I[0])/ot,I[0]=D),E=b(I,S)):G&it?(G&et?(k[1]+=at*(F-k[0])/ot,k[0]=F):(k[1]+=at*(D-k[0])/ot,k[0]=D),G=b(k,S)):E?(E&st?(I[0]+=ot*(N-I[1])/at,I[1]=N):(I[0]+=ot*(X-I[1])/at,I[1]=X),E=b(I,S)):(G&st?(k[0]+=ot*(N-k[1])/at,k[1]=N):(k[0]+=ot*(X-k[1])/at,k[1]=X),G=b(k,S));else if(E&nt?(E&st?(I[0]+=ot*(N-I[1])/at,I[1]=N):(I[0]+=ot*(X-I[1])/at,I[1]=X),E=b(I,S)):G&nt?(G&st?(k[0]+=ot*(N-k[1])/at,k[1]=N):(k[0]+=ot*(X-k[1])/at,k[1]=X),G=b(k,S)):E?(E&et?(I[1]+=at*(F-I[0])/ot,I[0]=F):(I[1]+=at*(D-I[0])/ot,I[0]=D),E=b(I,S)):(G&et?(k[1]+=at*(F-k[0])/ot,k[0]=F):(k[1]+=at*(D-k[0])/ot,k[0]=D),G=b(k,S)),E&G)return 0}while(E|G);return ot}function b(S,I){return(S[0]<I[0]?1:0)|(S[0]>I[2]?1:0)<<1|(S[1]<I[1]?1:0)<<2|(S[1]>I[3]?1:0)<<3}function w(S,I,k){return S+(I-S)*k}function p(S,I){return(S[0]-I[0])*(S[0]-I[0])+(S[1]-I[1])*(S[1]-I[1])}function C(S,I){if(S<I)return-1;if(S>I)return 1;if(S===I)return 0;const k=isNaN(S),E=isNaN(I);return k<E?-1:k>E?1:0}},47463:(S,I,k)=>{k.d(I,{Aq:()=>r,pC:()=>s,rx:()=>i});var E=k(10717);function r(S,I){S[4]=I}class s{constructor(S){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],k=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.isClosed=!1,this.geometryCursor=null,this.geometryCursor=!I&&"esriGeometryPolygon"===S.geometryType||!k&&"esriGeometryPolyline"===S.geometryType?null:S,this.geomUnitsPerPoint=G,this.iteratePath=!1,this.internalPlacement=new E.W}next(){if(!this.geometryCursor)return null;for(;this.iteratePath||this.geometryCursor.pathIndex<this.geometryCursor.totalSize-1;){this.iteratePath||this.geometryCursor.nextPath();const S=this.processPath(this.geometryCursor);if(S)return S}return this.geometryCursor=null,null}}class i{constructor(S,I,k){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.isClosed=!1,this.inputGeometries=S,this.acceptPolygon=I,this.acceptPolyline=k,this.geomUnitsPerPoint=E,this.iteratePath=!1,this.multiPathCursor=null}next(){for(;;){if(!this.multiPathCursor){let S=this.inputGeometries.next();for(;S&&(this.isClosed=this.acceptPolygon&&"esriGeometryPolygon"===S.geometryType||"esriGeometryEnvelope"===S.geometryType,this.multiPathCursor=S,!this.multiPathCursor);)S=this.inputGeometries.next();if(!this.multiPathCursor)return null}for(;this.iteratePath||this.multiPathCursor.nextPath();){this.multiPathCursor.seekPathStart();const S=this.processPath(this.multiPathCursor);if(S)return S}this.multiPathCursor=null}}}},73619:(S,I,k)=>{k.d(I,{k:()=>s,q:()=>i});var E=k(33303),G=k(5144);const F=512;let N;class s{constructor(S){this._geometry=S}next(){const S=this._geometry;return this._geometry=null,S}}function i(S,I){N||(N=new G.O3(0,0,0,1));const k="esriGeometryPolygon"===S.geometryType,D=k?G.dC.Polygon:G.dC.LineString,X=k?3:2;let et,st;for(N.reset(D),N.setPixelMargin(I+1),N.setExtent(F);S.nextPath();)if(!(S.pathSize<X)){for(S.nextPoint(),et=S.x,st=-S.y,N.moveTo(et,st);S.nextPoint();)et=S.x,st=-S.y,N.lineTo(et,st);k&&N.close()}const it=N.result(!1);if(it){const I=E.z.createEmptyOptimizedCIM(S.geometryType);for(const S of it){I.startPath();for(const k of S)I.pushXY(k.x,-k.y)}return I.reset(),I}return null}},60072:(S,I,k)=>{k.d(I,{A:()=>A,c:()=>g});var E=k(20665),G=k(77045),F=k(18356),N=k(5139),D=k(58860),X=k(870),et=k(9760),st=k(57516),it=k(70335),nt=k(17985),ot=k(76506),at=k(53185),ht=k(99054),lt=k(97887),ct=k(54574),ut=k(36654),_t=k(85272),ft=k(75184),dt=k(11931),pt=k(67382),mt=k(11257);function A(S){if(!S)return null;switch(S.type){case"CIMGeometricEffectAddControlPoints":return E.N.local();case"CIMGeometricEffectArrow":return G.B.local();case"CIMGeometricEffectBuffer":return F.s.local();case"CIMGeometricEffectControlMeasureLine":return N.v.local();case"CIMGeometricEffectCut":return D.y.local();case"CIMGeometricEffectDashes":return X.I.local();case"CIMGeometricEffectDonut":return et.O.local();case"CIMGeometricEffectJog":return st.U.local();case"CIMGeometricEffectMove":return it.V.local();case"CIMGeometricEffectOffset":return nt.V.local();case"CIMGeometricEffectReverse":return ot.C.local();case"CIMGeometricEffectRotate":return at.v.local();case"CIMGeometricEffectScale":return ht.W.local();case"CIMGeometricEffectWave":return lt.l.local()}return null}function g(S){if(!S)return null;switch(S.type){case"CIMMarkerPlacementAlongLineSameSize":return ct.e.local();case"CIMMarkerPlacementAtExtremities":return ut.y.local();case"CIMMarkerPlacementAtRatioPositions":return _t.S.local();case"CIMMarkerPlacementInsidePolygon":return ft.M.local();case"CIMMarkerPlacementOnLine":return dt.R.local();case"CIMMarkerPlacementOnVertices":return pt.A.local();case"CIMMarkerPlacementPolygonCenter":return mt.L.local()}return null}},10717:(S,I,k)=>{k.d(I,{W:()=>t});class t{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rzCos&&0!==this.rzSin)&&(this.rz=Math.atan2(this.rzSin,this.rzCos)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rzCos=1,this.rzSin=0}setTranslate(S,I){this.tx=S,this.ty=I}setTranslateZ(S){this.tz=S}setRotateCS(S,I){this.rz=void 0,this.rzCos=S,this.rzSin=I}setRotate(S){this.rz=S,this.rzCos=void 0,this.rzSin=void 0}setRotateY(S){this.ry=S}setScale(S){this.s=S}setMeasure(S){this.m=S}}},80887:(S,I,k)=>{k.d(I,{Rj:()=>K,mx:()=>Y,CK:()=>W,IT:()=>V,QF:()=>$});var E=k(77480),G=k(50886),F=k(66004),N=k(89412),D=k(83157),X=k(62555),et=k(33303),st=k(88965),it=k(12439),nt=k(61077),ot=k(31670),at=k(73619);class CIMImageColorSubstitutionHelper_t{applyColorSubstituition(S,I){if(!I)return S;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:k,height:E}=S,G=this._rasterizationCanvas,F=G.getContext("2d",{willReadFrequently:!0});S!==G&&(G.width=k,G.height=E,F.drawImage(S,0,0,k,E));const N=F.getImageData(0,0,k,E).data;if(I)for(const X of I)if(X&&X.oldColor&&4===X.oldColor.length&&X.newColor&&4===X.newColor.length){const[S,I,k,E]=X.oldColor,[G,F,D,et]=X.newColor;if(S===G&&I===F&&k===D&&E===et)continue;for(let X=0;X<N.length;X+=4)S===N[X]&&I===N[X+1]&&k===N[X+2]&&E===N[X+3]&&(N[X]=G,N[X+1]=F,N[X+2]=D,N[X+3]=et)}const D=new ImageData(N,k,E);return F.putImageData(D,0,0),G}tintImageData(S,I){if(!I||I.length<4)return S;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:k,height:E}=S,G=this._rasterizationCanvas,F=G.getContext("2d",{willReadFrequently:!0});S!==G&&(G.width=k,G.height=E,F.drawImage(S,0,0,k,E));const N=F.getImageData(0,0,k,E),D=new Uint8Array(N.data),X=[I[0]/255,I[1]/255,I[2]/255,I[3]/255];for(let st=0;st<D.length;st+=4)D[st]*=X[0],D[st+1]*=X[1],D[st+2]*=X[2],D[st+3]*=X[3];const et=new ImageData(new Uint8ClampedArray(D.buffer),k,E);return F.putImageData(et,0,0),G}}var ht=k(60072),lt=k(10717),ct=k(29354),ut=k(64032);function imageUtils_t(S){const I=S.getFrame(0);if(I instanceof HTMLImageElement||I instanceof HTMLCanvasElement)return I;const k=document.createElement("canvas");k.width=S.width,k.height=S.height;const E=k.getContext("2d");return I instanceof ImageData?E.putImageData(I,0,0):E.drawImage(I,0,0),k}var _t=k(29470),ft=k(90086);function s(S){return"rgba(".concat(S.slice(0,3).toString(),",").concat(S[3],")")}class TextRasterizer_r{constructor(S){S&&(this._textRasterizationCanvas=S)}rasterizeText(S,I){var k;this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const E=this._textRasterizationCanvas,G=E.getContext("2d",{willReadFrequently:!0});this._setFontProperties(G,I),this._parameters=I,this._textLines=S.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const{decoration:F,weight:N}=I.font;this._lineThroughWidthOffset=F&&"line-through"===F?.1*this._lineHeight:0;const D=null!=I.backgroundColor||null!=I.borderLine,et=D?ft.y7:0,st=this._computeTextWidth(G,I)+2*et,it=this._lineHeight*this._textLines.length+2*et;if(E.width=st+2*this._lineThroughWidthOffset,E.height=it,0===E.width||0===E.height)return E.width=E.height=1,{size:[0,0],image:new Uint32Array(0),sdf:!1,simplePattern:!1,anchorX:0,anchorY:0,canvas:E};this._renderedLineHeight=Math.round(this._lineHeight*I.pixelRatio),this._renderedHaloSize=(0,X.Lz)(I.halo.size)*I.pixelRatio,this._renderedWidth=st*I.pixelRatio,this._renderedHeight=it*I.pixelRatio,this._lineThroughWidthOffset*=I.pixelRatio;const nt=null!==(k=I.color)&&void 0!==k?k:[0,0,0,0],ot=I.halo&&I.halo.color?I.halo.color:[0,0,0,0];this._fillStyle=s(nt),this._haloStyle=function i(S){return"rgb(".concat(S.slice(0,3).toString(),")")}(ot);const at=this._renderedLineHeight,ht=this._renderedHaloSize;G.save(),G.clearRect(0,0,E.width,E.height),this._setFontProperties(G,I);const lt=et*I.pixelRatio,ct=function n(S,I){return"center"===S?.5*I:"right"===S?I:0}(G.textAlign,this._renderedWidth-2*lt)+ht+lt,ut=ht+lt,_t=ht>0;let dt=this._lineThroughWidthOffset,pt=0;if(D){var mt,gt,yt,Pt,xt;G.save();const S=null!==(mt=I.backgroundColor)&&void 0!==mt?mt:[0,0,0,0],k=null!==(gt=null===(yt=I.borderLine)||void 0===yt?void 0:yt.color)&&void 0!==gt?gt:[0,0,0,0],F=2*(0,X.Lz)(null!==(Pt=null===(xt=I.borderLine)||void 0===xt?void 0:xt.size)&&void 0!==Pt?Pt:0);G.fillStyle=s(S),G.strokeStyle=s(k),G.lineWidth=F,G.fillRect(0,0,E.width,E.height),G.strokeRect(0,0,E.width,E.height),G.restore()}_t&&this._renderHalo(G,ct,ut,dt,pt,I),pt+=ut,dt+=ct;for(const X of this._textLines)_t?(G.globalCompositeOperation="destination-out",G.fillStyle="rgb(0, 0, 0)",G.fillText(X,dt,pt),G.globalCompositeOperation="source-over",G.fillStyle=this._fillStyle,G.fillText(X,dt,pt)):(G.fillStyle=this._fillStyle,G.fillText(X,dt,pt)),F&&"none"!==F&&this._renderDecoration(G,dt,pt,F,N),pt+=at;G.restore();const Mt=this._renderedWidth+2*this._lineThroughWidthOffset,bt=this._renderedHeight,St=G.getImageData(0,0,Mt,bt),Ct=new Uint8Array(St.data);if(I.premultiplyColors){let S;for(let I=0;I<Ct.length;I+=4)S=Ct[I+3]/255,Ct[I]=Ct[I]*S,Ct[I+1]=Ct[I+1]*S,Ct[I+2]=Ct[I+2]*S}let wt,vt;switch(I.horizontalAlignment){case"left":wt=-.5;break;case"right":wt=.5;break;default:wt=0}switch(I.verticalAlignment){case"bottom":vt=-.5;break;case"top":vt=.5;break;case"baseline":vt=-1/6;break;default:vt=0}return{size:[Mt,bt],image:new Uint32Array(Ct.buffer),sdf:!1,simplePattern:!1,anchorX:wt,anchorY:vt,canvas:E}}_renderHalo(S,I,k,E,G,F){const N=this._renderedWidth,D=this._renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=N,this._haloRasterizationCanvas.height=D;const X=this._haloRasterizationCanvas,et=X.getContext("2d");et.clearRect(0,0,N,D),this._setFontProperties(et,F);const{decoration:st,weight:it}=F.font;et.fillStyle=this._haloStyle,et.strokeStyle=this._haloStyle,et.lineJoin="round",this._renderHaloNative(et,I,k,st,it),S.globalAlpha=this._parameters.halo.color[3],S.drawImage(X,0,0,N,D,E,G,N,D),S.globalAlpha=1}_renderHaloNative(S,I,k,E,G){const F=this._renderedLineHeight,N=this._renderedHaloSize;for(const D of this._textLines){const X=2*N,et=5,st=.1;for(let F=0;F<et;F++){const N=(1-(et-1)*st+F*st)*X;S.lineWidth=N,S.strokeText(D,I,k),E&&"none"!==E&&this._renderDecoration(S,I,k,E,G,N)}k+=F}}_setFontProperties(S,I){const k=Math.max(I.size,.5),E=I.font,G="".concat(E.style," ").concat(E.weight," ").concat((0,X.Lz)(k*I.pixelRatio).toFixed(1),"px ").concat(E.family,", sans-serif");let F;switch(S.font=G,S.textBaseline="top",I.horizontalAlignment){case"left":default:F="left";break;case"right":F="right";break;case"center":F="center"}S.textAlign=F}computeTextSize(S,I){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const k=this._textRasterizationCanvas,E=k.getContext("2d");this._setFontProperties(E,I),this._parameters=I,this._textLines=S.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const G=this._computeTextWidth(E,I),F=this._lineHeight*this._textLines.length;return k.width=G,k.height=F,[G*I.pixelRatio,F*I.pixelRatio]}_computeTextWidth(S,I){let k=0;for(const G of this._textLines)k=Math.max(k,S.measureText(G).width);const E=I.font;return("italic"===E.style||"oblique"===E.style||"string"==typeof E.weight&&("bold"===E.weight||"bolder"===E.weight)||"number"==typeof E.weight&&E.weight>600)&&(k+=.3*S.measureText("w").width),k+=2*(0,X.Lz)(this._parameters.halo.size),Math.round(k)}_computeLineHeight(){let S=1.275*this._parameters.size;const I=this._parameters.font.decoration;return I&&"underline"===I&&(S*=1.3),Math.round(S+2*(0,X.Lz)(this._parameters.halo.size))}_renderDecoration(S,I,k,E,G,F){const N=.9*this._lineHeight,D="bold"===G?.06:"bolder"===G?.09:.04;switch(S.textAlign){case"center":I-=this._renderedWidth/2;break;case"right":I-=this._renderedWidth}const X=S.textBaseline;if("underline"===E)switch(X){case"top":k+=N;break;case"middle":k+=N/2}else if("line-through"===E)switch(X){case"top":k+=N/1.5;break;case"middle":k+=N/3}const et=F?1.5*F:Math.ceil(N*D);S.save(),S.beginPath(),S.strokeStyle=S.fillStyle,S.lineWidth=et,S.moveTo(I-this._lineThroughWidthOffset,k),S.lineTo(I+this._renderedWidth+2*this._lineThroughWidthOffset,k),S.stroke(),S.restore()}}var dt=k(3067),pt=k(80271),mt=k(90624);const gt=Math.PI/180;class V{constructor(S){this._t=S}static createIdentity(){return new V([1,0,0,0,1,0])}clone(){const S=this._t;return new V(S.slice())}transform(S){const I=this._t;return[I[0]*S[0]+I[1]*S[1]+I[2],I[3]*S[0]+I[4]*S[1]+I[5]]}static createScale(S,I){return new V([S,0,0,0,I,0])}scale(S,I){const k=this._t;return k[0]*=S,k[1]*=S,k[2]*=S,k[3]*=I,k[4]*=I,k[5]*=I,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(S,I){return new V([0,0,S,0,0,I])}translate(S,I){const k=this._t;return k[2]+=S,k[5]+=I,this}static createRotate(S){const I=Math.cos(S),k=Math.sin(S);return new V([I,-k,0,k,I,0])}rotate(S){return V.multiply(this,V.createRotate(S),this)}angle(){const S=this._t[0],I=this._t[3],k=Math.sqrt(S*S+I*I);return[S/k,I/k]}static multiply(S,I,k){const E=S._t,G=I._t,F=E[0]*G[0]+E[3]*G[1],N=E[1]*G[0]+E[4]*G[1],D=E[2]*G[0]+E[5]*G[1]+G[2],X=E[0]*G[3]+E[3]*G[4],et=E[1]*G[3]+E[4]*G[4],st=E[2]*G[3]+E[5]*G[4]+G[5],it=k._t;return it[0]=F,it[1]=N,it[2]=D,it[3]=X,it[4]=et,it[5]=st,k}invert(){const S=this._t;let I=S[0]*S[4]-S[1]*S[3];if(0===I)return new V([0,0,0,0,0,0]);I=1/I;const k=(S[1]*S[5]-S[2]*S[4])*I,E=(S[2]*S[3]-S[0]*S[5])*I,G=S[4]*I,F=-S[1]*I,N=-S[3]*I,D=S[0]*I;return new V([G,F,k,N,D,E])}}class q{constructor(S,I){this._resourceManager=S,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new D.A(lt.W,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(I||V.createIdentity()),this._sizeTransfos.push(I?I.scaleRatio():1)}setTransform(S,I){this._transfos=[S||V.createIdentity()],this._sizeTransfos=[I||(S?S.scaleRatio():1)]}setGeomUnitsPerPoint(S){this._geomUnitsPerPoint=S}transformPt(S){return this._transfos[this._transfos.length-1].transform(S)}transformSize(S){return S*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(S){return this._transfos[this._transfos.length-1].invert().transform(S)}reverseTransformSize(S){return S/this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformScalar(S){return S/this._transfos[this._transfos.length-1].scaleRatio()}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}prevGeomUnitsPerPoint(){return this._transfos.length>2?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(S,I){const k=I?S.scaleRatio():1;V.multiply(S,this.back(),S),this._transfos.push(S),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*k)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(S,I,k){if(S)switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(S,I);break;case"CIMTextSymbol":this.drawTextSymbol(S,I,k)}}drawMultiLayerSymbol(S,I){if(!S||!I)return;const k=S.symbolLayers;if(!k)return;const E=S.effects;if(E&&E.length>0){const S=this.executeEffects(E,I);if(S){let I=S.next();for(;I;)this.drawSymbolLayers(k,I.asJSON()),I=S.next()}}else this.drawSymbolLayers(k,I)}executeEffects(S,I){const k=this._resourceManager.geometryEngine;let E=new at.k(et.z.fromJSONCIM(I));for(const G of S){const S=(0,ht.A)(G);S&&(E=S.execute(E,G,this.geomUnitsPerPoint(),null,k))}return E}drawSymbolLayers(S,I){let k=S.length;for(;k--;){const E=S[k];if(!E||!1===E.enable)continue;const G=E.effects;if(G&&G.length>0){const S=this.executeEffects(G,I);if(S){let I=null;for(;(I=S.next())&&(this.drawSymbolLayer(E,I.asJSON()),!this._earlyReturn););}}else this.drawSymbolLayer(E,I);if(this._earlyReturn)return}}drawSymbolLayer(S,I){switch(S.type){case"CIMSolidFill":this.drawSolidFill(I,S.color);break;case"CIMHatchFill":this.drawHatchFill(I,S);break;case"CIMPictureFill":this.drawPictureFill(I,S);break;case"CIMGradientFill":this.drawGradientFill(I,S);break;case"CIMSolidStroke":this.drawSolidStroke(I,S.color,S.width,S.capStyle,S.joinStyle,S.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(I,S);break;case"CIMGradientStroke":this.drawGradientStroke(I,S);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(S,I)}}drawHatchFill(S,I){const k=this._buildHatchPolyline(I,S,this.geomUnitsPerPoint());k&&(this.pushClipPath(S),this.drawMultiLayerSymbol(I.lineSymbol,k),this.popClipPath())}drawPictureFill(S,I){}drawGradientFill(S,I){}drawPictureStroke(S,I){}drawGradientStroke(S,I){}drawMarkerLayer(S,I){const k=S.markerPlacement;if(k){const E=(0,ht.c)(k);if(E){const G="CIMMarkerPlacementInsidePolygon"===k.type||"CIMMarkerPlacementPolygonCenter"===k.type&&k.clipAtBoundary;G&&this.pushClipPath(I);const F=E.execute(et.z.fromJSONCIM(I),k,this.geomUnitsPerPoint(),null,this._resourceManager.geometryEngine);if(F){let I=null;for(;(I=F.next())&&(this.drawMarker(S,I),!this._earlyReturn););}G&&this.popClipPath()}}else{const k=this._placementPool.acquire();if((0,ot.fT)(I))k.tx=I.x,k.ty=I.y,this.drawMarker(S,k);else if((0,ot.Bi)(I)){const E=(0,nt.l8)(I);E&&([k.tx,k.ty]=E,this.drawMarker(S,k))}else for(const E of I.points)if(k.tx=E[0],k.ty=E[1],this.drawMarker(S,k),this._earlyReturn)break;this._placementPool.release(k)}}drawMarker(S,I){switch(S.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(S,I);break;case"CIMVectorMarker":this.drawVectorMarker(S,I)}}drawPictureMarker(S,I){if(!S)return;const k=this._resourceManager.getResource(S.url),E=(0,dt._W)(S.size,ct.D.CIMPictureMarker.size);if(null==k||E<=0)return;const G=k.width,F=k.height;if(!G||!F)return;const N=G/F,D=(0,dt._W)(S.scaleX,1),X=V.createIdentity(),et=S.anchorPoint;if(et){let I=et.x,k=et.y;"Absolute"!==S.anchorPointUnits&&(I*=E*N*D,k*=E),X.translate(-I,-k)}let st=(0,dt._W)(S.rotation);S.rotateClockwise&&(st=-st),this._mapRotation&&(st+=this._mapRotation),st&&X.rotate(st*gt);let it=(0,dt._W)(S.offsetX),nt=(0,dt._W)(S.offsetY);if(it||nt){if(this._mapRotation){const S=gt*this._mapRotation,I=Math.cos(S),k=Math.sin(S),E=it*k+nt*I;it=it*I-nt*k,nt=E}X.translate(it,nt)}const ot=this.geomUnitsPerPoint();1!==ot&&X.scale(ot,ot);const at=I.getAngle();at&&X.rotate(at),X.translate(I.tx,I.ty),this.push(X,!1),this.drawImage(S,E),this.pop()}drawVectorMarker(S,I){if(!S)return;const k=S.markerGraphics;if(!k)return;const E=(0,dt._W)(S.size,ct.D.CIMVectorMarker.size),G=S.frame,F=G?G.ymax-G.ymin:0,D=E&&F?E/F:1,X=V.createIdentity();G&&X.translate(.5*-(G.xmax+G.xmin),.5*-(G.ymax+G.ymin));const et=S.anchorPoint;if(et){let I=et.x,k=et.y;"Absolute"!==S.anchorPointUnits?G&&(I*=G.xmax-G.xmin,k*=G.ymax-G.ymin):(I/=D,k/=D),X.translate(-I,-k)}1!==D&&X.scale(D,D);let st=(0,dt._W)(S.rotation);S.rotateClockwise&&(st=-st),this._mapRotation&&(st+=this._mapRotation),st&&X.rotate(st*gt);let it=(0,dt._W)(S.offsetX),nt=(0,dt._W)(S.offsetY);if(it||nt){if(this._mapRotation){const S=gt*this._mapRotation,I=Math.cos(S),k=Math.sin(S),E=it*k+nt*I;it=it*I-nt*k,nt=E}X.translate(it,nt)}const ot=this.geomUnitsPerPoint();1!==ot&&X.scale(ot,ot);const at=I.getAngle();at&&X.rotate(at),X.translate(I.tx,I.ty),this.push(X,S.scaleSymbolsProportionally);for(const ht of k){(null===ht||void 0===ht?void 0:ht.symbol)&&ht.geometry||N.A.getLogger("esri.symbols.cim.CIMSymbolDrawHelper").error("Invalid marker graphic",ht);let S=ht.textString;if("number"==typeof S&&(S=S.toString()),this.drawSymbol(ht.symbol,ht.geometry,S),this._earlyReturn)break}this.pop()}drawTextSymbol(S,I,k){if(!S)return;if(!(0,ot.fT)(I))return;if((0,dt._W)(S.height,ct.D.CIMTextSymbol.height)<=0)return;const E=V.createIdentity();let G=(0,dt._W)(S.angle);G=-G,G&&E.rotate(G*gt);const F=(0,dt._W)(S.offsetX),N=(0,dt._W)(S.offsetY);(F||N)&&E.translate(F,N);const D=this.geomUnitsPerPoint();1!==D&&E.scale(D,D),E.translate(I.x,I.y),this.push(E,!1),this.drawText(S,k),this.pop()}_buildHatchPolyline(S,I,k){let E=(0,dt._W)(S.separation,ct.D.CIMHatchFill.separation)*k,G=(0,dt._W)(S.rotation);if(0===E)return null;E<0&&(E=-E);let F=0;const N=.5*E;for(;F>N;)F-=E;for(;F<-N;)F+=E;const D=(0,st.vt)();(0,it.Rg)(D,I),D[0]-=N,D[1]-=N,D[2]+=N,D[3]+=N;const X=[[D[0],D[1]],[D[0],D[3]],[D[2],D[3]],[D[2],D[1]]];for(;G>180;)G-=180;for(;G<0;)G+=180;const et=Math.cos(G*gt),nt=Math.sin(G*gt),ot=-E*nt,at=E*et;let ht,lt,ut,_t;F=(0,dt._W)(S.offsetX)*k*nt-(0,dt._W)(S.offsetY)*k*et,ht=ut=Number.MAX_VALUE,lt=_t=-Number.MAX_VALUE;for(const st of X){const S=st[0],I=st[1],k=et*S+nt*I,E=-nt*S+et*I;ht=Math.min(ht,k),ut=Math.min(ut,E),lt=Math.max(lt,k),_t=Math.max(_t,E)}ut=Math.floor(ut/E)*E;let ft=et*ht-nt*ut-ot*F/E,pt=nt*ht+et*ut-at*F/E,mt=et*lt-nt*ut-ot*F/E,yt=nt*lt+et*ut-at*F/E;const Pt=1+Math.round((_t-ut)/E),xt=[];for(let st=0;st<Pt;st++)ft+=ot,pt+=at,mt+=ot,yt+=at,xt.push([[ft,pt],[mt,yt]]);return{paths:xt}}}class Y extends q{constructor(S,I){super(S,I),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new _t.A(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,st.fA)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(S){if(S&&!(this._clipCount>0))if((0,ot.Bi)(S))this._processPath(S.rings,0);else if((0,ot.Rg)(S))this._processPath(S.paths,0);else if((0,ot.ZC)(S)){const I=Z(S);I&&this._processPath(I.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(S,I,k){if(!S||this._clipCount>0||null==k||k<=0)return;const E=Math.max(.5*this.transformSize((0,dt._W)(k,ct.D.CIMSolidStroke.width)),.25);if((0,ot.Bi)(S))this._processPath(S.rings,E);else if((0,ot.Rg)(S))this._processPath(S.paths,E);else if((0,ot.ZC)(S)){const I=Z(S);I&&this._processPath(I.rings,E)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(S,I){(0,ot.Bi)(I)&&S.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===S.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===S.markerPlacement.type&&S.markerPlacement.clipAtBoundary)?this._processPath(I.rings,0):super.drawMarkerLayer(S,I)}drawHatchFill(S,I){this.drawSolidFill(S)}drawPictureFill(S,I){this.drawSolidFill(S)}drawGradientFill(S,I){this.drawSolidFill(S)}drawPictureStroke(S,I){this.drawSolidStroke(S,null,I.width)}drawGradientStroke(S,I){this.drawSolidStroke(S,null,I.width)}pushClipPath(S){this.drawSolidFill(S),this._clipCount++}popClipPath(){this._clipCount--}drawImage(S,I){const{url:k}=S,E=(0,dt._W)(S.scaleX,1);let G=E*I,F=I;const N=this._resourceManager.getResource(k);if(null!=N){const S=N.height/N.width;G=E*(I?S>1?I:I/S:N.width),F=I?S>1?I*S:I:N.height}this._merge(this.transformPt([-G/2,-F/2]),0),this._merge(this.transformPt([-G/2,F/2]),0),this._merge(this.transformPt([G/2,-F/2]),0),this._merge(this.transformPt([G/2,F/2]),0)}drawText(S,I){if(!I||0===I.length)return;this._textRasterizer||(this._textRasterizer=new TextRasterizer_r);const k=tt(S);let[E,G]=this._textRasterizer.computeTextSize(I,k);E=(0,X.PN)(E),G=(0,X.PN)(G);let F=0;switch(S.horizontalAlignment){case"Left":F=E/2;break;case"Right":F=-E/2}let N=0;switch(S.verticalAlignment){case"Bottom":N=G/2;break;case"Top":N=-G/2;break;case"Baseline":N=G/6}this._merge(this.transformPt([-E/2+F,-G/2+N]),0),this._merge(this.transformPt([-E/2+F,G/2+N]),0),this._merge(this.transformPt([E/2+F,-G/2+N]),0),this._merge(this.transformPt([E/2+F,G/2+N]),0)}_processPath(S,I){if(S)for(const k of S){const S=k?k.length:0;if(S>1){this._merge(this.transformPt(k[0]),I);for(let E=1;E<S;E++)this._merge(this.transformPt(k[E]),I)}}}_merge(S,I){S[0]-I<this._xmin&&(this._xmin=S[0]-I),S[0]+I>this._xmax&&(this._xmax=S[0]+I),S[1]-I<this._ymin&&(this._ymin=S[1]-I),S[1]+I>this._ymax&&(this._ymax=S[1]+I)}}class W extends q{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0,this._textInfo=null}hitTest(S,I,k,E,F,N){const D=N*(0,X.Lz)(1);this.setTransform(),this.setGeomUnitsPerPoint(D),this._searchPoint=[(S[0]+S[2])/2,(S[1]+S[3])/2],this._searchDistPoint=(S[2]-S[0])/2/D,this._textInfo=E;const et=I&&("CIMPointSymbol"===I.type&&"Map"!==I.angleAlignment||"CIMTextSymbol"===I.type);if(this._mapRotation=et?F:0,!(0,G.A)("esri-mobile")){var st,it;const S=(0,X.PN)((0,G.A)("hittest-2d-small-symbol-tolerance")*window.devicePixelRatio),k=(0,X.PN)((0,G.A)("hittest-2d-small-symbol-tolerance-threshold"));("CIMLineSymbol"!==(null===I||void 0===I?void 0:I.type)&&"CIMPolygonSymbol"!==(null===I||void 0===I?void 0:I.type)||null===(st=I.symbolLayers)||void 0===st||!st.some(dt.jn))&&"CIMMeshSymbol"!==(null===I||void 0===I?void 0:I.type)&&(null!==(it=(0,dt.YC)(I))&&void 0!==it?it:0)<k&&(this._searchDistPoint=S)}return this._earlyReturn=!1,this.drawSymbol(I,k),this._earlyReturn}drawSolidFill(S,I){this._hitTestFill(S)}drawHatchFill(S,I){this._hitTestFill(S)}drawPictureFill(S,I){this._hitTestFill(S)}drawGradientFill(S,I){this._hitTestFill(S)}drawSolidStroke(S,I,k,E,G,F){this._hitTestStroke(S,k)}drawPictureStroke(S,I){this._hitTestStroke(S,I.width)}drawGradientStroke(S,I){this._hitTestStroke(S,I.width)}drawMarkerLayer(S,I){S.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===S.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===S.markerPlacement.type&&S.markerPlacement.clipAtBoundary)?this._hitTestFill(I):super.drawMarkerLayer(S,I)}pushClipPath(S){}popClipPath(){}drawImage(S,I){const{url:k}=S,E=(0,dt._W)(S.scaleX,1),G=this._resourceManager.getResource(k);if(null==G||0===G.height||0===I)return;const F=I*this.geomUnitsPerPoint(),N=F*E*(G.width/G.height),D=this.reverseTransformPt(this._searchPoint),X=this._searchDistPoint;Math.abs(D[0])<N/2+X&&Math.abs(D[1])<F/2+X&&(this._earlyReturn=!0)}drawText(S,I){var k;const E=this._textInfo;if(!E)return;const G=E.get(S);if(!G)return;if(!G.glyphMosaicItems.glyphs.length)return;const F=(0,dt._W)(S.height,ct.D.CIMTextSymbol.height),{lineGapType:N,lineGap:D}=S,X=N?$(N,(0,dt._W)(D),F):0,et="CIMBackgroundCallout"===(null===(k=S.callout)||void 0===k?void 0:k.type),st=(0,mt.Tl)(G.glyphMosaicItems,{scale:F/pt.eG,angle:0,xOffset:0,yOffset:0,horizontalAlignment:S.horizontalAlignment,verticalAlignment:S.verticalAlignment,maxLineWidth:512,lineHeight:pt.DY*Math.max(.25,Math.min(X||1,4)),decoration:S.font.decoration||"none",useCIMAngleBehavior:!0,hasBackground:et}),it=this.reverseTransformPt(this._searchPoint),nt=it[0],ot=it[1];for(const at of st.glyphs)if(nt>at.xTopLeft&&nt<at.xBottomRight&&ot>-at.yBottomRight&&ot<-at.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(S){let I=null;if((0,ot.ZC)(S)){const k=S;I=[[[k.xmin,k.ymin],[k.xmin,k.ymax],[k.xmax,k.ymax],[k.xmax,k.ymin],[k.xmin,k.ymin]]]}else if((0,ot.Bi)(S))I=S.rings;else{if(!(0,ot.Rg)(S))return;I=S.paths}const k=this.reverseTransformPt(this._searchPoint);if(this._pointInPolygon(k,I)&&(this._earlyReturn=!0),!this._earlyReturn){const S=this.reverseTransformScalar(this._searchDistPoint)*this.prevGeomUnitsPerPoint();this._nearLine(k,I,S)&&(this._earlyReturn=!0)}}_hitTestStroke(S,I){let k=null;if((0,ot.ZC)(S)){const I=S;k=[[[I.xmin,I.ymin],[I.xmin,I.ymax],[I.xmax,I.ymax],[I.xmax,I.ymin],[I.xmin,I.ymin]]]}else if((0,ot.Bi)(S))k=S.rings;else{if(!(0,ot.Rg)(S))return;k=S.paths}const E=this.reverseTransformPt(this._searchPoint),G=(0,dt._W)(I,ct.D.CIMSolidStroke.width)*this.geomUnitsPerPoint(),F=this.reverseTransformScalar(this._searchDistPoint)*this.prevGeomUnitsPerPoint();this._nearLine(E,k,G/2+F)&&(this._earlyReturn=!0)}_pointInPolygon(S,I){let k=0;for(const E of I){const I=E.length;for(let G=1;G<I;G++){const I=E[G-1],F=E[G];I[1]>S[1]!=F[1]>S[1]&&((F[0]-I[0])*(S[1]-I[1])-(F[1]-I[1])*(S[0]-I[0])>0?k++:k--)}}return 0!==k}_nearLine(S,I,k){for(const E of I){const I=E.length;for(let G=1;G<I;G++){const I=E[G-1],F=E[G];let N=(F[0]-I[0])*(F[0]-I[0])+(F[1]-I[1])*(F[1]-I[1]);if(0===N)continue;N=Math.sqrt(N);const D=((F[0]-I[0])*(S[1]-I[1])-(F[1]-I[1])*(S[0]-I[0]))/N;if(Math.abs(D)<k){const E=((F[0]-I[0])*(S[0]-I[0])+(F[1]-I[1])*(S[1]-I[1]))/N;if(E>-k&&E<N+k)return!0}}}return!1}}class K extends q{constructor(S,I,k,E){super(I,k),this._applyAdditionalRenderProps=E,this._colorSubstitutionHelper=new CIMImageColorSubstitutionHelper_t,this._ctx=S}drawSolidFill(S,I){var k;if(!S)return;if((0,ot.Bi)(S))this._buildPath(S.rings,!0);else if((0,ot.Rg)(S))this._buildPath(S.paths,!0);else if((0,ot.ZC)(S))this._buildPath(Z(S).rings,!0);else{if(!(0,ot.U9)(S))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const E=this._ctx;E.fillStyle="string"==typeof I?I:"rgba("+Math.round(I[0])+","+Math.round(I[1])+","+Math.round(I[2])+","+(null!==(k=I[3])&&void 0!==k?k:255)/255+")",E.fill("evenodd")}drawSolidStroke(S,I,k,E,G,F){var N;if(!S||!I||0===k)return;if((0,ot.Bi)(S))this._buildPath(S.rings,!0);else if((0,ot.Rg)(S))this._buildPath(S.paths,!1);else{if(!(0,ot.ZC)(S))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(Z(S).rings,!0)}const D=this._ctx;D.strokeStyle="string"==typeof I?I:"rgba("+Math.round(I[0])+","+Math.round(I[1])+","+Math.round(I[2])+","+(null!==(N=I[3])&&void 0!==N?N:255)/255+")",D.lineWidth=Math.max(this.transformSize(k),.5),this._setCapStyle(E),this._setJoinStyle(G),D.miterLimit=F,D.stroke()}pushClipPath(S){if(this._ctx.save(),(0,ot.Bi)(S))this._buildPath(S.rings,!0);else if((0,ot.Rg)(S))this._buildPath(S.paths,!0);else{if(!(0,ot.ZC)(S))return;this._buildPath(Z(S).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(S,I){const{colorSubstitutions:k,url:E,tintColor:G}=S,F=(0,dt._W)(S.scaleX,1),N=this._resourceManager.getResource(E);if(null==N)return;let D=I*(N.width/N.height),X=I;I||(D=N.width,X=N.height);const et=(0,dt.UE)(E)||"src"in N&&(0,dt.UE)(N.src);let st="getFrame"in N?imageUtils_t(N):N;k&&(st=this._colorSubstitutionHelper.applyColorSubstituition(st,k)),this._applyAdditionalRenderProps&&!et&&G&&(st=this._colorSubstitutionHelper.tintImageData(st,G));const it=this.transformPt([0,0]),[nt,ot]=this.getTransformAngle(),at=this.transformSize(1),ht=this._ctx;ht.save(),ht.setTransform({m11:F*at*nt,m12:F*at*ot,m21:-at*ot,m22:at*nt,m41:it[0],m42:it[1]}),ht.drawImage(st,-D/2,-X/2,D,X),ht.restore()}drawText(S,I){if(!I||0===I.length)return;this._textRasterizer||(this._textRasterizer=new TextRasterizer_r);const k=tt(S);k.size*=this.transformSize((0,X.PN)(1));const E=this._textRasterizer.rasterizeText(I,k);if(!E)return;const{size:G,anchorX:F,anchorY:N,canvas:D}=E,et=G[0]*(F+.5),st=G[1]*(N-.5),it=this._ctx,nt=this.transformPt([0,0]),[ot,at]=this.getTransformAngle();it.save(),it.setTransform({m11:1*ot,m12:1*at,m21:-1*at,m22:1*ot,m41:nt[0]-1*et,m42:nt[1]+1*st}),it.drawImage(D,0,0),it.restore()}drawPictureFill(S,I){if(!S)return;let{colorSubstitutions:k,height:E,offsetX:G,offsetY:F,rotation:N,scaleX:D,tintColor:X,url:et}=I;const st=this._resourceManager.getResource(et);if(null==st)return;if((0,ot.Bi)(S))this._buildPath(S.rings,!0);else if((0,ot.Rg)(S))this._buildPath(S.paths,!0);else if((0,ot.ZC)(S))this._buildPath(Z(S).rings,!0);else{if(!(0,ot.U9)(S))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const it=this._ctx,nt=(0,dt.UE)(et)||"src"in st&&(0,dt.UE)(st.src);let at,ht="getFrame"in st?imageUtils_t(st):st;if(k&&(ht=this._colorSubstitutionHelper.applyColorSubstituition(ht,k)),this._applyAdditionalRenderProps){nt||X&&(ht=this._colorSubstitutionHelper.tintImageData(ht,X)),at=it.createPattern(ht,"repeat");const S=this.transformSize(1);N||(N=0),G?G*=S:G=0,F?F*=S:F=0,E&&(E*=S);const I=E?E/st.height:1,k=D&&E?D*E/st.width:1;if(0!==N||1!==I||1!==k||0!==G||0!==F){const S=new DOMMatrix;S.rotateSelf(0,0,-N).translateSelf(G,F).scaleSelf(k,I,1),at.setTransform(S)}}else at=it.createPattern(ht,"repeat");it.save(),it.fillStyle=at,it.fill("evenodd"),it.restore()}drawPictureStroke(S,I){if(!S)return;let{colorSubstitutions:k,capStyle:E,joinStyle:G,miterLimit:N,tintColor:D,url:et,width:st}=I;const it=this._resourceManager.getResource(et);if(null==it)return;let nt;if((0,ot.Bi)(S))nt=S.rings;else if((0,ot.Rg)(S))nt=S.paths;else{if(!(0,ot.ZC)(S))return(0,ot.U9)(S)?void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!"):void 0;nt=Z(S).rings}st||(st=it.width);const at=(0,dt.UE)(et)||"src"in it&&(0,dt.UE)(it.src);let ht="getFrame"in it?imageUtils_t(it):it;k&&(ht=this._colorSubstitutionHelper.applyColorSubstituition(ht,k)),this._applyAdditionalRenderProps&&(at||D&&(ht=this._colorSubstitutionHelper.tintImageData(ht,D)));const lt=Math.max(this.transformSize((0,X.Lz)(st)),.5),ct=lt/ht.width,ut=this._ctx,_t=ut.createPattern(ht,"repeat-y");let ft,pt;ut.save(),this._setCapStyle(E),this._setJoinStyle(G),void 0!==N&&(ut.miterLimit=N),ut.lineWidth=lt;for(let X of nt)if(X=(0,F.o8)(X),rt(X),X&&!(X.length<=1)){ft=this.transformPt(X[0]);for(let S=1;S<X.length;S++){pt=this.transformPt(X[S]);const I=Q(ft,pt),k=new DOMMatrix;k.translateSelf(0,ft[1]-lt/2).scaleSelf(ct,ct,1).rotateSelf(0,0,90-I),_t.setTransform(k),ut.strokeStyle=_t,ut.beginPath(),ut.moveTo(ft[0],ft[1]),ut.lineTo(pt[0],pt[1]),ut.stroke(),ft=pt}}ut.restore()}_buildPath(S,I){const k=this._ctx;if(k.beginPath(),S)for(const E of S){const S=E?E.length:0;if(S>1){let G=this.transformPt(E[0]);k.moveTo(G[0],G[1]);for(let I=1;I<S;I++)G=this.transformPt(E[I]),k.lineTo(G[0],G[1]);I&&k.closePath()}}}_setCapStyle(S){switch(S){case ut.uT.Butt:this._ctx.lineCap="butt";break;case ut.uT.Round:this._ctx.lineCap="round";break;case ut.uT.Square:this._ctx.lineCap="square"}}_setJoinStyle(S){switch(S){case ut.wd.Bevel:this._ctx.lineJoin="bevel";break;case ut.wd.Round:this._ctx.lineJoin="round";break;case ut.wd.Miter:this._ctx.lineJoin="miter"}}}function Q(S,I){const k=I[0]-S[0],E=I[1]-S[1];return 180/Math.PI*Math.atan2(E,k)}const Z=S=>S?{spatialReference:S.spatialReference,rings:[[[S.xmin,S.ymin],[S.xmin,S.ymax],[S.xmax,S.ymax],[S.xmax,S.ymin],[S.xmin,S.ymin]]]}:null,$=(S,I,k)=>{switch(S){case"ExtraLeading":return 1+I/k;case"Multiple":return I;case"Exact":return I/k}};function tt(S){var I,k,G;let F=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const N=(0,dt.DW)(S),D=(0,dt._d)(S.fontStyleName),X=null!==(I=S.fontFamilyName)&&void 0!==I?I:E.Vb,{weight:et,style:st}=D,it=F*(S.height||5),nt=(0,dt.Bu)(S.horizontalAlignment),ot=(0,dt.Nl)(S.verticalAlignment),at=(0,dt.pM)(S),ht=(0,dt.pM)(S.haloSymbol),lt=null!=ht?F*(null!==(k=S.haloSize)&&void 0!==k?k:0):0,ct="CIMBackgroundCallout"===(null===(G=S.callout)||void 0===G?void 0:G.type)?S.callout.backgroundSymbol:null,ut=(0,dt.pM)(ct),_t=(0,dt.xo)(ct),ft=(0,dt._1)(ct);return{color:at,size:it,horizontalAlignment:nt,verticalAlignment:ot,font:{family:X,style:(0,dt.pV)(st),weight:(0,dt.Kn)(et),decoration:N},halo:{size:lt||0,color:ht,style:st},backgroundColor:ut,borderLine:null!=_t&&null!=ft?{size:_t,color:ft}:null,pixelRatio:1,premultiplyColors:!0}}const yt=1e-4;function rt(S){let I,k,E,G,F,N=S[0],D=1;for(;D<S.length;)I=S[D][0]-N[0],k=S[D][1]-N[1],G=0!==I?k/I:Math.PI/2,void 0!==E&&G-E<=yt?(S.splice(D-1,1),N=F):(F=N,N=S[D],D++),E=G}},8809:(S,I,k)=>{k.d(I,{BW:()=>ne,Sc:()=>J,Vb:()=>U,ll:()=>$,ni:()=>Z,wp:()=>K});var E=k(90301),G=k(50886),F=k(66004),N=k(89412),D=k(76761),X=k(62555),et=k(88965),st=k(12439),it=k(40137),nt=k(10717),ot=k(80887),at=k(29354),ht=k(64032),lt=k(3067),ct=k(99442),ut=k(29457),_t=k(80271),ft=k(90624);const dt=Math.PI,pt=dt/2,mt=Math.PI/180,gt=96/72,H=()=>N.A.getLogger("esri.symbols.cim.CIMSymbolHelper");function U(S){let I;switch(S.type){case"cim":return S.data;case"web-style":return S;case"simple-marker":{const k=K.fromSimpleMarker(S);if(!k)throw new Error("InternalError: Cannot convert symbol to CIM");I=k;break}case"picture-marker":I=K.fromPictureMarker(S);break;case"simple-line":I=K.fromSimpleLineSymbol(S);break;case"simple-fill":I=K.fromSimpleFillSymbol(S);break;case"picture-fill":I=K.fromPictureFillSymbol(S);break;case"text":I=K.fromTextSymbol(S)}return{type:"CIMSymbolReference",symbol:I}}function O(S,I,k){switch(I.type){case"CIMSymbolReference":return O(S,I.symbol,k);case"CIMPointSymbol":null==k&&(k={x:0,y:0}),S.drawSymbol(I,k);break;case"CIMLineSymbol":null==k&&(k={paths:[[[0,0],[10,0]]]}),S.drawSymbol(I,k);break;case"CIMPolygonSymbol":null==k&&(k={rings:[[[0,0],[0,10],[10,10],[10,0],[0,0]]]}),S.drawSymbol(I,k);break;case"CIMTextSymbol":{const k={x:0,y:0};S.drawSymbol(I,k);break}case"CIMVectorMarker":{const k=new nt.W;S.drawMarker(I,k);break}}return S.envelope()}function q(S){if(!S)return 0;switch(S.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(S.offset);default:return 0}}function W(S){if(!S)return 0;switch(S.type){case"CIMGeometricEffectArrow":return Math.abs(.5*S.width);case"CIMGeometricEffectBuffer":return Math.abs(S.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(S.length);case"CIMGeometricEffectJog":return Math.abs(.5*S.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,lt._W)(S.offsetX)),Math.abs((0,lt._W)(S.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(S.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(S.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(S.fromWidth),Math.abs(S.toWidth));case"CIMGeometricEffectWave":return Math.abs(S.amplitude);case"CIMGeometricEffectDonut":return Math.abs(S.width)}}function $(S){if(!S)return 0;let I=0;for(const k of S)I+=W(k);return I}class J{static getSymbolInflateSize(S,I,k,E,G){return S||(S=[0,0,0,0]),I?this._getInflateSize(S,I,k,E,G):S}static safeSize(S){const I=Math.max(Math.abs(S[0]),Math.abs(S[2])),k=Math.max(Math.abs(S[1]),Math.abs(S[3]));return Math.sqrt(I*I+k*k)}static _vectorMarkerBounds(S,I,k,E){let G=!0;const F=(0,et.vt)();if(null!==I&&void 0!==I&&I.markerGraphics)for(const N of I.markerGraphics){const I=[0,0,0,0];N.geometry&&((0,st.Rg)(F,N.geometry),I[0]=0,I[1]=0,I[2]=0,I[3]=0,this.getSymbolInflateSize(I,N.symbol,k,0,E),F[0]+=I[0],F[1]+=I[1],F[2]+=I[2],F[3]+=I[3],G?(S[0]=F[0],S[1]=F[1],S[2]=F[2],S[3]=F[3],G=!1):(S[0]=Math.min(S[0],F[0]),S[1]=Math.min(S[1],F[1]),S[2]=Math.max(S[2],F[2]),S[3]=Math.max(S[3],F[3])))}return S}static _getInflateSize(S,I,k,E,G){if(function le(S){return void 0!==S.symbolLayers}(I)){const F=this._getLayersInflateSize(S,I.symbolLayers,k,E,G),N=$(I.effects);return N>0&&(F[0]-=N,F[1]-=N,F[2]+=N,F[3]+=N),F}return this._getTextInflatedSize(S,I,G)}static _getLayersInflateSize(S,I,k,E,G){let F=!0;if(!I)return S;for(const N of I){if(!N)continue;let I=[0,0,0,0];switch(N.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const S=N;let k=S.width;null!=k&&(S.capStyle===ht.uT.Square||S.joinStyle===ht.wd.Miter?k/=1.4142135623730951:k/=2,I[0]=-k,I[1]=-k,I[2]=k,I[3]=k);break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const S=N;if("CIMVectorMarker"===N.type){const S=N;if(I=this._vectorMarkerBounds(I,S,k,G),S.frame){const k=(S.frame.xmin+S.frame.xmax)/2,E=(S.frame.ymin+S.frame.ymax)/2;if(I[0]-=k,I[1]-=E,I[2]-=k,I[3]-=E,null!=S.size){const k=S.size/(S.frame.ymax-S.frame.ymin);I[0]*=k,I[1]*=k,I[2]*=k,I[3]*=k}}}else if("CIMPictureMarker"===N.type){const E=N,G=k.getResource(E.url);let F=1;if(null!=G&&G.height&&(F=G.width/G.height),null!=S.size){const k=S.size/2,G=S.size*F*E.scaleX/2;I=[-G,-k,G,k]}}else if(null!=S.size){const k=S.size/2;I=[-k,-k,k,k]}if(S.anchorPoint){let k,E;"Absolute"===S.anchorPointUnits?(k=S.anchorPoint.x,E=S.anchorPoint.y):(k=S.anchorPoint.x*(I[2]-I[0]),E=S.anchorPoint.y*(I[3]-I[1])),I[0]-=k,I[1]-=E,I[2]-=k,I[3]-=E}let F=(0,lt._W)(S.rotation);if(S.rotateClockwise&&(F=-F),E&&(F-=E),F){const S=mt*F,k=Math.cos(S),E=Math.sin(S),G=(0,et.vt)([ut.MG,ut.MG,-ut.MG,-ut.MG]);(0,et.tK)(G,[I[0]*k-I[1]*E,I[0]*E+I[1]*k]),(0,et.tK)(G,[I[0]*k-I[3]*E,I[0]*E+I[3]*k]),(0,et.tK)(G,[I[2]*k-I[1]*E,I[2]*E+I[1]*k]),(0,et.tK)(G,[I[2]*k-I[3]*E,I[2]*E+I[3]*k]),I=G}let D=(0,lt._W)(S.offsetX),X=(0,lt._W)(S.offsetY);if(E){const S=mt*E,I=Math.cos(S),k=Math.sin(S),G=D*k+X*I;D=D*I-X*k,X=G}I[0]+=D,I[1]+=X,I[2]+=D,I[3]+=X;const st=q(S.markerPlacement);st>0&&(I[0]-=st,I[1]-=st,I[2]+=st,I[3]+=st);break}}const D=$(N.effects);D>0&&(I[0]-=D,I[1]-=D,I[2]+=D,I[3]+=D),F?(S[0]=I[0],S[1]=I[1],S[2]=I[2],S[3]=I[3],F=!1):(S[0]=Math.min(S[0],I[0]),S[1]=Math.min(S[1],I[1]),S[2]=Math.max(S[2],I[2]),S[3]=Math.max(S[3],I[3]))}return S}static _getTextInflatedSize(S,I,k){var E,G;const F=null!==(E=I.height)&&void 0!==E?E:at.D.CIMTextSymbol.height;if(S[0]=-F/2,S[1]=-F/2,S[2]=F/2,S[3]=F/2,!k)return S;const N=k.get(I);if(!N)return S;if(!N.glyphMosaicItems.glyphs.length)return S;const{lineGapType:D,lineGap:X}=I,et=D?(0,ot.QF)(D,null!==X&&void 0!==X?X:0,F):0,st="CIMBackgroundCallout"===(null===(G=I.callout)||void 0===G?void 0:G.type),it=(0,ft.Tl)(N.glyphMosaicItems,{scale:F/_t.eG,angle:(0,lt._W)(I.angle),xOffset:(0,lt._W)(I.offsetX),yOffset:(0,lt._W)(I.offsetY),horizontalAlignment:I.horizontalAlignment,verticalAlignment:I.verticalAlignment,maxLineWidth:512,lineHeight:_t.DY*Math.max(.25,Math.min(et||1,4)),decoration:I.font.decoration||"none",useCIMAngleBehavior:!0,hasBackground:st}).boundsT;return S[0]=it.x-it.halfWidth,S[1]=-it.y-it.halfHeight,S[2]=it.x+it.halfWidth,S[3]=-it.y+it.halfHeight,S}}class K{static getEnvelope(S,I,k){if(!S)return null;const E=new ot.mx(k);if(Array.isArray(S)){let k;for(const G of S)k?k.union(O(E,G,I)):k=O(E,G,I);return k}return O(E,S,I)}static getTextureAnchor(S,I){const k=this.getEnvelope(S,null,I);if(!k)return[0,0,0];const E=(k.x+.5*k.width)*gt,G=(k.y+.5*k.height)*gt,F=k.width*gt+2,N=k.height*gt+2;return[-E/F,-G/N,N]}static rasterize(S,I,k,E){let G=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const F=k||this.getEnvelope(I,null,E);if(!F)return[null,0,0,0,0];const N=(F.x+.5*F.width)*gt,D=(F.y+.5*F.height)*gt;S.width=F.width*gt,S.height=F.height*gt,k||(S.width+=2,S.height+=2);const X=S.getContext("2d",{willReadFrequently:!0}),et=ot.IT.createScale(gt,-gt);et.translate(.5*S.width-N,.5*S.height+D);const st=new ot.Rj(X,E,et);switch(I.type){case"CIMPointSymbol":{const S={type:"point",x:0,y:0};st.drawSymbol(I,S);break}case"CIMVectorMarker":{const S=new nt.W;st.drawMarker(I,S);break}}const it=X.getImageData(0,0,S.width,S.height),at=new Uint8Array(it.data);if(G){let S;for(let I=0;I<at.length;I+=4)S=at[I+3]/255,at[I]=at[I]*S,at[I+1]=at[I+1]*S,at[I+2]=at[I+2]*S}return[at,S.width,S.height,-N/S.width,-D/S.height]}static fromTextSymbol(S){const{text:I}=S;return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:K.createCIMTextSymbolfromTextSymbol(S),textString:I}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(S){var I;const{height:k,outline:E,width:G,xoffset:F,xscale:N,yoffset:D,yscale:X}=S,et=[],st={type:"CIMPolygonSymbol",symbolLayers:et};if(E){const S=ye(E);S&&et.push(S)}let it=S.url;"esriPFS"===S.type&&S.imageData&&(it=S.imageData);const nt="angle"in S&&null!==(I=S.angle)&&void 0!==I?I:0,ot=(null!==G&&void 0!==G?G:0)*(N||1),at=(null!==k&&void 0!==k?k:0)*(X||1);return et.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:ht.O$.Picture,tintColor:null,url:it,height:at,width:ot,offsetX:(0,lt._W)(F),offsetY:(0,lt._W)(D),rotation:(0,lt._W)(-nt),colorSubstitutions:null}),st}static fromSimpleFillSymbol(S){const{color:I,style:k,outline:E}=S,G=[],N={type:"CIMPolygonSymbol",symbolLayers:G};if(E){const S=ye(E);S&&G.push(S)}if(k&&"solid"!==k&&"none"!==k&&"esriSFSSolid"!==k&&"esriSFSNull"!==k){const S={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:oe(I),capStyle:ht.uT.Butt,joinStyle:ht.wd.Miter,width:.75}]};let E=0;const N=(0,X.PN)(me(k)?8:10);switch(k){case"vertical":case"esriSFSVertical":E=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":E=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":E=45;break;case"cross":case"esriSFSCross":E=0}G.push({type:"CIMHatchFill",lineSymbol:S,offsetX:0,offsetY:0,rotation:E,separation:N}),"cross"===k||"esriSFSCross"===k?G.push({type:"CIMHatchFill",lineSymbol:(0,F.o8)(S),offsetX:0,offsetY:0,rotation:90,separation:N}):"diagonal-cross"!==k&&"esriSFSDiagonalCross"!==k||G.push({type:"CIMHatchFill",lineSymbol:(0,F.o8)(S),offsetX:0,offsetY:0,rotation:45,separation:N})}else!k||"solid"!==k&&"esriSFSSolid"!==k||G.push({type:"CIMSolidFill",enable:!0,color:oe(I)});return N}static fromSimpleLineSymbol(S){const{cap:I,color:k,join:E,marker:G,miterLimit:F,style:N,width:D}=S;let X=null;"solid"!==N&&"none"!==N&&"esriSLSSolid"!==N&&"esriSLSNull"!==N&&(X=[{type:"CIMGeometricEffectDashes",dashTemplate:ne(N,I),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const et=[];if(G){let S;switch(G.placement){case"begin-end":S=ht.$2.Both;break;case"begin":S=ht.$2.JustBegin;break;case"end":S=ht.$2.JustEnd;break;default:S=ht.$2.None}const I=K.fromSimpleMarker(G,D,k).symbolLayers[0];I.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:S,offsetAlongLine:0},et.push(I)}return et.push({type:"CIMSolidStroke",color:"none"!==N&&"esriSLSNull"!==N?oe(k):[0,0,0,0],capStyle:Z(I),joinStyle:ee(E),miterLimit:F,width:D,effects:X}),{type:"CIMLineSymbol",symbolLayers:et}}static fromPictureMarker(S){const{angle:I,height:k,width:E,xoffset:G,yoffset:F}=S;let N=S.url;return"esriPMS"===S.type&&S.imageData&&(N=S.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:ht.O$.Picture,tintColor:null,url:N,size:k,width:E,offsetX:(0,lt._W)(G),offsetY:(0,lt._W)(F),rotation:(0,lt._W)(-I)}]}}static createCIMTextSymbolfromTextSymbol(S){const{angle:I,color:k,font:G,haloColor:F,haloSize:N,horizontalAlignment:D,kerning:X,text:et,verticalAlignment:st,xoffset:it,yoffset:nt,backgroundColor:ot,borderLineColor:at,borderLineSize:ct}=S;let ut,_t,ft,dt,pt,mt;G&&(ut=G.family,_t=G.style,ft=G.weight,dt=G.size,pt=G.decoration);let gt=!1;return et&&(gt=(0,E.y)(et)[1]),(ot||ct)&&(mt={type:"CIMBackgroundCallout",margin:null,backgroundSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",color:oe(ot)},{type:"CIMSolidStroke",color:oe(at),width:ct}]},accentBarSymbol:null,gap:null,leaderLineSymbol:null,lineStyle:null}),{type:"CIMTextSymbol",angle:I,blockProgression:ht.TZ.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:ht.Y.Normal,fontEncoding:ht.bj.Unicode,fontFamilyName:ut||"Arial",fontStyleName:ae(_t,ft),fontType:ht.g7.Unspecified,haloSize:N,height:dt,hinting:ht.mU.Default,horizontalAlignment:te(null!==D&&void 0!==D?D:"center"),kerning:X,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,lt._W)(it),offsetY:(0,lt._W)(nt),strikethrough:"line-through"===pt,underline:"underline"===pt,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:oe(k)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:oe(F)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:gt?ht.f0.RTL:ht.f0.LTR,verticalAlignment:re(null!==st&&void 0!==st?st:"baseline"),verticalGlyphOrientation:ht.vG.Right,wordSpacing:100,billboardMode3D:ht.xn.FaceNearPlane,callout:mt}}static createPictureMarkerRasterizationParam(S){var I,k,E,G;const{angle:F,height:N,width:D,xoffset:X,yoffset:et}=S,st=null!==(I=null!==(k=S.url)&&void 0!==k?k:null===(E=S.source)||void 0===E?void 0:E.url)&&void 0!==I?I:null===(G=S.source)||void 0===G?void 0:G.imageData;return st?{type:"sprite-rasterization-param",overrides:[],resource:{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:ht.O$.Picture,tintColor:null,url:st,size:N,width:D,offsetX:(0,lt._W)(X),offsetY:(0,lt._W)(et),rotation:(0,lt._W)(-F)}}:null}static createPictureFillRasterizationParam(S){const{width:I,height:k,xoffset:E,yoffset:G,url:F}=S;return F?{type:"sprite-rasterization-param",overrides:[],resource:{type:"CIMPictureFill",scaleX:1,textureFilter:ht.O$.Picture,tintColor:null,url:F,width:I,height:k,offsetX:(0,lt._W)(E),offsetY:(0,lt._W)(G),rotation:0}}:null}static fromSimpleMarker(S,I,k){var E;const{style:G}=S,F=null!==(E=S.color)&&void 0!==E?E:k;if("path"===G||"esriSMSPath"===G){const I=[];if("outline"in S&&S.outline){const k=S.outline;I.push({type:"CIMSolidStroke",enable:!0,width:k.width,color:oe(k.color),path:S.path})}I.push({type:"CIMSolidFill",enable:!0,color:oe(F),path:S.path});const[k,E]=ce("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:-(0,lt._W)(S.angle),size:(0,lt._W)(S.size||6),offsetX:(0,lt._W)(S.xoffset),offsetY:(0,lt._W)(S.yoffset),scaleSymbolsProportionally:!1,frame:k,markerGraphics:[{type:"CIMMarkerGraphic",geometry:E,symbol:{type:"CIMPolygonSymbol",symbolLayers:I}}]}]}}const N=[];let D,X,et=S.size;if("outline"in S&&S.outline&&"none"!==S.outline.style&&"esriSLSNull"!==S.outline.style){var st;const I=S.outline,k="solid"!==I.style&&"esriSLSSolid"!==I.style;[D,X]=k?ce(G,S.size):ce(G);const E=null!==(st=I.width)&&void 0!==st?st:ct.A7.width;if(k){const I=E/S.size,k=(D.xmax-D.xmin)*I/2,G=(D.ymax-D.ymin)*I/2;D.xmin-=k,D.xmax+=k,D.ymin-=G,D.ymax+=G,et&&(et+=E)}const F="cross"!==S.style&&"x"!==S.style||"dot"===(null===S||void 0===S?void 0:S.outline.style)||"short-dot"===(null===S||void 0===S?void 0:S.outline.style)?ht.yS.HalfGap:ht.yS.FullPattern,it=k?[{type:"CIMGeometricEffectAddControlPoints"},{type:"CIMGeometricEffectDashes",dashTemplate:ne(I.style,null).map((S=>I.width&&I.width>0?S*I.width:S)),lineDashEnding:F,controlPointEnding:ht.yS.FullPattern}]:void 0;N.push({type:"CIMSolidStroke",capStyle:k?ht.uT.Round:ht.uT.Butt,enable:!0,width:E,color:oe(I.color),effects:it})}else!I||"line-marker"!==S.type||"cross"!==S.style&&"x"!==S.style?[D,X]=ce(G):([D,X]=ce(G),N.push({type:"CIMSolidStroke",enable:!0,width:I,color:oe(F)}));N.push({type:"CIMSolidFill",enable:!0,color:oe(F)});const it={type:"CIMPolygonSymbol",symbolLayers:N};return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,lt._W)(-S.angle),size:(0,lt._W)(et||6*I),offsetX:(0,lt._W)(S.xoffset),offsetY:(0,lt._W)(S.yoffset),scaleSymbolsProportionally:!1,frame:D,markerGraphics:[{type:"CIMMarkerGraphic",geometry:X,symbol:it}]}]}}static fromCIMHatchFill(S,I){var k,E;const G=I*(null!==(k=S.separation)&&void 0!==k?k:at.D.CIMHatchFill.separation),N=G/2,D=(0,F.o8)(S.lineSymbol);null===(E=D.symbolLayers)||void 0===E||E.forEach((S=>{var k;switch(S.type){case"CIMSolidStroke":null!=S.width&&(S.width*=I),null===(k=S.effects)||void 0===k||k.forEach((S=>{if("CIMGeometricEffectDashes"===S.type){const k=S.dashTemplate;S.dashTemplate=k.map((S=>S*I))}}));break;case"CIMVectorMarker":{null!=S.size&&(S.size*=I);const k=S.markerPlacement;null!=k&&"placementTemplate"in k&&(k.placementTemplate=k.placementTemplate.map((S=>S*I)));break}}}));let X=this._getLineSymbolPeriod(D)||4;for(;X<4;)X*=2;const et=X/2;return{type:"CIMVectorMarker",frame:{xmin:-et,xmax:et,ymin:-N,ymax:N},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-et,0],[et,0]]]},symbol:D}],size:G}}static fetchResources(S,I,k){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;return S&&I?(Q(S,(S=>{(function fe(S,I,k){if(!S.effects||null!=I.geometryEngine)return;if(I.geometryEnginePromise)return void k.push(I.geometryEnginePromise);(0,lt.yH)(S.effects)&&(I.geometryEnginePromise=(0,lt._H)(),k.push(I.geometryEnginePromise),I.geometryEnginePromise.then((S=>I.geometryEngine=S)))})(S,I,k),"url"in S&&S.url&&k.push(I.fetchResource(S.url,{signal:E}))})),k):k}static fetchFonts(S,I,k){if(S&&I)if("symbolLayers"in S&&S.symbolLayers){for(const E of S.symbolLayers)if("CIMVectorMarker"===E.type&&E.markerGraphics)for(const S of E.markerGraphics)(null===S||void 0===S?void 0:S.symbol)&&K.fetchFonts(S.symbol,I,k)}else if("CIMTextSymbol"===S.type){const{fontFamilyName:E,fontStyleName:G}=S;if(!E||"calcitewebcoreicons"===E.toLowerCase())return;const{style:F,weight:N}=(0,lt._d)(G),D=(0,lt.DW)(S),X=new it.A({family:E,style:F,weight:N,decoration:D});k.push(I.loadFont(X).catch((()=>{H().error("Unsupported font ".concat(E," in CIM symbol"))})))}}static _getLineSymbolPeriod(S){if(S){const I=this._getEffectsRepeat(S.effects);if(I)return I;if(S.symbolLayers)for(const k of S.symbolLayers)if(k){const S=this._getEffectsRepeat(k.effects);if(S)return S;switch(k.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const S=this._getPlacementRepeat(k.markerPlacement);if(S)return S}}}}return 0}static _getEffectsRepeat(S){if(S)for(const I of S)if(I)switch(I.type){case"CIMGeometricEffectDashes":{const S=I.dashTemplate;if(S&&S.length){let I=0;for(const k of S)I+=k;return 1&S.length&&(I*=2),I}break}case"CIMGeometricEffectWave":return I.period;default:H().error("unsupported geometric effect type ".concat(I.type))}return 0}static _getPlacementRepeat(S){if(S)switch(S.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const I=S.placementTemplate;if(I&&I.length){let S=0;for(const k of I)S+=+k;return 1&I.length&&(S*=2),S}break}}return 0}static fromCIMInsidePolygon(S){var I;const k=S.markerPlacement,E={...S};E.markerPlacement=null,E.anchorPoint=null;const G=Math.abs(k.stepX),F=Math.abs(k.stepY),N=(null!==(I=k.randomness)&&void 0!==I?I:100)/100;let et,st,it,nt;if("Random"===k.gridType){const S=(0,X.PN)(_t.yv),I=Math.max(Math.floor(S/G),1),E=Math.max(Math.floor(S/F),1);et=I*G/2,st=E*F/2,it=2*st;const ot=new D.A(k.seed),at=N*G/1.5,ht=N*F/1.5;nt=[];for(let k=0;k<I;k++)for(let S=0;S<E;S++){const I=k*G-et+at*(.5-ot.getFloat()),E=S*F-st+ht*(.5-ot.getFloat());nt.push({x:I,y:E}),0===k&&nt.push({x:I+2*et,y:E}),0===S&&nt.push({x:I,y:E+2*st})}}else!0===k.shiftOddRows?(et=G/2,st=F,it=2*F,nt=[{x:-et,y:0},{x:et,y:0},{x:0,y:st},{x:0,y:-st}]):(et=G/2,st=F/2,it=F,nt=[{x:-G,y:0},{x:0,y:-F},{x:-G,y:-F},{x:0,y:0},{x:G,y:0},{x:0,y:F},{x:G,y:F},{x:-G,y:F},{x:G,y:-F}]);return{type:"CIMVectorMarker",frame:{xmin:-et,xmax:et,ymin:-st,ymax:st},markerGraphics:nt.map((S=>({type:"CIMMarkerGraphic",geometry:S,symbol:{type:"CIMPointSymbol",symbolLayers:[E]}}))),size:it}}}function Q(S,I){if(S)switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{const k=S.symbolLayers;if(!k)return;for(const S of k)if(I(S),"CIMVectorMarker"===S.type){const k=S.markerGraphics;if(!k)continue;for(const S of k)if(S){const k=S.symbol;k&&Q(k,I)}}break}}}const Z=S=>{if(!S)return ht.uT.Butt;switch(S){case"butt":return ht.uT.Butt;case"square":return ht.uT.Square;case"round":return ht.uT.Round}},ee=S=>{if(!S)return ht.wd.Miter;switch(S){case"miter":return ht.wd.Miter;case"round":return ht.wd.Round;case"bevel":return ht.wd.Bevel}},te=S=>{if(null==S)return"Center";switch(S){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},re=S=>{if(null==S)return"Center";switch(S){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},oe=S=>{if(!S)return[0,0,0,0];const{r:I,g:k,b:E,a:G}=S;return[I,k,E,255*G]},ae=(S,I)=>{const k=se(I),E=ie(S);return k&&E?"".concat(k,"-").concat(E):"".concat(k).concat(E)},se=S=>{if(!S)return"";switch(S.toLowerCase()){case"bold":case"bolder":return"bold"}return""},ie=S=>{if(!S)return"";switch(S.toLowerCase()){case"italic":case"oblique":return"italic"}return""},ne=(S,I)=>{const k=(0,G.A)("safari")?.001:0,E="butt"===I;switch(S){case"dash":case"esriSLSDash":return E?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return E?[4,3,1,3]:[3,4,k,4];case"dot":case"esriSLSDot":return E?[1,3]:[k,4];case"long-dash":case"esriSLSLongDash":return E?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return E?[8,3,1,3]:[7,4,k,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return E?[8,3,1,3,1,3]:[7,4,k,4,k,4];case"short-dash":case"esriSLSShortDash":return E?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return E?[4,1,1,1]:[3,2,k,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return E?[4,1,1,1,1,1]:[3,2,k,2,k,2];case"short-dot":case"esriSLSShortDot":return E?[1,1]:[k,2];case"solid":case"esriSLSSolid":case"none":return H().error("Unexpected: style does not require rasterization"),[0,0];default:return H().error("Tried to rasterize SLS, but found an unexpected style: ".concat(S,"!")),[0,0]}};const ce=function(S){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100;const k=I/2;let E,G;const F=S;if("circle"===F||"esriSMSCircle"===F){const S=.25;let I=Math.acos(1-S/k),F=Math.ceil(dt/I/4);0===F&&(F=1),I=pt/F,F*=4;const N=[];N.push([k,0]);for(let E=1;E<F;E++)N.push([k*Math.cos(E*I),-k*Math.sin(E*I)]);N.push([k,0]),E={rings:[N]},G={xmin:-k,ymin:-k,xmax:k,ymax:k}}else if("cross"===F||"esriSMSCross"===F){const S=0;E={paths:[[[S,k],[S,-k]],[[k,S],[-k,S]]]},G={xmin:-k,ymin:-k,xmax:k,ymax:k}}else if("diamond"===F||"esriSMSDiamond"===F)E={rings:[[[-k,0],[0,k],[k,0],[0,-k],[-k,0]]]},G={xmin:-k,ymin:-k,xmax:k,ymax:k};else if("square"===F||"esriSMSSquare"===F)E={rings:[[[-k,-k],[-k,k],[k,k],[k,-k],[-k,-k]]]},G={xmin:-k,ymin:-k,xmax:k,ymax:k};else if("x"===F||"esriSMSX"===F)E={paths:[[[k,k],[-k,-k]],[[k,-k],[-k,k]]]},G={xmin:-k,ymin:-k,xmax:k,ymax:k};else if("triangle"===F||"esriSMSTriangle"===F){const S=.5773502691896257*I,k=-S,F=2/3*I,N=F-I;E={rings:[[[k,N],[0,F],[S,N],[k,N]]]},G={xmin:k,ymin:N,xmax:S,ymax:F}}else"arrow"===F&&(E={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},G={xmin:-k,ymin:-k,xmax:k,ymax:k});return[G,E]},me=S=>"vertical"===S||"horizontal"===S||"cross"===S||"esriSFSCross"===S||"esriSFSVertical"===S||"esriSFSHorizontal"===S;function ye(S){if(!S)return null;let I=null;const{cap:k,color:E,join:G,miterLimit:F,style:N,width:D}=S;return"solid"!==N&&"none"!==N&&"esriSLSSolid"!==N&&"esriSLSNull"!==N&&(I=[{type:"CIMGeometricEffectDashes",dashTemplate:ne(N,k),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),{type:"CIMSolidStroke",color:"esriSLSNull"!==N&&"none"!==N?oe(E):[0,0,0,0],capStyle:Z(k),joinStyle:ee(G),miterLimit:F,width:D,effects:I}}},42273:(S,I,k)=>{k.d(I,{I:()=>s,U:()=>F});var E=k(33303),G=k(64032);const F=.03;class s{constructor(){}isEmpty(S){if(!S.nextPoint())return!0;let I,k,E,G;for(I=S.x,k=S.y;S.nextPoint();I=k,k=G)if(E=S.x,G=S.y,E!==I||G!==k)return S.seekPathStart(),!1;return S.seekPathStart(),!0}normalize(S){const I=Math.sqrt(S[0]*S[0]+S[1]*S[1]);0!==I&&(S[0]/=I,S[1]/=I)}getLength(S,I,k,E){const G=k-S,F=E-I;return Math.sqrt(G*G+F*F)}getSegLength(S){const[[I,k],[E,G]]=S;return this.getLength(I,k,E,G)}getCoord2D(S,I,k,E,G){return[S+(k-S)*G,I+(E-I)*G]}getSegCoord2D(S,I){const[[k,E],[G,F]]=S;return this.getCoord2D(k,E,G,F,I)}getAngle(S,I,k,E,G){const F=k-S,N=E-I;return Math.atan2(N,F)}getAngleCS(S,I,k,E,G){const F=k-S,N=E-I,D=Math.sqrt(F*F+N*N);return D>0?[F/D,N/D]:[1,0]}getSegAngleCS(S,I){const[[k,E],[G,F]]=S;return this.getAngleCS(k,E,G,F,I)}cut(S,I,k,E,G,F){return[G<=0?[S,I]:this.getCoord2D(S,I,k,E,G),F>=1?[k,E]:this.getCoord2D(S,I,k,E,F)]}getSubCurve(S,I,k){const G=E.z.createEmptyOptimizedCIM("esriGeometryPolyline");return this.appendSubCurve(G,S,I,k)?G:null}appendSubCurve(S,I,k,E){S.startPath(),I.seekPathStart();let G=0,F=!0;if(!I.nextPoint())return!1;let N=I.x,D=I.y;for(;I.nextPoint();){const X=this.getLength(N,D,I.x,I.y);if(0!==X){if(F){if(G+X>k){const et=(k-G)/X;let st=1,it=!1;G+X>=E&&(st=(E-G)/X,it=!0);const nt=this.cut(N,D,I.x,I.y,et,st);if(nt&&S.pushPoints(nt),it)break;F=!1}}else{if(G+X>E){const k=this.cut(N,D,I.x,I.y,0,(E-G)/X);k&&S.pushPoint(k[1]);break}S.pushXY(I.x,I.y)}G+=X,N=I.x,D=I.y}else N=I.x,D=I.y}return!0}getCIMPointAlong(S,I){if(!S.nextPoint())return null;let k,E,G,F,N=0;for(k=S.x,E=S.y;S.nextPoint();k=G,E=F){G=S.x,F=S.y;const D=this.getLength(k,E,G,F);if(0!==D){if(N+D>I){const S=(I-N)/D;return this.getCoord2D(k,E,G,F,S)}N+=D}}return null}offset(S,I,k,E,F){if(!S||S.length<2)return null;let N=0,D=S[N++],X=N;for(;N<S.length;){const I=S[N];I[0]===D[0]&&I[1]===D[1]||(N!==X&&(S[X]=S[N]),D=S[X++]),N++}const et=S[0][0]===S[X-1][0]&&S[0][1]===S[X-1][1];if(et&&--X,X<(et?3:2))return null;const st=[];D=et?S[X-1]:null;let it=S[0];for(let nt=0;nt<X;nt++){const F=nt===X-1?et?S[0]:null:S[nt+1];if(D)if(F){const S=[F[0]-it[0],F[1]-it[1]];this.normalize(S);const N=[it[0]-D[0],it[1]-D[1]];this.normalize(N);const X=N[0]*S[1]-N[1]*S[0],et=N[0]*S[0]+N[1]*S[1];if(0===X&&1===et){it=F;continue}if(X>=0==I<=0){if(et<1){const k=[S[0]-N[0],S[1]-N[1]];this.normalize(k);const G=Math.sqrt((1+et)/2);if(G>1/E){const S=-Math.abs(I)/G;st.push([it[0]-k[0]*S,it[1]-k[1]*S])}}}else switch(k){case G.xw.Mitered:{const k=Math.sqrt((1+et)/2);if(k>0&&1/k<E){const E=[S[0]-N[0],S[1]-N[1]];this.normalize(E);const G=Math.abs(I)/k;st.push([it[0]-E[0]*G,it[1]-E[1]*G]);break}}case G.xw.Bevelled:st.push([it[0]+N[1]*I,it[1]-N[0]*I]),st.push([it[0]+S[1]*I,it[1]-S[0]*I]);break;case G.xw.Rounded:if(et<1){st.push([it[0]+N[1]*I,it[1]-N[0]*I]);const k=Math.floor(2.5*(1-et));if(k>0){const E=1/k;let G=E;for(let F=1;F<k;F++,G+=E){const k=[N[1]*(1-G)+S[1]*G,-N[0]*(1-G)-S[0]*G];this.normalize(k),st.push([it[0]+k[0]*I,it[1]+k[1]*I])}}st.push([it[0]+S[1]*I,it[1]-S[0]*I])}break;case G.xw.Square:default:if(X<0)st.push([it[0]+(N[1]+N[0])*I,it[1]+(N[1]-N[0])*I]),st.push([it[0]+(S[1]-S[0])*I,it[1]-(S[0]+S[1])*I]);else{const k=Math.sqrt((1+Math.abs(et))/2),E=[S[0]-N[0],S[1]-N[1]];this.normalize(E);const G=I/k;st.push([it[0]-E[0]*G,it[1]-E[1]*G])}}}else{const S=[it[0]-D[0],it[1]-D[1]];this.normalize(S),st.push([it[0]+S[1]*I,it[1]-S[0]*I])}else{const S=[F[0]-it[0],F[1]-it[1]];this.normalize(S),st.push([it[0]+S[1]*I,it[1]-S[0]*I])}D=it,it=F}return st.length<(et?3:2)?null:(et&&st.push([st[0][0],st[0][1]]),st)}}},94042:(S,I,k)=>{k.d(I,{VA:()=>i,YQ:()=>F,Z1:()=>o,ps:()=>h});var E=k(33303),G=k(42273);class i{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(S,I){let k=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(this._setEmpty(),!S||0===S.length)return!1;for(let E=0;E<S.length;E++){let I=Math.abs(S[E]);k&&I<1e-7&&(I=1e-7),this._values.push(I),this._length+=I}return I&&1&S.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(S){const I=this._values?this._values.length:0;for(let k=0;k<I;++k)this._values[k]*=S;this._length*=S,this.extPtGap*=S,this.ctrlPtGap*=S}addValue(S){this._length+=S,this._values.push(S)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class h{constructor(){this.pt=null,this.ca=0,this.sa=0}}var F;!function(S){S[S.FAIL=0]="FAIL",S[S.END=1]="END",S[S.CONTINUE=2]="CONTINUE"}(F||(F={}));class a{constructor(){this.reset()}reset(){this.segment=null,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return null!==this.segment}copyTo(S){S.segment=this.segment,S.segmentLength=this.segmentLength,S.abscissa=this.abscissa,S.isPathEnd=this.isPathEnd,S.isPartEnd=this.isPartEnd}}class o extends G.I{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),this._tolerance=G.U,this._currentPosition=new a}updateTolerance(S){this._tolerance=G.U*S}init(S,I){return!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?(this._patternLength=I.length(),this._partExtPtGap=I.extPtGap,this._partCtrlPtGap=I.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._pathCursor=S,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(S){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.FAIL;const k=new a;return!!this._nextPosition(S,k,null,I)&&(k.copyTo(this._currentPosition),!0)}curPointAndAngle(S){S.pt=this._getPoint(this._currentPosition);const[I,k]=this._getAngleCS(this._currentPosition);S.ca=I,S.sa=k}nextPointAndAngle(S,I){let k=arguments.length>2&&void 0!==arguments[2]?arguments[2]:F.FAIL;const E=new a;if(!this._nextPosition(S,E,null,k))return!1;E.copyTo(this._currentPosition),I.pt=this._getPoint(E);const[G,N]=this._getAngleCS(E);return I.ca=G,I.sa=N,!0}nextCurve(S){if(0===S)return null;const I=E.z.createEmptyOptimizedCIM("esriGeometryPolyline");I.startPath(),I.nextPath();const k=new a;return this._nextPosition(S,k,I,F.END)?(k.copyTo(this._currentPosition),I):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){return this._currentPosition.segment[1]}getPt(S){return this._pathCursor.seekInPath(S),[this._pathCursor.x,this._pathCursor.y]}getSeg(S){return[this.getPt(S),this.getPt(S+1)]}_nextPosition(S,I,k,E){if(this._currentPosition.isPathEnd)return!1;let G=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(G/=this._currentPosition.segmentLength),this._currentPosition.copyTo(I);I.abscissa+S*this._partLengthRatio>I.segmentLength+this._tolerance;){if(k){if(0===k.pathSize)if(0===G){const S=I.segment[0];k.pushXY(S[0],S[1])}else k.pushPoint(this.getSegCoord2D(I.segment,G));const S=I.segment[1];k.pushXY(S[0],S[1])}if(G=0,S-=(I.segmentLength-I.abscissa)/this._partLengthRatio,this._partSegCount)I.segment=this._nextSegment(),I.segmentLength=this.getSegLength(I.segment),I.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return E!==F.FAIL&&(I.segmentLength=this.getSegLength(I.segment),I.isPartEnd=!0,E===F.END?(I.abscissa=I.segmentLength,I.isPathEnd=!0):I.abscissa=I.segmentLength+S,!0);this._currentPosition.copyTo(I)}}if(I.abscissa+=S*this._partLengthRatio,k){0===k.pathSize&&(0===G?k.pushPoint(I.segment[0]):k.pushPoint(this.getSegCoord2D(I.segment,G)));const S=I.abscissa/I.segmentLength;1===S?k.pushPoint(I.segment[1]):k.pushPoint(this.getSegCoord2D(I.segment,S))}return this._partSegCount||Math.abs(I.abscissa-I.segmentLength)<this._tolerance&&(I.isPathEnd=this._partIsLast,I.isPartEnd=!0),!0}_getPoint(S){const I=S.segmentLength<=0?0:S.abscissa/S.segmentLength;return this.getSegCoord2D(this._currentPosition.segment,I)}_getAngleCS(S){const I=S.segmentLength<=0?0:S.abscissa/S.segmentLength;return this.getSegAngleCS(this._currentPosition.segment,I)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.getSegLength(this._nextSegment()),this._partSegCount++,this._pathCursor.getControlPointAt(this._getEndPointIndex())){this._partIsLast=!this._hasNextSegment();break}let S=this._partSegCount;for(;S;)this._previousSegment(),--S;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.getSegLength(this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const I=this._getStartPointIndex();this._ctrlPtBegin=this._pathCursor.getControlPointAt(I);let k=I+this._partSegCount+1;if(k>=this._pathCursor.pathSize&&(k=0),this._ctrlPtEnd=this._pathCursor.getControlPointAt(k),this._patternLength>0){const S=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,I=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let k=Math.round((this._partLength-(S+I))/this._patternLength);k<=0&&(k=S+I>0?0:1),this._partLengthRatio=this._partLength/(S+I+k*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._pathCursor.pathSize-2}_previousSegment(){return this.getSeg(--this._seg)}_nextSegment(){return this.getSeg(++this._seg)}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}},29470:(S,I,k)=>{k.d(I,{A:()=>t});class t{constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,k=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.x=S,this.y=I,this.width=k,this.height=E}static fromExtent(S){return new t(S.xmin,-S.ymax,S.xmax-S.xmin,S.ymax-S.ymin)}get isEmpty(){return this.width<=0||this.height<=0}union(S){this.x=Math.min(this.x,S.x),this.y=Math.min(this.y,S.y),this.width=Math.max(this.width,S.width),this.height=Math.max(this.height,S.height)}}},20665:(S,I,k)=>{k.d(I,{N:()=>e});class e{static local(){return null===e.instance&&(e.instance=new e),e.instance}execute(S,I,k,E,G){return new t(S,I,k)}}e.instance=null;class t{constructor(S,I,k){this._inputGeometries=S,this._angleTolerance=void 0!==I.angleTolerance?I.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let S=this._inputGeometries.next();for(;S;){if("esriGeometryPolygon"===S.geometryType)this._isClosed=!0;else if("esriGeometryPolyline"===S.geometryType)this._isClosed=!1;else{if("esriGeometryEnvelope"!==S.geometryType){S=this._inputGeometries.next();continue}if(this._maxCosAngle)return S;this._isClosed=!0}for(;S.nextPath();)this._processPath(S);return S.reset(),S}return null}_processPath(S){if(S.nextPoint()){const I=S.x,k=S.y;let E=I,G=k,F=S.pathSize,N=0,D=0,X=0,et=0,st=0,it=0;this._isClosed&&++F;for(let nt=1;S.nextPoint()||nt<F;++nt){let ot,at;this._isClosed&&nt===F-1?(ot=I,at=k):(ot=S.x,at=S.y);const ht=ot-E,lt=at-G,ct=Math.sqrt(ht*ht+lt*lt);nt>1&&ct>0&&X>0&&(N*ht+D*lt)/ct/X<=this._maxCosAngle&&S.setControlPointAt(nt-1),1===nt&&(et=ht,st=lt,it=ct),ct>0&&(E=ot,G=at,N=ht,D=lt,X=ct)}this._isClosed&&X>0&&it>0&&(N*et+D*st)/it/X<=this._maxCosAngle&&S.setControlPointAt(0)}}}},77045:(S,I,k)=>{k.d(I,{B:()=>p});var E=k(33303),G=k(46164),F=k(47463),N=k(42273),D=k(64032);const X=1.7320508075688772,et=D.oF.OpenEnded;class p{static local(){return null===p.instance&&(p.instance=new p),p.instance}execute(S,I,k,E,G){return new P(S,I,k)}}p.instance=null;class P extends F.rx{constructor(S,I,k){super(S,!1,!0),this._curveHelper=new N.I,this._width=(void 0!==I.width?I.width:5)*k,this._arrowType=void 0!==I.geometricEffectArrowType?I.geometricEffectArrowType:void 0!==I.arrowType?I.arrowType:et,this._offsetFlattenError=N.U*k}processPath(S){const I=E.z.createEmptyOptimizedCIM(S.geometryType);switch(this._arrowType){case D.oF.OpenEnded:default:this._constructSimpleArrow(I,S,!0);break;case D.oF.Block:this._constructSimpleArrow(I,S,!1);break;case D.oF.Crossed:this._constructCrossedArrow(I,S)}return I}_constructSimpleArrow(S,I,k){const E=I.pathLength();let F=this._width;E<2*F&&(F=E/2);const N=this._curveHelper.getSubCurve(I,0,E-F);if(!N||!N.nextPath())return;N.seekPathStart();const D=F/2;if(this._curveHelper.isEmpty(N))return;const X=(0,G.A)(N),et=this._constructOffset(X,-D);if(!et)return;const st=this._constructOffset(X,D);if(!st)return;const it=this._constructArrowBasePoint(et,-D/2);if(!it)return;const nt=this._constructArrowBasePoint(st,D/2);if(!nt)return;I.seekInPath(I.pathSize-1);const ot=[I.x,I.y];S.pushPath(st),S.nextPath(),S.nextPoint(),S.setControlPoint(),S.pushPoint(nt),S.nextPoint(),S.setControlPoint(),S.pushPoint(ot),S.nextPoint(),S.setControlPoint(),S.pushPoint(it),S.nextPoint(),S.setControlPoint(),S.pushPoints(et.reverse()),S.setControlPoint(),k||(S.setControlPointAt(0),S.setControlPointAt(S.pathSize-1),S.pushPoint(st[0])),S.reset()}_constructCrossedArrow(S,I){const k=I.pathLength();let E=this._width;k<E*(1+X+1)&&(E=k/(1+X+1)),I.seekPathStart();const F=this._curveHelper.getSubCurve(I,0,k-E*(1+X));if(!F)return;F.nextPath();const N=E/2;if(this._curveHelper.isEmpty(F))return;const D=(0,G.A)(F),et=this._constructOffset(D,N);if(!et)return;const st=this._constructOffset(D,-N);if(!st)return;const it=this._curveHelper.getSubCurve(I,0,k-E);if(!it)return;if(it.nextPath(),this._curveHelper.isEmpty(it))return;const nt=(0,G.A)(it),ot=this._constructOffset(nt,N);if(!ot)return;const at=this._constructOffset(nt,-N);if(!at)return;const ht=ot[ot.length-1],lt=this._constructArrowBasePoint(ot,N/2);if(!lt)return;const ct=at[at.length-1],ut=this._constructArrowBasePoint(at,-N/2);if(!ut)return;I.seekInPath(I.pathSize-1);const _t=[I.x,I.y];S.pushPath(et),S.nextPath(),S.nextPoint(),S.setControlPoint(),S.pushPoint(ct),S.nextPoint(),S.setControlPoint(),S.pushPoint(ut),S.nextPoint(),S.setControlPoint(),S.pushPoint(_t),S.nextPoint(),S.setControlPoint(),S.pushPoint(lt),S.nextPoint(),S.setControlPoint(),S.pushPoint(ht),S.nextPoint(),S.setControlPoint(),S.pushPoints(st.reverse()),S.nextPoint(),S.setControlPoint(),S.reset()}_constructOffset(S,I){return this._curveHelper.offset(S,I,D.xw.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(S,I){if(!S||S.length<2)return null;const k=S[S.length-2],E=S[S.length-1],G=[E[0]-k[0],E[1]-k[1]];return this._curveHelper.normalize(G),[E[0]+G[1]*I,E[1]-G[0]*I]}}},18356:(S,I,k)=>{k.d(I,{s:()=>m});k(30174);var E=k(33303),G=k(46164),F=k(73619),N=k(42273),D=k(64032),X=k(98664);class m{static local(){return null===m.instance&&(m.instance=new m),m.instance}execute(S,I,k,E,G,F){return new l(S,I,k,E,G,F)}}m.instance=null;class l{constructor(S,I,k,E,G,F){this._inputGeometries=S,this._tileKey=E,this._geometryEngine=G,this._curveHelper=new N.I,this._size=(void 0!==I.size?I.size:1)*k,this._maxInflateSize=F*k,this._offsetFlattenError=N.U*k}next(){let S;for(;S=this._inputGeometries.next();){if(0===this._size)return S;if("esriGeometryEnvelope"===S.geometryType)if(this._size>0){const I=E.z.createEmptyOptimizedCIM(S.geometryType),k=(0,G.x)(S)[0],F=this._curveHelper.offset(k,this._size,D.xw.Rounded,4,this._offsetFlattenError);if(F)return I.pushPath(F),I}else if(this._size<0){const I=S.asJSON();if(Math.min(I.xmax-I.xmin,I.ymax-I.ymin)+2*this._size>0)return E.z.fromJSONCIM({xmin:I.xmin-this._size,xmax:I.xmax+this._size,ymin:I.ymin-this._size,ymax:I.ymax+this._size})}const I=this._geometryEngine;if(null==I)return null;const k=this._tileKey?(0,F.q)(S,this._maxInflateSize):S;if(!k)continue;const N=I.buffer(X.A.WebMercator,k.asJSON(),this._size,1);return N?E.z.fromJSONCIM(N):null}return null}}},5139:(S,I,k)=>{k.d(I,{v:()=>e});var E=k(33303),G=k(46164),F=k(47463),N=k(64032);class e{static local(){return null===e.instance&&(e.instance=new e),e.instance}execute(S,I,k,E,G){return new r(S,I,k)}}e.instance=null;class r{constructor(S,I,k){var E;this._defaultPointSize=20,this._inputGeometries=S,this._geomUnitsPerPoint=k,this._rule=null!==(E=I.rule)&&void 0!==E?E:N.uQ.FullGeometry,this._defaultSize=this._defaultPointSize*k}next(){let S;for(;S=this._inputGeometries.next();){const I=this._processGeom((0,G.x)(S));if(I&&I.length)return E.z.fromJSONCIM({paths:I})}return null}_clone(S){return[S[0],S[1]]}_mid(S,I){return[(S[0]+I[0])/2,(S[1]+I[1])/2]}_mix(S,I,k,E){return[S[0]*I+k[0]*E,S[1]*I+k[1]*E]}_add(S,I){return[S[0]+I[0],S[1]+I[1]]}_add2(S,I,k){return[S[0]+I,S[1]+k]}_sub(S,I){return[S[0]-I[0],S[1]-I[1]]}_dist(S,I){return Math.sqrt((S[0]-I[0])*(S[0]-I[0])+(S[1]-I[1])*(S[1]-I[1]))}_norm(S){return Math.sqrt(S[0]*S[0]+S[1]*S[1])}_normalize(S){const I=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)/this._norm(S);S[0]*=I,S[1]*=I}_leftPerpendicular(S){const I=-S[1],k=S[0];S[0]=I,S[1]=k}_leftPerp(S){return[-S[1],S[0]]}_rightPerpendicular(S){const I=S[1],k=-S[0];S[0]=I,S[1]=k}_rightPerp(S){return[S[1],-S[0]]}_dotProduct(S,I){return S[0]*I[0]+S[1]*I[1]}_crossProduct(S,I){return S[0]*I[1]-S[1]*I[0]}_rotateDirect(S,I,k){const E=S[0]*I-S[1]*k,G=S[0]*k+S[1]*I;S[0]=E,S[1]=G}_makeCtrlPt(S){const I=[S[0],S[1]];return(0,F.Aq)(I,1),I}_addAngledTicks(S,I,k,E){const G=this._sub(k,I);this._normalize(G);const F=this._crossProduct(G,this._sub(E,I));let N;N=F>0?this._rightPerp(G):this._leftPerp(G);const D=Math.abs(F)/2,X=[];X.push([I[0]+(N[0]-G[0])*D,I[1]+(N[1]-G[1])*D]),X.push(I),X.push(k),X.push([k[0]+(N[0]+G[0])*D,k[1]+(N[1]+G[1])*D]),S.push(X)}_addBezier2(S,I,k,E,G){if(0==G--)return void S.push(E);const F=this._mid(I,k),N=this._mid(k,E),D=this._mid(F,N);this._addBezier2(S,I,F,D,G),this._addBezier2(S,D,N,E,G)}_addBezier3(S,I,k,E,G,F){if(0==F--)return void S.push(G);const N=this._mid(I,k),D=this._mid(k,E),X=this._mid(E,G),et=this._mid(N,D),st=this._mid(D,X),it=this._mid(et,st);this._addBezier3(S,I,N,et,it,F),this._addBezier3(S,it,st,X,G,F)}_add90DegArc(S,I,k,E,G){const F=null!==G&&void 0!==G?G:this._crossProduct(this._sub(k,I),this._sub(E,I))>0,N=this._mid(I,k),D=this._sub(N,I);F?this._leftPerpendicular(D):this._rightPerpendicular(D),N[0]+=D[0],N[1]+=D[1],this._addBezier3(S,I,this._mix(I,.33333,N,.66667),this._mix(k,.33333,N,.66667),k,4)}_addArrow(S,I,k){const E=I[0],G=I[1],F=I[I.length-1],N=this._sub(E,G);this._normalize(N);const D=this._crossProduct(N,this._sub(F,G)),X=.5*D,et=this._leftPerp(N),st=[F[0]-et[0]*D,F[1]-et[1]*D],it=I.length-1,nt=[];nt.push(k?[-et[0],-et[1]]:et);let ot=[-N[0],-N[1]];for(let at=1;at<it-1;at++){const S=this._sub(I[at+1],I[at]);this._normalize(S);const k=this._dotProduct(S,ot),E=this._crossProduct(S,ot),G=Math.sqrt((1+k)/2),F=this._sub(S,ot);this._normalize(F),F[0]/=G,F[1]/=G,nt.push(E<0?[-F[0],-F[1]]:F),ot=S}nt.push(this._rightPerp(ot));for(let at=nt.length-1;at>0;at--)S.push([I[at][0]+nt[at][0]*X,I[at][1]+nt[at][1]*X]);S.push([st[0]+nt[0][0]*X,st[1]+nt[0][1]*X]),S.push([st[0]+nt[0][0]*D,st[1]+nt[0][1]*D]),S.push(E),S.push([st[0]-nt[0][0]*D,st[1]-nt[0][1]*D]),S.push([st[0]-nt[0][0]*X,st[1]-nt[0][1]*X]);for(let at=1;at<nt.length;at++)S.push([I[at][0]-nt[at][0]*X,I[at][1]-nt[at][1]*X])}_cp2(S,I,k){return S.length>=2?S[1]:this._add2(S[0],I*this._defaultSize,k*this._defaultSize)}_cp3(S,I,k,E){if(S.length>=3)return S[2];const G=this._mix(S[0],1-k,I,k),F=this._sub(I,S[0]);return this._normalize(F),this._rightPerpendicular(F),[G[0]+F[0]*E*this._defaultSize,G[1]+F[1]*E*this._defaultSize]}_arrowPath(S){if(S.length>2)return S;const I=S[0],k=this._cp2(S,-4,0),E=this._sub(I,k);this._normalize(E);const G=this._rightPerp(E);return[I,k,[I[0]+(G[0]-E[0])*this._defaultSize,I[1]+(G[1]-E[1])*this._defaultSize]]}_arrowLastSeg(S){const I=S[0],k=this._cp2(S,-4,0);let E;if(S.length>=3)E=S[S.length-1];else{const S=this._sub(I,k);this._normalize(S);const G=this._rightPerp(S);E=[I[0]+(G[0]-S[0])*this._defaultSize,I[1]+(G[1]-S[1])*this._defaultSize]}return[k,E]}_processGeom(S){if(!S)return null;const I=[];for(const k of S){if(!k||0===k.length)continue;const S=k.length;let E=k[0];switch(this._rule){case N.uQ.PerpendicularFromFirstSegment:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,4),F=[];F.push(G),F.push(this._mid(E,S)),I.push(F);break}case N.uQ.ReversedFirstSegment:{const S=this._cp2(k,0,-1);I.push([S,E]);break}case N.uQ.PerpendicularToSecondSegment:{const S=this._cp2(k,-4,1),G=this._cp3(k,S,.882353,-1.94),F=[];F.push(this._mid(S,G)),F.push(E),I.push(F);break}case N.uQ.SecondSegmentWithTicks:{const S=this._cp2(k,-4,1),G=this._cp3(k,S,.882353,-1.94),F=this._sub(G,S);let N;N=this._crossProduct(F,this._sub(E,S))>0?this._rightPerp(N):this._leftPerp(F);const D=[];D.push([S[0]+(N[0]-F[0])/3,S[1]+(N[1]-F[1])/3]),D.push(S),D.push(G),D.push([G[0]+(N[0]+F[0])/3,G[1]+(N[1]+F[1])/3]),I.push(D);break}case N.uQ.DoublePerpendicular:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,3),F=this._mid(E,S),N=this._sub(F,G);this._normalize(N);const D=this._crossProduct(N,this._sub(E,G));this._leftPerpendicular(N);const X=[];X.push(E),X.push([G[0]+N[0]*D,G[1]+N[1]*D]),I.push(X);const et=[];et.push([G[0]-N[0]*D,G[1]-N[1]*D]),et.push(S),I.push(et);break}case N.uQ.OppositeToFirstSegment:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,3),F=this._mid(E,S),N=this._sub(F,G);this._normalize(N);const D=this._crossProduct(N,this._sub(E,G));this._leftPerpendicular(N);const X=[];X.push([G[0]+N[0]*D,G[1]+N[1]*D]),X.push([G[0]-N[0]*D,G[1]-N[1]*D]),I.push(X);break}case N.uQ.TriplePerpendicular:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,4),F=this._mid(E,S),N=this._sub(F,G);this._normalize(N);const D=this._crossProduct(N,this._sub(E,G));this._leftPerpendicular(N);const X=[];X.push([G[0]+N[0]*D*.8,G[1]+N[1]*D*.8]),X.push([F[0]+.8*(E[0]-F[0]),F[1]+.8*(E[1]-F[1])]),I.push(X),I.push([G,F]);const et=[];et.push([G[0]-N[0]*D*.8,G[1]-N[1]*D*.8]),et.push([F[0]+.8*(S[0]-F[0]),F[1]+.8*(S[1]-F[1])]),I.push(et);break}case N.uQ.HalfCircleFirstSegment:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,4),F=this._mid(E,S);let N=this._sub(S,E);const D=Math.cos(Math.PI/18),X=Math.sin(Math.PI/18),et=Math.sqrt((1+D)/2),st=Math.sqrt((1-D)/2),it=[];let nt;this._crossProduct(N,this._sub(G,E))>0?(it.push(E),N=this._sub(E,F),nt=S):(it.push(S),N=this._sub(S,F),nt=E),this._rotateDirect(N,et,st),N[0]/=et,N[1]/=et;for(let I=1;I<=18;I++)it.push(this._add(F,N)),this._rotateDirect(N,D,X);it.push(nt),I.push(it);break}case N.uQ.HalfCircleSecondSegment:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,1,-1);let F=this._sub(E,S);this._normalize(F);const N=this._crossProduct(F,this._sub(G,S))/2;this._leftPerpendicular(F);const D=[S[0]+F[0]*N,S[1]+F[1]*N];F=this._sub(S,D);const X=Math.cos(Math.PI/18);let et=Math.sin(Math.PI/18);N>0&&(et=-et);const st=[S];for(let I=1;I<=18;I++)this._rotateDirect(F,X,et),st.push(this._add(D,F));I.push(st);break}case N.uQ.HalfCircleExtended:{const G=this._cp2(k,0,-2),F=this._cp3(k,G,1,-1);let N;if(S>=4)N=k[3];else{const S=this._sub(E,G);N=this._add(F,S)}const D=this._dist(G,F)/2/.75,X=this._sub(G,E);this._normalize(X,D);const et=this._sub(F,N);this._normalize(et,D);const st=[N,F];I.push(st);const it=[this._clone(F)];this._addBezier3(it,F,this._add(F,et),this._add(G,X),G,4),it.push(E),I.push(it);break}case N.uQ.OpenCircle:{const S=this._cp2(k,-2,0),G=this._sub(S,E),F=Math.cos(Math.PI/18),N=-Math.sin(Math.PI/18),D=[S];for(let I=1;I<=33;I++)this._rotateDirect(G,F,N),D.push(this._add(E,G));I.push(D);break}case N.uQ.CoverageEdgesWithTicks:{const G=this._cp2(k,0,-1);let F,N;if(S>=3)F=k[2];else{const S=this._sub(G,E),I=this._leftPerp(S);F=[E[0]+I[0]-.25*S[0],E[1]+I[1]-.25*S[1]]}if(S>=4)N=k[3];else{const S=this._mid(E,G),I=this._sub(E,G);this._normalize(I),this._leftPerpendicular(I);const k=this._crossProduct(I,this._sub(F,S));this._rightPerpendicular(I),N=[F[0]+I[0]*k*2,F[1]+I[1]*k*2]}const D=this._sub(G,E);let X,et;X=this._crossProduct(D,this._sub(F,E))>0?this._rightPerp(D):this._leftPerp(D),et=[],et.push(F),et.push(E),et.push([E[0]+(X[0]-D[0])/3,E[1]+(X[1]-D[1])/3]),I.push(et),X=this._crossProduct(D,this._sub(N,G))>0?this._rightPerp(X):this._leftPerp(D),et=[],et.push([G[0]+(X[0]+D[0])/3,G[1]+(X[1]+D[1])/3]),et.push(G),et.push(N),I.push(et);break}case N.uQ.GapExtentWithDoubleTicks:{const G=this._cp2(k,0,2),F=this._cp3(k,G,0,1);let N;if(S>=4)N=k[3];else{const S=this._sub(G,E);N=this._add(F,S)}this._addAngledTicks(I,E,G,this._mid(F,N)),this._addAngledTicks(I,F,N,this._mid(E,G));break}case N.uQ.GapExtentMidline:{const G=this._cp2(k,2,0),F=this._cp3(k,G,0,1);let N;if(S>=4)N=k[3];else{const S=this._sub(G,E);N=this._add(F,S)}const D=[];D.push(this._mid(E,F)),D.push(this._mid(G,N)),I.push(D);break}case N.uQ.Chevron:{const G=this._cp2(k,-1,-1);let F;if(S>=3)F=k[2];else{const S=this._sub(G,E);this._leftPerpendicular(S),F=this._add(E,S)}I.push([G,this._makeCtrlPt(E),F]);break}case N.uQ.PerpendicularWithArc:{const S=this._cp2(k,0,-2),G=this._cp3(k,S,.5,-1);let F=this._sub(S,E);const N=this._norm(F);F[0]/=N,F[1]/=N;const D=this._crossProduct(F,this._sub(G,E));let X=this._dotProduct(F,this._sub(G,E));X<.05*N?X=.05*N:X>.95*N&&(X=.95*N);const et=[E[0]+F[0]*X,E[1]+F[1]*X];this._leftPerpendicular(F);let st=[];st.push([et[0]-F[0]*D,et[1]-F[1]*D]),st.push([et[0]+F[0]*D,et[1]+F[1]*D]),I.push(st);const it=[S[0]+F[0]*D,S[1]+F[1]*D];F=this._sub(S,it);const nt=Math.cos(Math.PI/18);let ot=Math.sin(Math.PI/18);D<0&&(ot=-ot),st=[E,S];for(let I=1;I<=9;I++)this._rotateDirect(F,nt,ot),st.push(this._add(it,F));I.push(st);break}case N.uQ.ClosedHalfCircle:{const S=this._cp2(k,2,0),G=this._mid(E,S),F=this._sub(S,G),N=Math.cos(Math.PI/18),D=Math.sin(Math.PI/18),X=[E,S];for(let I=1;I<=18;I++)this._rotateDirect(F,N,D),X.push(this._add(G,F));I.push(X);break}case N.uQ.TripleParallelExtended:{const S=this._cp2(k,0,-2),G=this._cp3(k,S,1,-2),N=this._mid(E,S),D=this._sub(G,S);this._normalize(D);const X=Math.abs(this._crossProduct(D,this._sub(N,S)))/2,et=this._dist(S,G),st=[S,E];st.push([E[0]+D[0]*et*.5,E[1]+D[1]*et*.5]),I.push(st);const it=[];it.push([N[0]-D[0]*X,N[1]-D[1]*X]),it.push([N[0]+D[0]*et*.375,N[1]+D[1]*et*.375]),(0,F.Aq)(it[it.length-1],1),it.push([N[0]+D[0]*et*.75,N[1]+D[1]*et*.75]),I.push(it);const nt=[S,G];I.push(nt);break}case N.uQ.ParallelWithTicks:{const S=this._cp2(k,3,0),G=this._cp3(k,S,.5,-1),F=this._sub(G,S);this._normalize(F);const N=this._crossProduct(F,this._sub(G,E));this._leftPerpendicular(F),this._addAngledTicks(I,E,S,G),this._addAngledTicks(I,this._mix(E,1,F,N),this._mix(S,1,F,N),this._mid(E,S));break}case N.uQ.Parallel:{const S=this._cp2(k,3,0),G=this._cp3(k,S,.5,-1),F=this._sub(S,E);this._normalize(F);const N=this._leftPerp(F),D=this._crossProduct(F,this._sub(G,E));let X=[E,S];I.push(X),X=[],X.push([E[0]+N[0]*D,E[1]+N[1]*D]),X.push([S[0]+N[0]*D,S[1]+N[1]*D]),I.push(X);break}case N.uQ.PerpendicularToFirstSegment:{const S=this._cp2(k,3,0),G=this._cp3(k,S,.5,-1),F=this._mid(E,S),N=this._sub(S,E);this._normalize(N);const D=this._crossProduct(N,this._sub(G,E));this._leftPerpendicular(N);const X=[];X.push([F[0]-N[0]*D*.25,F[1]-N[1]*D*.25]),X.push([F[0]+N[0]*D*1.25,F[1]+N[1]*D*1.25]),I.push(X);break}case N.uQ.ParallelOffset:{const S=this._cp2(k,3,0),G=this._cp3(k,S,.5,-1),F=this._sub(S,E);this._normalize(F);const N=this._crossProduct(F,this._sub(G,E));this._leftPerpendicular(F);const D=[];D.push([E[0]-F[0]*N,E[1]-F[1]*N]),D.push([S[0]-F[0]*N,S[1]-F[1]*N]),I.push(D);const X=[];X.push([E[0]+F[0]*N,E[1]+F[1]*N]),X.push([S[0]+F[0]*N,S[1]+F[1]*N]),I.push(X);break}case N.uQ.OffsetOpposite:{const S=this._cp2(k,3,0),G=this._cp3(k,S,.5,-1),F=this._sub(S,E);this._normalize(F);const N=this._crossProduct(F,this._sub(G,E));this._leftPerpendicular(F);const D=[];D.push([E[0]-F[0]*N,E[1]-F[1]*N]),D.push([S[0]-F[0]*N,S[1]-F[1]*N]),I.push(D);break}case N.uQ.OffsetSame:{const S=this._cp2(k,3,0),G=this._cp3(k,S,.5,-1),F=this._sub(S,E);this._normalize(F);const N=this._crossProduct(F,this._sub(G,E));this._leftPerpendicular(F);const D=[];D.push([E[0]+F[0]*N,E[1]+F[1]*N]),D.push([S[0]+F[0]*N,S[1]+F[1]*N]),I.push(D);break}case N.uQ.CircleWithArc:{let G=this._cp2(k,3,0);const N=this._cp3(k,G,.5,-1);let D,X;if(S>=4)D=k[3],X=this._crossProduct(this._sub(D,G),this._sub(N,G))>0;else{D=G,X=this._crossProduct(this._sub(D,E),this._sub(N,E))>0;const S=24*this._geomUnitsPerPoint,I=this._sub(D,E);this._normalize(I,S);const k=Math.sqrt(2)/2;this._rotateDirect(I,k,X?k:-k),G=this._add(E,I)}const et=this._sub(G,E),st=Math.cos(Math.PI/18),it=Math.sin(Math.PI/18),nt=[G];for(let S=1;S<=36;S++)this._rotateDirect(et,st,it),nt.push(this._add(E,et));this._add90DegArc(nt,G,D,N,X),(0,F.Aq)(nt[nt.length-8],1),I.push(nt);break}case N.uQ.DoubleJog:{let G,F,N=this._cp2(k,-3,1);if(G=S>=3?k[2]:this._add(E,this._sub(E,N)),S>=4)F=k[3];else{const S=E;E=N,F=G;const I=this._dist(E,S),k=this._dist(F,S);let D=30*this._geomUnitsPerPoint;.5*I<D&&(D=.5*I),.5*k<D&&(D=.5*k),N=this._mix(E,D/I,S,(I-D)/I),G=this._mix(F,D/k,S,(k-D)/k)}const D=this._mid(E,N),X=this._mid(F,G),et=this._dist(E,N),st=this._dist(G,F);let it=Math.min(et,st)/8;it=Math.min(it,24*this._geomUnitsPerPoint);const nt=Math.cos(Math.PI/4);let ot=this._sub(E,N);this._normalize(ot,it),this._crossProduct(ot,this._sub(F,N))>0?this._rotateDirect(ot,nt,-nt):this._rotateDirect(ot,nt,nt);let at=[];at.push(N),at.push(this._add(D,ot)),at.push(this._sub(D,ot)),at.push(E),I.push(at),ot=this._sub(F,G),this._normalize(ot,it),this._crossProduct(ot,this._sub(E,G))<0?this._rotateDirect(ot,nt,nt):this._rotateDirect(ot,nt,-nt),at=[],at.push(G),at.push(this._add(X,ot)),at.push(this._sub(X,ot)),at.push(F),I.push(at);break}case N.uQ.PerpendicularOffset:{const S=this._cp2(k,-4,1),G=this._cp3(k,S,.882353,-1.94),F=this._sub(G,S);this._crossProduct(F,this._sub(E,S))>0?this._rightPerpendicular(F):this._leftPerpendicular(F);const N=[F[0]/8,F[1]/8],D=this._sub(this._mid(S,G),N);I.push([D,E]);break}case N.uQ.LineExcludingLastSegment:{const S=this._arrowPath(k),E=[];let G=S.length-2;for(;G--;)E.push(S[G]);I.push(E);break}case N.uQ.MultivertexArrow:{const S=this._arrowPath(k),E=[];this._addArrow(E,S,!1),I.push(E);break}case N.uQ.CrossedArrow:{const S=this._arrowPath(k),E=[];this._addArrow(E,S,!0),I.push(E);break}case N.uQ.ChevronArrow:{const[S,G]=this._arrowLastSeg(k),F=10*this._geomUnitsPerPoint,N=this._sub(E,S);this._normalize(N);const D=this._crossProduct(N,this._sub(G,S)),X=this._leftPerp(N),et=[G[0]-X[0]*D*2,G[1]-X[1]*D*2],st=[];st.push([G[0]+N[0]*F,G[1]+N[1]*F]),st.push(E),st.push([et[0]+N[0]*F,et[1]+N[1]*F]),I.push(st);break}case N.uQ.ChevronArrowOffset:{const[S,G]=this._arrowLastSeg(k),F=this._sub(E,S);this._normalize(F);const N=this._crossProduct(F,this._sub(G,S));this._leftPerpendicular(F);const D=[G[0]-F[0]*N,G[1]-F[1]*N],X=[];X.push([D[0]+F[0]*N*.5,D[1]+F[1]*N*.5]),X.push(this._mid(D,E)),X.push([D[0]-F[0]*N*.5,D[1]-F[1]*N*.5]),I.push(X);break}case N.uQ.PartialFirstSegment:{const[S,G]=this._arrowLastSeg(k),F=this._sub(E,S);this._normalize(F);const N=this._crossProduct(F,this._sub(G,S));this._leftPerpendicular(F);const D=[G[0]-F[0]*N,G[1]-F[1]*N];I.push([S,D]);break}case N.uQ.Arch:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,1),F=this._sub(E,S),N=this._mix(G,1,F,.55),D=this._mix(G,1,F,-.55),X=[E];this._addBezier2(X,E,N,G,4),this._addBezier2(X,G,D,S,4),I.push(X);break}case N.uQ.CurvedParallelTicks:{const S=this._cp2(k,-4,1),G=this._cp3(k,S,.882353,-1.94),F=this._sub(G,S);this._crossProduct(F,this._sub(E,S))>0?this._rightPerpendicular(F):this._leftPerpendicular(F);const N=[F[0]/8,F[1]/8],D=this._sub(this._mid(S,G),N),X=this._sub(this._mix(S,.75,G,.25),N),et=this._sub(this._mix(S,.25,G,.75),N),st=[S];this._addBezier2(st,S,X,D,3),this._addBezier2(st,D,et,G,3),I.push(st);for(let k=0;k<8;k++){const S=st[2*k+1],E=[this._clone(S)];E.push(this._add(S,[F[0]/4,F[1]/4])),I.push(E)}break}case N.uQ.Arc90Degrees:{const S=this._cp2(k,0,-1),G=this._cp3(k,S,.5,1),F=[S];this._add90DegArc(F,S,E,G),I.push(F);break}case N.uQ.FullGeometry:default:I.push(k)}}return I}}},58860:(S,I,k)=>{k.d(I,{y:()=>r});var E=k(33303),G=k(47463),F=k(42273);class r{static local(){return null===r.instance&&(r.instance=new r),r.instance}execute(S,I,k,E,G){return new u(S,I,k)}}r.instance=null;class u extends G.rx{constructor(S,I,k){super(S,!0,!0),this._curveHelper=new F.I,this._beginCut=(void 0!==I.beginCut?I.beginCut:1)*k,this._endCut=(void 0!==I.endCut?I.endCut:1)*k,this._middleCut=(void 0!==I.middleCut?I.middleCut:0)*k,this._invert=void 0!==I.invert&&I.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(S){const{_beginCut:I,_endCut:k,_middleCut:G}=this,F=S.pathLength(),N=E.z.createEmptyOptimizedCIM("esriGeometryPolyline");if(this._invert){if(0!==I||0!==k||0!==G)if(I+k+G>=F)for(N.startPath();S.nextPoint();)N.pushXY(S.x,S.y);else this._curveHelper.appendSubCurve(N,S,0,I),this._curveHelper.appendSubCurve(N,S,.5*(F-G),.5*(F+G)),this._curveHelper.appendSubCurve(N,S,F-k,k)}else if(0===I&&0===k&&0===G)for(N.startPath();S.nextPoint();)N.pushXY(S.x,S.y);else I+k+G<F&&(0===G?this._curveHelper.appendSubCurve(N,S,I,F-k):(this._curveHelper.appendSubCurve(N,S,I,.5*(F-G)),this._curveHelper.appendSubCurve(N,S,.5*(F+G),F-k)));return 0===N.totalSize?null:N}}},870:(S,I,k)=>{k.d(I,{I:()=>h});var E=k(33303),G=k(46164),F=k(47463),N=k(64032),D=k(94042),X=k(3067);class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(S,I,k,E,G){return new l(S,I,k)}}h.instance=null;class l extends F.rx{constructor(S,I,k){var E,G;super(S,!0,!0),this._firstCurve=null,this._walker=new D.Z1,this._walker.updateTolerance(k),this._endings=I.lineDashEnding,this._customDashPos=-(null!==(E=I.offsetAlongLine)&&void 0!==E?E:0)*k,this._offsetAtEnd=(null!==(G=I.customEndingOffset)&&void 0!==G?G:0)*k,this._pattern=new D.VA,this._pattern.init((0,X.K3)(I).dashTemplate,!0),this._pattern.scale(k)}processPath(S){var I;if(0===this._pattern.length()){this.iteratePath=!1;const I=(0,G.A)(S);return E.z.fromJSONCIM({paths:[I]})}if(!this.iteratePath){let I=!0;switch(this._endings){case N.yS.HalfPattern:case N.yS.HalfGap:default:this._pattern.extPtGap=0;break;case N.yS.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case N.yS.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case N.yS.NoConstraint:this.isClosed||(I=!1);break;case N.yS.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const k=S.pathLength();if(this._pattern.isEmpty()||k<.1*this._pattern.length()){const I=(0,G.A)(S);return E.z.fromJSONCIM({paths:[I]})}if(!this._walker.init(S,this._pattern,I)){const I=(0,G.A)(S);return E.z.fromJSONCIM({paths:[I]})}}let k;if(this.iteratePath)k=this._pattern.nextValue();else{let S;switch(this._endings){case N.yS.HalfPattern:default:S=.5*this._pattern.firstValue();break;case N.yS.HalfGap:S=.5*-this._pattern.lastValue();break;case N.yS.FullGap:S=-this._pattern.lastValue();break;case N.yS.FullPattern:S=0;break;case N.yS.NoConstraint:case N.yS.Custom:S=-this._customDashPos}let I=S/this._pattern.length();I-=Math.floor(I),S=I*this._pattern.length(),this._pattern.reset(),k=this._pattern.nextValue();let E=!1;for(;S>=k;)S-=k,k=this._pattern.nextValue(),E=!E;k-=S,E?(this._walker.nextPosition(k),k=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(k),k=this._pattern.nextValue(),this._walker.nextPosition(k),k=this._pattern.nextValue())}let F=this._walker.nextCurve(k);if(F)if(this._walker.isPathEnd()){if(this.iteratePath=!1,this._firstCurve){for(this._firstCurve.nextPath();this._firstCurve.nextPoint();)F.pushXY(this._firstCurve.x,this._firstCurve.y);this._firstCurve=null}}else k=this._pattern.nextValue(),!this._walker.nextPosition(k)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(F.pushCursor(this._firstCurve),this._firstCurve=null)):this.iteratePath=!0;else this.iteratePath=!1,F=this._firstCurve,this._firstCurve=null;return null!==(I=F)&&void 0!==I&&I.reset(),F}}},9760:(S,I,k)=>{k.d(I,{O:()=>s});k(30174);var E=k(33303),G=k(73619),F=k(64032),N=k(98664);class s{static local(){return null===s.instance&&(s.instance=new s),s.instance}execute(S,I,k,E,G,F){return new r(S,I,k,E,G,F)}}s.instance=null;class r{constructor(S,I,k,E,G,N){switch(this._inputGeometries=S,this._tileKey=E,this._geometryEngine=G,this._maxInflateSize=N*k,this._width=(void 0!==I.width?I.width:2)*k,I.method){case F.M1.Mitered:case F.M1.Bevelled:case F.M1.Rounded:case F.M1.TrueBuffer:case F.M1.Square:}this._option=I.option}next(){let S;for(;S=this._inputGeometries.next();){if("esriGeometryEnvelope"===S.geometryType&&this._width>0){const I=S.asJSON();return Math.min(I.xmax-I.xmin,I.ymax-I.ymin)-2*this._width<0?S:E.z.fromJSONCIM({paths:[[[I.xmin+this._width,I.ymin+this._width],[I.xmax-this._width,I.ymin+this._width],[I.xmax-this._width,I.ymax-this._width],[I.xmin+this._width,I.ymax-this._width],[I.xmin+this._width,I.ymin+this._width]],[[I.xmin,I.ymin],[I.xmin,I.ymax],[I.xmax,I.ymax],[I.xmax,I.ymin],[I.xmin,I.ymin]]]})}if("esriGeometryPolygon"===S.geometryType){if(0===this._width)return S.clone();const I=this._geometryEngine;if(null==I)return null;const k=this._tileKey?(0,G.q)(S,this._maxInflateSize):S.clone();if(!k)continue;const E=I.buffer(N.A.WebMercator,k.asJSON(),-this._width,1);if(E)for(const S of E.rings)if(S){k.startPath();for(const I of S.reverse())k.pushXY(I[0],k.yFactor*I[1])}return k}}return null}}},57516:(S,I,k)=>{k.d(I,{U:()=>e});var E=k(33303),G=k(47463),F=k(42273);class e{static local(){return null===e.instance&&(e.instance=new e),e.instance}execute(S,I,k,E,G){return new n(S,I,k)}}e.instance=null;class n extends G.rx{constructor(S,I,k){super(S,!1,!0),this._curveHelper=new F.I,this._length=(void 0!==I.length?I.length:20)*k,this._angle=void 0!==I.angle?I.angle:225,this._position=void 0!==I.position?I.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(S){const I=E.z.createEmptyOptimizedCIM("esriGeometryPolyline");if(this._curveHelper.isEmpty(S))return null;S.seekInPath(0);const k=S.x,G=S.y;S.seekInPath(S.pathSize-1);const F=S.x,N=S.y,D=[F-k,N-G];this._curveHelper.normalize(D);const X=k+(F-k)*this._position/100,et=G+(N-G)*this._position/100,st=Math.cos((90-this._angle)/180*Math.PI);let it=Math.sin((90-this._angle)/180*Math.PI);this._mirror&&(it=-it),this._mirror=!this._mirror;const nt=[X-this._length/2*st,et-this._length/2*it],ot=[X+this._length/2*st,et+this._length/2*it];return I.pushPath([[k,G],nt,ot,[F,N]]),I}}},70335:(S,I,k)=>{k.d(I,{V:()=>t});class t{static local(){return null===t.instance&&(t.instance=new t),t.instance}execute(S,I,k,E,G){return new e(S,I,k)}}t.instance=null;class e{constructor(S,I,k){this._inputGeometries=S,this._offsetX=void 0!==I.offsetX?I.offsetX*k:0,this._offsetY=void 0!==I.offsetY?I.offsetY*k:0}next(){let S=this._inputGeometries.next();for(;S;){if(S.totalSize>0)return this._move(S.clone(),this._offsetX,this._offsetY);S=this._inputGeometries.next()}return null}_move(S,I,k){for(;S.nextPath();)for(;S.nextPoint();)S.x=S.x+I,S.y=S.y+k;return S.reset(),S}}},17985:(S,I,k)=>{k.d(I,{V:()=>h});k(30174);var E=k(33303),G=k(46164),F=k(31670),N=k(73619),D=k(42273),X=k(64032),et=k(98664);class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(S,I,k,E,G,F){return new l(S,I,k,E,G,F)}}h.instance=null;class l{constructor(S,I,k,E,G,F){var N;this._inputGeometries=S,this._tileKey=E,this._geometryEngine=G,this._curveHelper=new D.I,this._offset=(null!==(N=I.offset)&&void 0!==N?N:1)*k,this._method=I.method,this._maxInflateSize=Math.max(Math.abs(F*k),10),this._option=I.option,this._offsetFlattenError=D.U*k}next(){let S;for(;S=this._inputGeometries.next();){if(0===this._offset)return S.clone();if("esriGeometryEnvelope"===S.geometryType){if(this._method===X.xw.Rounded&&this._offset>0){const I=(0,G.A)(S),k=this._curveHelper.offset(I,-this._offset,this._method,4,this._offsetFlattenError);if(k){const I=E.z.createEmptyOptimizedCIM(S.geometryType);return I.pushPath(k),I}return null}const I=S.asJSON();if((0,F.ZC)(I)&&Math.min(I.xmax-I.xmin,I.ymax-I.ymin)+2*this._offset>0)return E.z.fromJSONCIM({xmin:I.xmin-this._offset,xmax:I.xmax+this._offset,ymin:I.ymin-this._offset,ymax:I.ymax+this._offset})}const I=this._geometryEngine;if(null==I)continue;const k=this._tileKey?(0,N.q)(S,this._maxInflateSize):S.clone();if(!k)continue;const D=I.offset(et.A.WebMercator,k.asJSON(),-this._offset,1,this._method,4,this._offsetFlattenError);return D?E.z.fromJSONCIM(D):null}return null}}},76506:(S,I,k)=>{k.d(I,{C:()=>e});class e{static local(){return null===e.instance&&(e.instance=new e),e.instance}execute(S,I,k,E,G){return new t(S,I,k)}}e.instance=null;class t{constructor(S,I,k){this._inputGeometries=S,this._reverse=void 0===I.reverse||I.reverse}next(){let S=this._inputGeometries.next();for(;S;){if(!this._reverse)return S;if("esriGeometryPolyline"===S.geometryType)return n(S.clone());S=this._inputGeometries.next()}return null}}function n(S){for(;S.nextPath();)for(let I=0;I<S.pathSize/2;I++){S.seekInPath(I);const k=S.x,E=S.y;S.seekInPath(S.pathSize-I-1);const G=S.x,F=S.y;S.x=k,S.y=E,S.seekInPath(I),S.x=G,S.y=F}return S.reset(),S}},53185:(S,I,k)=>{k.d(I,{v:()=>e});var E=k(12439);class e{static local(){return null===e.instance&&(e.instance=new e),e.instance}execute(S,I,k,E,G){return new n(S,I,k)}}e.instance=null;class n{constructor(S,I,k){this._inputGeometries=S,this._rotateAngle=void 0!==I.angle?I.angle*Math.PI/180:0}next(){let S=this._inputGeometries.next();for(;S;){if(0===this._rotateAngle||"esriGeometryPoint"===S.geometryType)return S;if(S.totalSize>0){const I=(0,E.z8)(S),k=(I[2]+I[0])/2,G=(I[3]+I[1])/2;return S.reset(),this._rotate(S.clone(),k,G)}S=this._inputGeometries.next()}return null}_rotate(S,I,k){const E=Math.cos(this._rotateAngle),G=Math.sin(this._rotateAngle);for(;S.nextPath();)for(;S.nextPoint();){const F=S.x-I,N=S.y-k;S.x=I+F*E-N*G,S.y=k+F*G+N*E}return S.reset(),S}}},99054:(S,I,k)=>{k.d(I,{W:()=>e});var E=k(12439);class e{static local(){return null===e.instance&&(e.instance=new e),e.instance}execute(S,I,k,E,G){return new r(S,I,k)}}e.instance=null;class r{constructor(S,I,k){this._inputGeometries=S,this._xFactor=void 0!==I.XScaleFactor?I.XScaleFactor:1.15,this._yFactor=void 0!==I.YScaleFactor?I.YScaleFactor:1.15}next(){const S=this._inputGeometries.next();if(S){if(1===this._xFactor&&1===this._yFactor)return S;if("esriGeometryPoint"===S.geometryType)return S;if(S.totalSize>0){const I=(0,E.z8)(S),k=(I[2]+I[0])/2,G=(I[3]+I[1])/2;return S.reset(),this._scaleCursor(S.clone(),k,G)}}return null}_scaleCursor(S,I,k){for(;S.nextPath();)for(;S.nextPoint();)S.x=I+(S.x-I)*this._xFactor,S.y=k+(S.y-k)*this._yFactor;return S.reset(),S}}},97887:(S,I,k)=>{k.d(I,{l:()=>n});var E=k(33303),G=k(64032),F=k(94042);class n{static local(){return null===n.instance&&(n.instance=new n),n.instance}execute(S,I,k,E,G){return new r(S,I,k)}}n.instance=null;class r{constructor(S,I,k){this._inputGeometries=S,this._height=(void 0!==I.amplitude?I.amplitude:2)*k,this._period=(void 0!==I.period?I.period:3)*k,this._style=I.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new F.VA,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new F.Z1,this._walker.updateTolerance(k)}next(){let S=this._inputGeometries.next();for(;S;){if(0===this._height||0===this._period)return S;const I=this._processGeom(S);if(I)return I;S=this._inputGeometries.next()}return null}_processGeom(S){const I=E.z.createEmptyOptimizedCIM(S.geometryType);for(;S.nextPath();){I.startPath();const k=S.pathLength();if(this._walker.init(S,this._pattern))switch(this._style){case G.WE.Sinus:default:this._constructCurve(I,k,!1);break;case G.WE.Square:this._constructSquare(I,k);break;case G.WE.Triangle:this._constructTriangle(I,k);break;case G.WE.Random:this._constructCurve(I,k,!0)}else for(;S.nextPoint();)I.pushXY(S.x,S.y)}return I}_constructCurve(S,I,k){let E=Math.round(I/this._period);0===E&&(E=1);const G=16*E+1,N=I/E,D=this._period/16,X=1/G,et=2*Math.PI*I/N,st=2*Math.PI*Math.random(),it=2*Math.PI*Math.random(),nt=2*Math.PI*Math.random(),ot=.75-Math.random()/2,at=.75-Math.random()/2,ht=new F.ps;this._walker.curPointAndAngle(ht),S.pushPoint(ht.pt);let lt=0;for(;;){if(!this._walker.nextPointAndAngle(D,ht)){S.pushPoint(this._walker.getPathEnd());break}{const I=lt;let E;if(lt+=X,k){const S=this._height/2*(1+.3*Math.sin(ot*et*I+st));E=S*Math.sin(et*I+it),E+=S*Math.sin(at*et*I+nt),E/=2}else E=.5*this._height*Math.sin(.5*et*I);S.pushXY(ht.pt[0]-E*ht.sa,ht.pt[1]+E*ht.ca)}}}_constructSquare(S,I){Math.round(I/this._period);let k=!0;for(;;){let I=!1;if(this._walker.curPositionIsValid()){const E=new F.ps;this._walker.curPointAndAngle(E);const G=new F.ps;if(this._walker.nextPointAndAngle(this._period,G)){const N=new F.ps;this._walker.nextPointAndAngle(this._period,N)&&(k?(S.pushPoint(E.pt),k=!1):S.pushPoint(E.pt),S.pushXY(E.pt[0]-this._height/2*E.sa,E.pt[1]+this._height/2*E.ca),S.pushXY(G.pt[0]-this._height/2*G.sa,G.pt[1]+this._height/2*G.ca),S.pushXY(G.pt[0]+this._height/2*G.sa,G.pt[1]-this._height/2*G.ca),S.pushXY(N.pt[0]+this._height/2*N.sa,N.pt[1]-this._height/2*N.ca),I=!0)}}if(!I){S.pushPoint(this._walker.getPathEnd());break}}}_constructTriangle(S,I){Math.round(I/this._period);let k=!0;for(;;){let I=!1;if(this._walker.curPositionIsValid()){const E=new F.ps;this._walker.curPointAndAngle(E);const G=new F.ps;if(this._walker.nextPointAndAngle(this._period/2,G)){const N=new F.ps;this._walker.nextPointAndAngle(this._period,N)&&(this._walker.nextPosition(this._period/2)&&(k?(S.pushPoint(E.pt),k=!1):S.pushPoint(E.pt),S.pushXY(G.pt[0]-this._height/2*G.sa,G.pt[1]+this._height/2*G.ca),S.pushXY(N.pt[0]+this._height/2*N.sa,N.pt[1]-this._height/2*N.ca)),I=!0)}}if(!I){S.pushPoint(this._walker.getPathEnd());break}}}}},54574:(S,I,k)=>{k.d(I,{e:()=>a});var E=k(47463),G=k(64032),F=k(94042);class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(S,I,k,E,G){return new r(S,I,k)}}a.instance=null;class r extends E.pC{constructor(S,I,k){var E;super(S),this._geometryWalker=new F.Z1,this._geometryWalker.updateTolerance(k),this._angleToLine=null===(E=I.angleToLine)||void 0===E||E,this._offset=(I.offset?I.offset:0)*k,this._originalEndings=I.endings,this._offsetAtEnd=(I.customEndingOffset?I.customEndingOffset:0)*k,this._position=-(I.offsetAlongLine?I.offsetAlongLine:0)*k,this._pattern=new F.VA,this._pattern.init(I.placementTemplate,!1),this._pattern.scale(k),this._endings=this._originalEndings}processPath(S){if(this._pattern.isEmpty())return null;let I;if(this.iteratePath)I=this._pattern.nextValue();else{this._originalEndings===G.e_.WithFullGap&&this.isClosed?this._endings=G.e_.WithMarkers:this._endings=this._originalEndings,this._pattern.extPtGap=0;let k,E=!0;switch(this._endings){case G.e_.NoConstraint:k=-this._position,k=this._adjustPosition(k),E=!1;break;case G.e_.WithHalfGap:default:k=-this._pattern.lastValue()/2;break;case G.e_.WithFullGap:k=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case G.e_.WithMarkers:k=0;break;case G.e_.Custom:k=-this._position,k=this._adjustPosition(k),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(S,this._pattern,E))return null;this._pattern.reset();let F=0;for(;k>F;)k-=F,F=this._pattern.nextValue();F-=k,I=F,this.iteratePath=!0}const k=new F.ps;return this._geometryWalker.nextPointAndAngle(I,k)?this._endings===G.e_.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===G.e_.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(k.pt[0]-this._offset*k.sa,k.pt[1]+this._offset*k.ca),this._angleToLine&&this.internalPlacement.setRotateCS(k.ca,k.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(S){let I=S/this._pattern.length();return I-=Math.floor(I),I*this._pattern.length()}}},36654:(S,I,k)=>{k.d(I,{y:()=>i});var E=k(47463),G=k(42273),F=k(64032);class i{static local(){return null===i.instance&&(i.instance=new i),i.instance}execute(S,I,k,E,G){return new n(S,I,k)}}i.instance=null;class n extends E.pC{constructor(S,I,k){super(S,!1,!0),this._curveHelper=new G.I,this._angleToLine=void 0===I.angleToLine||I.angleToLine,this._offset=void 0!==I.offset?I.offset*k:0,this._type=I.extremityPlacement,this._position=void 0!==I.offsetAlongLine?I.offsetAlongLine*k:0,this._beginProcessed=!1}processPath(S){let I;switch(this._type){case F.$2.Both:default:this._beginProcessed?(I=this._atExtremities(S,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(I=this._atExtremities(S,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case F.$2.JustBegin:I=this._atExtremities(S,this._position,!0);break;case F.$2.JustEnd:I=this._atExtremities(S,this._position,!1);case F.$2.None:}return I}_atExtremities(S,I,k){if(k||S.seekPathEnd(),k?S.nextPoint():S.prevPoint()){let E=0,[G,F]=[0,0],[N,D]=[S.x,S.y];for(;k?S.nextPoint():S.prevPoint();){G=N,F=D,N=S.x,D=S.y;const k=this._curveHelper.getLength(G,F,N,D);if(E+k>I){const S=(I-E)/k,[X,et]=this._curveHelper.getAngleCS(G,F,N,D,S),st=this._curveHelper.getCoord2D(G,F,N,D,S);return this.internalPlacement.setTranslate(st[0]-this._offset*et,st[1]+this._offset*X),this._angleToLine&&this.internalPlacement.setRotateCS(-X,-et),this.internalPlacement}E+=k}}return null}}},85272:(S,I,k)=>{k.d(I,{S:()=>a});var E=k(47463),G=k(94042);class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(S,I,k,E,G){return new r(S,I,k)}}a.instance=null;class r extends E.pC{constructor(S,I,k){super(S),this._walker=new G.Z1,this._walker.updateTolerance(k),this._angleToLine=void 0===I.angleToLine||I.angleToLine,this._offset=void 0!==I.offset?I.offset*k:0,this._beginGap=void 0!==I.beginPosition?I.beginPosition*k:0,this._endGap=void 0!==I.endPosition?I.endPosition*k:0,this._flipFirst=void 0===I.flipFirst||I.flipFirst,this._pattern=new G.VA,this._pattern.init(I.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(S){if(this._pattern.isEmpty())return null;let I;if(this.iteratePath){const S=this._pattern.nextValue()*this._subPathLen,k=this._beginGap+S;I=k-this._prevPos,this._prevPos=k}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=S.pathLength()-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(S,this._pattern,!1))return null;this._pattern.reset();const k=this._pattern.nextValue()*this._subPathLen,E=this._beginGap+k;I=E-this._prevPos,this._prevPos=E,this.iteratePath=!0}const k=new G.ps;if(!this._walker.nextPointAndAngle(I,k,G.YQ.END))return this.iteratePath=!1,null;this.internalPlacement.setTranslate(k.pt[0]-this._offset*k.sa,k.pt[1]+this._offset*k.ca);const E=this._isFirst&&this._flipFirst;let F,N;return this._angleToLine?(F=k.ca,N=k.sa):(F=1,N=0),E&&(F=-F,N=-N),this.internalPlacement.setRotateCS(F,N),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}},75184:(S,I,k)=>{k.d(I,{M:()=>r});var E=k(76761),G=k(10717),F=k(64032);const N=512,D=24,X=1e-6;class r{static local(){return null===r.instance&&(r.instance=new r),r.instance}execute(S,I,k,E,G){return new a(S,I,k,E,G)}}r.instance=null;class a{constructor(S,I,k,D,X){var et,st;if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(null!==(et=I.stepX)&&void 0!==et?et:16)*k,this._stepY=Math.abs(null!==(st=I.stepY)&&void 0!==st?st:16)*k,this._stepX=Math.round(128*this._stepX)/128,this._stepY=Math.round(128*this._stepY)/128,0!==this._stepX&&0!==this._stepY){var it;if(this._gridType=null!==(it=I.gridType)&&void 0!==it?it:F.Q1.Fixed,this._gridType===F.Q1.Random){var nt,ot;const S=null!==(nt=I.seed)&&void 0!==nt?nt:13,k=1;this._randomLCG=new E.A(S*k),this._randomness=(null!==(ot=I.randomness)&&void 0!==ot?ot:100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues()}else{var at,ht,lt,ct;if(this._randomness=0,this._gridAngle=null!==(at=I.gridAngle)&&void 0!==at?at:0,this._shiftOddRows=null!==(ht=I.shiftOddRows)&&void 0!==ht&&ht,this._offsetX=(null!==(lt=I.offsetX)&&void 0!==lt?lt:0)*k,this._offsetY=(null!==(ct=I.offsetY)&&void 0!==ct?ct:0)*k,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=D){const[S,I,k,E]=D.split("/"),G=parseFloat(S),F=parseFloat(I),X=parseFloat(k),et=parseFloat(E);this._graphicOriginX=-(et*2**G+X)*N,this._graphicOriginY=F*N,this._testInsidePolygon=!0}this._internalPlacement=new G.W,this._calculateMinMax(S),this._geometryCursor=S}}next(){return this._geometryCursor?this._nextInside():null}_buildRandomValues(){if(!a._randValues){a._randValues=[];for(let S=0;S<D;S++)for(let I=0;I<D;I++)a._randValues.push(this._randomLCG.getFloat()),a._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(S){let I,k,E,G,F,D,X,et,st,it,nt,ot,at,ht;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,X=et=at=nt=Number.MAX_VALUE,st=it=ht=ot=-Number.MAX_VALUE;const lt=1!==this._cosAngle;for(S.reset();S.nextPath();)for(;S.nextPoint();)D=S.x,F=S.y,I=D-this._graphicOriginX-this._offsetX,k=F-this._graphicOriginY-this._offsetY,lt?(E=this._cosAngle*I-this._sinAngle*k,G=this._sinAngle*I+this._cosAngle*k):(E=I,G=k),X=Math.min(X,E),st=Math.max(st,E),et=Math.min(et,G),it=Math.max(it,G),nt=Math.min(nt,F),ot=Math.max(ot,F),at=Math.min(at,D),ht=Math.max(ht,D);nt=nt!==Number.MAX_VALUE?nt:-N-this._stepY,ot=ot!==-Number.MAX_VALUE?ot:this._stepY,at=at!==Number.MAX_VALUE?at:-this._stepX,ht=ht!==-Number.MAX_VALUE?ht:N+this._stepX;const ct=ot-nt,ut=ht-at;if(this._verticalSubdivision=ct>=ut,this._polygonMin=this._verticalSubdivision?nt:at,this._testInsidePolygon){let S=0-this._graphicOriginX-this._offsetX-this._stepX,I=N-this._graphicOriginX-this._offsetX+this._stepX,k=-N-this._graphicOriginY-this._offsetY-this._stepY,E=0-this._graphicOriginY-this._offsetY+this._stepY;if(lt){const G=[[S,k],[S,E],[I,k],[I,E]];S=k=Number.MAX_VALUE,I=E=-Number.MAX_VALUE;for(const F of G){const G=this._cosAngle*F[0]-this._sinAngle*F[1],N=this._sinAngle*F[0]+this._cosAngle*F[1];S=Math.min(S,G),I=Math.max(I,G),k=Math.min(k,N),E=Math.max(E,N)}}X=X!==Number.MAX_VALUE?Math.max(X,S):S,et=et!==Number.MAX_VALUE?Math.max(et,k):k,st=st!==-Number.MAX_VALUE?Math.min(st,I):I,it=it!==-Number.MAX_VALUE?Math.min(it,E):E}this._xMin=Math.round(X/this._stepX),this._xMax=Math.round(st/this._stepX),this._yMin=Math.round(et/this._stepY),this._yMax=Math.round(it/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._buildAccelerationMap(S,at,ht,nt,ot)}_buildAccelerationMap(S,I,k,E,G){S.reset();const F=new Map,D=this._verticalSubdivision,X=D?G-E:k-I;let et=Math.ceil(X/10);if(et<=1)return;const st=Math.floor(X/et);let it,nt,ot,at,ht,lt,ct,ut,_t,ft,dt;for(et++,this._delta=st,D?(_t=-N-2*this._stepY,ft=2*this._stepY,dt=E):(_t=-2*this._stepX,ft=N+2*this._stepX,dt=I);S.nextPath();)if(!(S.pathSize<2)&&S.nextPoint())for(it=S.x,nt=S.y;S.nextPoint();it=ot,nt=at){if(ot=S.x,at=S.y,D){if(nt===at||nt<_t&&at<_t||nt>ft&&at>ft)continue;ht=Math.min(nt,at),lt=Math.max(nt,at)}else{if(it===ot||it<_t&&ot<_t||it>ft&&ot>ft)continue;ht=Math.min(it,ot),lt=Math.max(it,ot)}for(;ht<lt;)ct=Math.floor((ht-dt)/st),l(ct,it,nt,ot,at,F),ht+=st;ut=Math.floor((lt-dt)/st),ut>ct&&l(ut,it,nt,ot,at,F)}this._accelerationMap=F}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let S=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(S+=.5*this._stepX);const I=this._currentY*this._stepY+this._offsetY;let k,E;if(this._currentX++,this._gridType===F.Q1.Random){const G=(this._currentX%D+D)%D,F=(this._currentY%D+D)%D;k=this._graphicOriginX+S+this._stepX*this._randomness*(.5-a._randValues[F*D+G])*2/3,E=this._graphicOriginY+I+this._stepY*this._randomness*(.5-a._randValues[F*D+G+1])*2/3}else k=this._graphicOriginX+this._cosAngle*S+this._sinAngle*I,E=this._graphicOriginY-this._sinAngle*S+this._cosAngle*I;if(!this._testInsidePolygon||this._isInsidePolygon(k,E,this._geometryCursor))return this._internalPlacement.setTranslate(k,E),this._internalPlacement}}_isInsidePolygon(S,I,k){if(null==this._accelerationMap)return function o(S,I,k){let E,G,F,N,D=0;for(S+=X,I+=X,k.reset();k.nextPath();)if(k.nextPoint())for(E=k.x,G=k.y;k.nextPoint();E=F,G=N)F=k.x,N=k.y,G>I!=N>I&&((F-E)*(I-G)-(N-G)*(S-E)>0?D++:D--);return 0!==D}(S,I,k);S+=X,I+=X;const E=this._verticalSubdivision,G=E?I:S,F=Math.floor((G-this._polygonMin)/this._delta),N=this._accelerationMap.get(F);if(!N)return!1;let D,et,st,it=0;for(const X of N){if(D=X[0],et=X[1],E){if(D[1]>I==et[1]>I)continue;st=(et[0]-D[0])*(I-D[1])-(et[1]-D[1])*(S-D[0])}else{if(D[0]>S==et[0]>S)continue;st=(et[1]-D[1])*(S-D[0])-(et[0]-D[0])*(I-D[1])}st>0?it++:it--}return 0!==it}}function l(S,I,k,E,G,F){let N=F.get(S);N||(N=[],F.set(S,N)),N.push([[I,k],[E,G]])}},11931:(S,I,k)=>{k.d(I,{R:()=>s});var E=k(47463),G=k(42273),F=k(64032);class s{static local(){return null===s.instance&&(s.instance=new s),s.instance}execute(S,I,k,E,G){return new r(S,I,k)}}s.instance=null;class r extends E.pC{constructor(S,I,k){super(S),this._curveHelper=new G.I,this._angleToLine=void 0===I.angleToLine||I.angleToLine,this._offset=void 0!==I.offset?I.offset*k:0,this._relativeTo=I.relativeTo,this._position=void 0!==I.startPointOffset?I.startPointOffset*k:0,this._epsilon=.001*k}processPath(S){const I=this._position;if(this._relativeTo===F.ip.SegmentMidpoint){if(this.iteratePath||(this.iteratePath=!0),S.nextPoint()){let[I,k]=[S.x,S.y],[E,G]=[0,0];for(;S.nextPoint();){E=S.x,G=S.y;const F=this._curveHelper.getLength(I,k,E,G);if(F<this._epsilon){I=E,k=G;continue}const N=.5+this._position/F,[D,X]=this._curveHelper.getAngleCS(I,k,E,G,N),et=this._curveHelper.getCoord2D(I,k,E,G,N);return this.internalPlacement.setTranslate(et[0]-this._offset*X,et[1]+this._offset*D),this._angleToLine&&this.internalPlacement.setRotateCS(D,X),this.internalPlacement}}return this.iteratePath=!1,null}const k=this._relativeTo===F.ip.LineEnd;return this.onLine(S,I,k)}onLine(S,I,k){let E,G=!1;switch(this._relativeTo){case F.ip.LineMiddle:default:S.seekPathStart(),E=S.pathLength()/2+I;break;case F.ip.LineBeginning:E=I;break;case F.ip.LineEnd:E=I,G=!0}k?S.seekPathEnd():S.seekPathStart();let N=0;if(k?S.prevPoint():S.nextPoint()){let[I,F]=[S.x,S.y],[D,X]=[0,0];for(;k?S.prevPoint():S.nextPoint();){D=S.x,X=S.y;const k=this._curveHelper.getLength(I,F,D,X);if(N+k>E){const S=(E-N)/k,[et,st]=this._curveHelper.getAngleCS(I,F,D,X,S),it=this._curveHelper.getCoord2D(I,F,D,X,S),nt=G?-this._offset:this._offset;return this.internalPlacement.setTranslate(it[0]-nt*st,it[1]+nt*et),this._angleToLine&&(G?this.internalPlacement.setRotateCS(-et,-st):this.internalPlacement.setRotateCS(et,st)),this.internalPlacement}I=D,F=X,N+=k}}return null}}},67382:(S,I,k)=>{k.d(I,{A:()=>i});var E=k(47463),G=k(42273);class i{static local(){return null===i.instance&&(i.instance=new i),i.instance}execute(S,I,k,E,G){return new n(S,I,k)}}i.instance=null;class n extends E.pC{constructor(S,I,k){super(S),this._curveHelper=new G.I,this._angleToLine=void 0===I.angleToLine||I.angleToLine,this._offset=void 0!==I.offset?I.offset*k:0,this._endPoints=void 0===I.placeOnEndPoints||I.placeOnEndPoints,this._controlPoints=void 0===I.placeOnControlPoints||I.placeOnControlPoints,this._regularVertices=void 0===I.placeOnRegularVertices||I.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(S){if(this.iteratePath||(this._preparePath(S),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const I=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(I[2]);let k=I[0],E=I[1];if(0!==this._offset){const S=Math.cos(I[2]),G=Math.sin(I[2]);k-=this._offset*G,E+=this._offset*S}return this.internalPlacement.setTranslate(k,E),this._tagIterator++,this.internalPlacement}_preparePath(S){this._tags.length=0,this._tagIterator=0,S.seekPathStart();const I=S.isClosed();let k=0,E=!1,G=0,F=0;if(S.seekPathStart(),S.nextPoint()){let N=S.x,D=S.y,X=S.getControlPoint(),et=!0,st=S.nextPoint();for(;st;){const it=S.x,nt=S.y,ot=S.getControlPoint();(this._angleToLine||0!==this._offset)&&(G=this._curveHelper.getAngle(N,D,it,nt,0)),et?(et=!1,I?(k=G,E=X):(this._endPoints||this._controlPoints&&X)&&this._tags.push([N,D,G])):X?this._controlPoints&&this._tags.push([N,D,o(F,G)]):this._regularVertices&&this._tags.push([N,D,o(F,G)]),(this._angleToLine||0!==this._offset)&&(F=this._curveHelper.getAngle(N,D,it,nt,1)),st=S.nextPoint(),st||(I?ot||E?this._controlPoints&&this._tags.push([it,nt,o(F,k)]):this._regularVertices&&this._tags.push([it,nt,o(F,k)]):(this._endPoints||this._controlPoints&&ot)&&this._tags.push([it,nt,F])),N=it,D=nt,X=ot}}this._tagIterator=0}}function o(S,I){const k=Math.PI;for(;Math.abs(I-S)>k+2e-15;)I-S>k?I-=2*k:I+=2*k;return(S+I)/2}},11257:(S,I,k)=>{k.d(I,{L:()=>r});var E=k(12439),G=k(61077),F=k(61693),N=k(10717),D=k(64032);class r{static local(){return null===r.instance&&(r.instance=new r),r.instance}execute(S,I,k,E,G){return new i(S,I,k)}}r.instance=null;class i{constructor(S,I,k){this._geometryCursor=S,this._offsetX=void 0!==I.offsetX?I.offsetX*k:0,this._offsetY=void 0!==I.offsetY?I.offsetY*k:0,this._method=void 0!==I.method?I.method:D.YI.OnPolygon,this._internalPlacement=new N.W}next(){const S=this._geometryCursor;return this._geometryCursor=null,S?this._polygonCenter(S):null}_polygonCenter(S){let I=!1;switch(this._method){case D.YI.CenterOfMass:{const k=(0,G.TP)(S);k&&(this._internalPlacement.setTranslate(k[0]+this._offsetX,k[1]+this._offsetY),I=!0)}break;case D.YI.BoundingBoxCenter:{const k=(0,E.z8)(S);k&&(this._internalPlacement.setTranslate((k[2]+k[0])/2+this._offsetX,(k[3]+k[1])/2+this._offsetY),I=!0)}break;case D.YI.OnPolygon:default:{const k=(0,F.d)(S);null!==k&&(this._internalPlacement.setTranslate(k[0]+this._offsetX,k[1]+this._offsetY),I=!0)}}return I?this._internalPlacement:null}}},73855:(S,I,k)=>{k.d(I,{Dy:()=>i,UD:()=>c,fO:()=>o,gy:()=>F,iT:()=>s,xy:()=>a});var E=k(89412);const t=()=>E.A.getLogger("esri.views.2d.engine.webgl.alignmentUtils");var G,F,N;function a(S){if(!S)return G.Center;switch(S){case"Left":case"left":return G.Left;case"Right":case"right":return G.Right;case"Justify":return t().warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."),G.Center;case"Center":case"center":return G.Center}}function c(S){if(!S)return F.Center;switch(S){case"Top":case"top":return F.Top;case"Center":case"middle":return F.Center;case"Baseline":case"baseline":return F.Baseline;case"Bottom":case"bottom":return F.Bottom}}function o(S){switch(S){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return["right","bottom"];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return["center","bottom"];case"above-right":case"esriServerPointLabelPlacementAboveRight":return["left","bottom"];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return["right","middle"];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return["center","middle"];case"center-right":case"esriServerPointLabelPlacementCenterRight":return["left","middle"];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return["right","top"];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return["center","top"];case"below-right":case"esriServerPointLabelPlacementBelowRight":return["left","top"];default:return console.debug("Found invalid placement type ".concat(S)),["center","middle"]}}function s(S){switch(S){case G.Right:case"right":return-1;case G.Center:case"center":return 0;case G.Left:case"left":return 1;default:return console.debug("Found invalid horizontal alignment ".concat(S)),0}}function i(S){switch(S){case F.Top:case"top":return 1;case F.Center:case"middle":return 0;case F.Bottom:case F.Baseline:case"baseline":case"bottom":return-1;default:return console.debug("Found invalid vertical alignment ".concat(S)),0}}(N=G||(G={}))[N.Left=-1]="Left",N[N.Center=0]="Center",N[N.Right=1]="Right",function(S){S[S.Top=1]="Top",S[S.Center=0]="Center",S[S.Bottom=-1]="Bottom",S[S.Baseline=2]="Baseline"}(F||(F={}))},90624:(S,I,k)=>{k.d(I,{Tl:()=>O});var E=k(22815),G=k(96062),F=k(37131),N=k(40102),D=k(73855),X=k(20943),et=k(22070);const st=22,it=4,nt=st+it,ot=st-6,at=3,ht=Math.PI/180;class M{constructor(S,I,k,E){this._rotationT=(0,G.vt)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const F=k.rect,N=new Float32Array(8);S*=E,I*=E;const D=k.code?F.width*E:k.metrics.width,X=k.code?F.height*E:k.metrics.height;this.width=D,this.height=X,N[0]=S,N[1]=I,N[2]=S+D,N[3]=I,N[4]=S,N[5]=I+X,N[6]=S+D,N[7]=I+X,this._data=N,this._setTextureCoords(F),this._scale=E,this._mosaic=k,this.x=S,this.y=I,this.maxOffset=Math.max(S+D,I+X)}get mosaic(){return this._mosaic}set angle(S){this._angle=S,(0,E.$0)(this._rotationT,-S),this._setOffsets()}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:S,width:I}=this._mosaic.metrics,k=I*this._scale,F=Math.abs(S)*this._scale,N=new Float32Array(8);N[0]=this.x,N[1]=this.y,N[2]=this.x+k,N[3]=this.y,N[4]=this.x,N[5]=this.y+F,N[6]=this.x+k,N[7]=this.y+F;const D=(0,E.lw)((0,G.vt)(),this._rotationT,this._transform);(0,G.gb)(N,N,D);let X=1/0,st=1/0,it=0,nt=0;for(let E=0;E<4;E++){const S=N[2*E],I=N[2*E+1];X=Math.min(X,S),st=Math.min(st,I),it=Math.max(it,S),nt=Math.max(nt,I)}const ot=it-X,at=nt-st,ht=X+ot/2,lt=st+at/2;this._bounds=new et.A(ht,lt,ot,at)}return this._bounds}setTransform(S){this._transform=S,this._offsets=null}_setOffsets(){this._offsets||(this._offsets={topLeft:[0,0],topRight:[0,0],bottomLeft:[0,0],bottomRight:[0,0]});const S=(0,E.lw)((0,G.vt)(),this._rotationT,this._transform);this._offsets.topLeft[0]=this._data[0],this._offsets.topLeft[1]=this._data[1],this._offsets.topRight[0]=this._data[2],this._offsets.topRight[1]=this._data[3],this._offsets.bottomLeft[0]=this._data[4],this._offsets.bottomLeft[1]=this._data[5],this._offsets.bottomRight[0]=this._data[6],this._offsets.bottomRight[1]=this._data[7],(0,F.l0)(this._offsets.topLeft,this._offsets.topLeft,S),(0,F.l0)(this._offsets.topRight,this._offsets.topRight,S),(0,F.l0)(this._offsets.bottomLeft,this._offsets.bottomLeft,S),(0,F.l0)(this._offsets.bottomRight,this._offsets.bottomRight,S)}_setTextureCoords(S){let{x:I,y:k,width:E,height:G}=S;this._texcoords={topLeft:[I,k],topRight:[I+E,k],bottomLeft:[I,k+G],bottomRight:[I+E,k+G]}}}const L=(S,I)=>({code:0,page:0,sdf:!0,rect:new X.A(0,0,11,8),textureBinding:I,metrics:{advance:0,height:4,width:S,left:0,top:0}});function R(S,I){return S.forEach((S=>(0,F.l0)(S,S,I))),{topLeft:S[0],topRight:S[1],bottomLeft:S[2],bottomRight:S[3]}}class B{constructor(S,I,k){this._rotation=0,this._decorate(S,I,k),this.glyphs=S,this.bounds=this._createBounds(S),this.isMultiline=I.length>1,this._hasRotation=0!==k.angle,this._transform=this._createGlyphTransform(this.bounds,k),this._borderLineSizePx=k.borderLineSizePx,(k.borderLineSizePx||k.hasBackground)&&([this.bounds,this.textBox]=this.shapeBackground(this._transform));for(const E of S)E.setTransform(this._transform)}setRotation(S){if(0===S&&0===this._rotation)return;this._rotation=S;const I=this._transform,k=(0,E.$0)((0,G.vt)(),S);(0,E.lw)(I,k,I);for(const E of this.glyphs)E.setTransform(this._transform)}_decorate(S,I,k){if(!k.decoration||"none"===k.decoration||!S.length)return;const E=k.scale,G="underline"===k.decoration?nt:ot,F=S[0].textureBinding;for(const N of I){const I=N.startX*E,k=N.startY*E,D=(N.width+N.glyphWidthEnd)*E;S.push(new M(I,k+G*E,L(D,F),1))}}shapeBackground(S){const I=(1.5+(this._borderLineSizePx||0))/2,k=this._borderLineSizePx?I:0,{xmin:E,ymin:G,xmax:F,ymax:N,x:D,y:X,width:st,height:it}=this.bounds,nt=[E-8,G-8],ot=[F+8,G-8],at=[E-8,N+8],ht=[F+8,N+8],lt=R([[nt[0]-I,nt[1]-I],[ot[0]+I,ot[1]-I],[nt[0]+k,nt[1]+k],[ot[0]-k,ot[1]+k]],S),ct=R([[at[0]+k,at[1]-k],[ht[0]-k,ht[1]-k],[at[0]-I,at[1]+I],[ht[0]+I,ht[1]+I]],S),ut=R([[nt[0]-I,nt[1]-I],[nt[0]+k,nt[1]+k],[at[0]-I,at[1]+I],[at[0]+k,at[1]-k]],S),_t=R([[ot[0]-k,ot[1]+k],[ot[0]+I,ot[1]-I],[ht[0]-k,ht[1]-k],[ht[0]+I,ht[1]+I]],S),ft={main:R([nt,ot,at,ht],S),top:lt,bot:ct,left:ut,right:_t};return[new et.A(D,X,st+2*I,it+2*I),ft]}get boundsT(){const S=this.bounds,I=(0,F.hZ)((0,N.vt)(),S.x,S.y);if((0,F.l0)(I,I,this._transform),this._hasRotation){const k=Math.max(S.width,S.height);return new et.A(I[0],I[1],k,k)}return new et.A(I[0],I[1],S.width,S.height)}_createBounds(S){let I=1/0,k=1/0,E=0,G=0;for(const D of S)I=Math.min(I,D.xTopLeft),k=Math.min(k,D.yTopLeft),E=Math.max(E,D.xBottomRight),G=Math.max(G,D.yBottomRight);const F=E-I,N=G-k;return new et.A(I+F/2,k+N/2,F,N)}_createGlyphTransform(S,I){const k=ht*I.angle,D=(0,G.vt)(),X=(0,N.vt)();return(0,E.Tl)(D,D,(0,F.hZ)(X,I.xOffset,-I.yOffset)),I.useCIMAngleBehavior?(0,E.e$)(D,D,k):((0,E.Tl)(D,D,(0,F.hZ)(X,S.x,S.y)),(0,E.e$)(D,D,k),(0,E.Tl)(D,D,(0,F.hZ)(X,-S.x,-S.y))),D}}class T{constructor(S,I,k,E,G,F){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(I,k)),this.end=Math.max(0,Math.max(I,k)),this.end<S.length&&(this.glyphWidthEnd=S[this.end].metrics.width),this.width=E,this.yMin=G,this.yMax=F}}const v=S=>10===S,j=S=>32===S;function z(S,I){let k=0;for(let F=0;F<S.length;F++){const{width:I}=S[F];k=Math.max(I,k)}const E="underline"===I.decoration?it:0,G=S[0].yMin;return{x:0,y:G,height:S[S.length-1].yMax+I.lineHeight*(S.length-1)+E-G,width:k}}function O(S,I){const k=I.scale,E=new Array,{glyphs:G,isRightToLeft:F}=S,N=function A(S,I,k){const E=new Array,G=1/k.scale,F=k.maxLineWidth*G,N=I?S.length-1:0,D=I?-1:S.length,X=I?-1:1;let et=N,st=0,it=0,nt=et,ot=nt,at=0,ht=1/0,lt=0;for(;et!==D;){const{code:I,metrics:k}=S[et],G=Math.abs(k.top);if(v(I)||j(I)||(ht=Math.min(ht,G),lt=Math.max(lt,G+k.height)),v(I))et!==N&&(E.push(new T(S,nt,et-X,st,ht,lt)),ht=1/0,lt=0),st=0,nt=et+X,ot=et+X,it=0;else if(j(I))ot=et+X,it=0,at=k.advance,st+=k.advance;else if(st>F){if(ot!==nt){const I=ot-2*X;st-=at,E.push(new T(S,nt,I,st-it,ht,lt)),ht=1/0,lt=0,nt=ot,st=it}else E.push(new T(S,nt,et-X,st,ht,lt)),ht=1/0,lt=0,nt=et,ot=et,st=0;st+=k.advance,it+=k.advance}else st+=k.advance,it+=k.advance;et+=X}const ct=new T(S,nt,et-X,st,ht,lt);return ct.start>=0&&ct.end<S.length&&E.push(ct),E}(G,F,I),X=z(N,I),et=(0,D.xy)(I.horizontalAlignment),it=(0,D.UD)(I.verticalAlignment),nt=it===D.gy.Baseline?1:0,ot=nt?0:it-1,ht=(1-nt)*-X.y+ot*(X.height/2)+(nt?1:0)*-st;for(let D=0;D<N.length;D++){const{start:S,end:F,width:X}=N[D];let st=-1*(et+1)*(X/2)-at;const it=D*I.lineHeight+ht-at;N[D].startX=st,N[D].startY=it;for(let I=S;I<=F;I++){const S=G[I];if(v(S.code))continue;const F=new M(st+S.metrics.left,it-S.metrics.top,S,k);st+=S.metrics.advance,E.push(F)}}return new B(E,N,I)}}}]);
//# sourceMappingURL=8809.ff7a69fb.chunk.js.map