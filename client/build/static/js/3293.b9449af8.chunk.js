"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[3293],{11277:(p,y,w)=>{var _;w.d(y,{u:()=>_}),function(p){p[p.KILOBYTES=1024]="KILOBYTES",p[p.MEGABYTES=1048576]="MEGABYTES",p[p.GIGABYTES=1073741824]="GIGABYTES"}(_||(_={}))},73293:(p,y,w)=>{w.r(y),w.d(y,{default:()=>xt});var _=w(80671),b=w(21365),I=w(88706),R=w(4180),T=w(89412),A=w(13132),M=w(81618),k=w(63390),C=w(57453),P=w(6493),O=(w(76761),w(50886)),D=w(99825),B=w(68682),N=w(78658),z=w(47478),J=w(53200),E=w(21642),H=(w(30174),w(96143)),U=w(53705),G=w(63537),W=w(59299),q=w(78395),Z=w(26128),j=w(32277),V=w(9607),Y=w(38855),X=w(29312),K=w(41211),Q=w(22179),ee=w(48343),te=w(83375),ie=w(5203),ne=w(86168),re=w(35341),se=w(67667),ae=w(63741),oe=w(73489),le=w(41761),ce=w(82793),ue=w(13804),he=w(60782),de=w(73896),fe=w(84661),me=w(57264),pe=w(98664);let ye=0,ge=class extends((0,ie.g)(te.oY)){constructor(){super(...arguments),this._tileFetchQueue=new de.e({concurrency:32,process:(p,y)=>this._fetchRawTile(p.pyramidLevel,p.row,p.col,{...p.options,signal:y})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const p=(0,ue.Hh)();this.addResolvingPromise(p),await this.when()}normalizeCtorArgs(p){var y;return null!==(y=p)&&void 0!==y&&y.ioConfig&&(p={...p,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Q.A.create(),...p.ioConfig}}),p}get _isGlobalWrappableSource(){const{rasterInfo:p}=this,y=(0,ue.FT)(p.spatialReference);return null!=y&&p.extent.width>=y/2}get _hasNoneOrGCSShiftTransform(){const{transform:p}=this.rasterInfo;return null==p||"gcs-shift"===p.type}set rasterJobHandler(p){var y;this._set("rasterJobHandler",p),"Function"===this.datasetFormat&&(null===(y=this.primaryRasters)||void 0===y||null===(y=y.rasters)||void 0===y||y.forEach((y=>y.rasterJobHandler=p)))}get rasterId(){return this.url||"rasterId-"+ye++}set url(p){this._set("url",(0,Z.Jf)(p,T.A.getLogger(this)))}async open(p){throw new R.A("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const b=_.tileInfo||this.rasterInfo.storageInfo.tileInfo,I=this.getTileExtentFromTileInfo(p,y,w,b);return _={noClip:!0,..._},this.fetchPixels(I,b.size[0],b.size[1],_)}async identify(p){var y,w;let _=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};p=(0,P.PZ)(me.A,p).clone().normalize();const{multidimensionalDefinition:b,timeExtent:I}=_,{rasterInfo:R}=this,{hasMultidimensionalTranspose:T,multidimensionalInfo:A}=R;let{transposedVariableName:M}=_;const k=null!=A&&T&&(null!=I||(0,se.DY)(b));var C;k&&!M&&(M=null!=b&&b.length>0?null!==(C=b[0].variableName)&&void 0!==C?C:void 0:A.variables[0].name,_={..._,transposedVariableName:M});_=this._getRequestOptionsWithSliceId(_);const{spatialReference:O,extent:D}=R,{datumTransformation:B}=_;let N=(0,ue._I)(p,O,B);if(!D.intersects(N))return{location:N,value:null};if(null!=R.transform){const p=R.transform.inverseTransform(N);if(!R.nativeExtent.intersects(p))return{location:p,value:null};N=p}let z=0;const J=null!=M&&null!=A&&R.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const p=this.primaryRasters.rasters[0];if(J)return p.identify(N,_);const{pixelSize:y}=R,w=3,I=y.x*w/2,T=y.y*w/2,A=new fe.A({xmin:N.x-I,xmax:N.x+I,ymin:N.y-T,ymax:N.y+T,spatialReference:O}),M={interpolation:"nearest",multidimensionalDefinition:b,sliceId:_.sliceId},{pixelBlock:k}=await p.fetchPixels(A,w,w,M),{pixelBlock:C}=await this.fetchPixels(A,w,w,M);if(null==k)return{location:N,value:null};const P=Math.floor(w*w*.5),D=!k.mask||k.mask[P]?k.pixels.map((p=>p[P])):null;let B;return null!=C&&(B=!C.mask||C.mask[P]?C.pixels.map((p=>p[P])):void 0),{location:N,value:D,processedValue:B,pyramidLevel:0}}if(!J)if(_.srcResolution)z=(0,ue.t$)(_.srcResolution,R,this.ioConfig.sampling).pyramidLevel;else if(z=await this.computeBestPyramidLevelForLocation(p,_),null==z)return{location:N,value:null};const E=this.identifyPixelLocation(N,z,null,J);if(null===E)return{location:N,value:null};const{row:H,col:U,rowOffset:G,colOffset:W,blockWidth:q}=E,Z=null!==(y=M)&&void 0!==y?y:_.sliceId,j=(0,ae.ph)(this.rasterId,Z),V="".concat(z,"/").concat(H,"/").concat(U);let Y=(0,ae.gd)(j,null,V);null==Y&&(Y=this.fetchRawTile(z,H,U,_),(0,ae.no)(j,null,V,Y));const X=await Y;if(null===X||void 0===X||null===(w=X.pixels)||void 0===w||!w.length)return{location:N,value:null};const K=G*q+W;return this._processIdentifyResult(X,{srcLocation:N,position:K,pyramidLevel:z,useTransposedTile:!!J,requestSomeSlices:k,identifyOptions:_})}async fetchPixels(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};p=(0,ue.Ps)(p),_=this._getRequestOptionsWithSliceId(_);const{_hasNoneOrGCSShiftTransform:b}=this;if(_.requestRawData&&b)return this._fetchPixels(p,y,w,_);const I=(0,ue.FT)(p.spatialReference),R=(0,ue.OM)(p);if(null==I||0===R||1===R&&this._isGlobalWrappableSource&&b)return this._fetchPixels(p,y,w,_);if(R>=3)return{extent:p,pixelBlock:null};const T=[],{xmin:A,xmax:M}=p,k=Math.round(I/(M-A)*y),C=k-Math.round((I/2-A)/(M-A)*y);let P=0;const O=[];for(let z=0;z<=R;z++){const b=new fe.A({xmin:0===z?A:-I/2,xmax:z===R?M-I*z:I/2,ymin:p.ymin,ymax:p.ymax,spatialReference:p.spatialReference}),D=0===z?k-C:z===R?y-P:k;P+=D,O.push(D);const B=_.disableWrapAround&&z>0?null:this._fetchPixels(b,D,w,_);T.push(B)}const D=(await Promise.all(T)).map((p=>null===p||void 0===p?void 0:p.pixelBlock));let B=null;const N={width:y,height:w};return B=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:D,srcMosaicSize:N,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:O},_)).pixelBlock:(0,ce.z7)(D,N,{blockWidths:O}),{extent:p,srcExtent:(0,ue._l)(p,this.rasterInfo.spatialReference,_.datumTransformation),pixelBlock:B}}async fetchRawPixels(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};y={x:Math.floor(y.x),y:Math.floor(y.y)};const b=await this._fetchRawTiles(p,y,w,_),{nativeExtent:I,nativePixelSize:R,storageInfo:T}=this.rasterInfo,A=2**p,M=R.x*A,k=R.y*A,C=new fe.A({xmin:I.xmin+M*y.x,xmax:I.xmin+M*(y.x+w.width-1),ymin:I.ymax-k*(y.y+w.height-1),ymax:I.ymax-k*y.y,spatialReference:I.spatialReference});if(!b)return{extent:C,srcExtent:C,pixelBlock:null};const{pixelBlocks:P,mosaicSize:O}=b;if(1===P.length&&null!=P[0]&&P[0].width===w.width&&P[0].height===w.height)return{extent:C,srcExtent:C,pixelBlock:b.pixelBlocks[0]};const D=p>0?T.pyramidBlockWidth:T.blockWidth,B=p>0?T.pyramidBlockHeight:T.blockHeight,N={x:y.x%D,y:y.y%B};let z;return z=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:P,srcMosaicSize:O,destDimension:w,clipOffset:N,clipSize:w,coefs:null,sampleSpacing:null,interpolation:_.interpolation,alignmentInfo:null,blockWidths:null},_)).pixelBlock:(0,ce.z7)(P,O,{clipOffset:N,clipSize:w}),{extent:C,srcExtent:C,pixelBlock:z}}fetchRawTile(p,y,w,_){throw new R.A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(p){return(0,ue._l)(this.rasterInfo.extent,p)}decodePixelBlock(p,y){return!this.rasterJobHandler||y.useCanvas?(0,le.D)(p,y):this.rasterJobHandler.decode({data:p,options:y})}async request(p,y){var w,_;let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const{customFetchParameters:I}=this.ioConfig,{range:R,query:T,headers:A}=y;b=null!==(w=null!==(_=b)&&void 0!==_?_:y.retryCount)&&void 0!==w?w:this.ioConfig.retryCount;const M=R?{Range:"bytes=".concat(R.from,"-").concat(R.to)}:null;try{return await(0,U.A)(p,{...y,query:{...T,...I},headers:{...A,...M}})}catch(k){if(b>0)return b--,this.request(p,y,b);throw k}}getSliceIndex(p){const{multidimensionalInfo:y}=this.rasterInfo;return null==y||null==p||0===p.length?null:(0,se.NG)(p,y)}getTileExtentFromTileInfo(p,y,w,_){const b=_.lodAt(p);return this.getTileExtent({x:b.resolution,y:b.resolution},y,w,_.origin,_.spatialReference,_.size)}updateTileInfo(){const{storageInfo:p,spatialReference:y,extent:w,pixelSize:_}=this.rasterInfo;if(!p.tileInfo){const b=[],I=p.maximumPyramidLevel||0;let R=Math.max(_.x,_.y),T=1/.0254*96*R;for(let p=0;p<=I;p++)b.unshift(new ne.A({level:I-p,resolution:R,scale:T})),R*=2,T*=2;const A=new me.A({x:w.xmin,y:w.ymax,spatialReference:y});p.tileInfo=new Q.A({origin:A,size:[p.blockWidth,p.blockHeight],spatialReference:y,lods:b}),p.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(p){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:512,w=arguments.length>2&&void 0!==arguments[2]?arguments[2]:512,_=arguments.length>3?arguments[3]:void 0;const{width:b,height:I,nativeExtent:R,pixelSize:T,spatialReference:A}=p,M=new me.A({x:R.xmin,y:R.ymax,spatialReference:A});null==_&&(_=Math.max(0,Math.round(Math.log(Math.max(b,I))/Math.LN2-8)));const k=this.computeBlockBoundary(R,512,512,{x:R.xmin,y:R.ymax},[T],_);p.storageInfo=new re.A({blockWidth:y,blockHeight:w,pyramidBlockWidth:y,pyramidBlockHeight:w,origin:M,firstPyramidLevel:1,maximumPyramidLevel:_,blockBoundary:k})}async computeBestPyramidLevelForLocation(p){return 0}computeBlockBoundary(p,y,w,_,b){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,R=arguments.length>6&&void 0!==arguments[6]?arguments[6]:2;if(1===b.length&&I>0){b=[...b];let{x:p,y:y}=b[0];for(let w=0;w<I;w++)p*=R,y*=R,b.push({x:p,y:y})}const T=[],{x:A,y:M}=_;for(let k=0;k<b.length;k++){const{x:_,y:I}=b[k];T.push({minCol:Math.floor((p.xmin-A+.1*_)/y/_),maxCol:Math.floor((p.xmax-A-.1*_)/y/_),minRow:Math.floor((M-p.ymax+.1*I)/w/I),maxRow:Math.floor((M-p.ymin-.1*I)/w/I)})}return T}getPyramidPixelSize(p){const{nativePixelSize:y}=this.rasterInfo,{pyramidResolutions:w,pyramidScalingFactor:_}=this.rasterInfo.storageInfo;if(0===p)return y;if(null!=w&&w.length)return w[p-1];const b=_**p;return{x:y.x*b,y:y.y*b}}identifyPixelLocation(p,y,w,_){const{spatialReference:b,nativeExtent:I,storageInfo:R}=this.rasterInfo,{maximumPyramidLevel:T,origin:A,transposeInfo:M}=R,k=_&&null!=M?M.tileSize[0]:R.blockWidth,C=_&&null!=M?M.tileSize[1]:R.blockHeight,P=(0,ue._I)(p,b,w);if(!I.intersects(P))return null;if(y<0||y>T)return null;const O=this.getPyramidPixelSize(y),{x:D,y:B}=O,N=(A.y-P.y)/B/C,z=(P.x-A.x)/D/k,J=Math.min(C-1,Math.floor((N-Math.floor(N))*C)),E=Math.min(k-1,Math.floor((z-Math.floor(z))*k));return{pyramidLevel:y,row:Math.floor(N),col:Math.floor(z),rowOffset:J,colOffset:E,blockWidth:k,srcLocation:P}}getTileExtent(p,y,w,_,b,I){const[R,T]=I,A=_.x+w*R*p.x,M=A+R*p.x,k=_.y-y*T*p.y,C=k-T*p.y;return new fe.A({xmin:A,xmax:M,ymin:C,ymax:k,spatialReference:b})}getBlockWidthHeight(p){return{blockWidth:p>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:p>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(p,y,w){const _=this.rasterInfo.storageInfo.blockBoundary[p];return!_||_.maxRow<y||_.maxCol<w||_.minRow>y||_.minCol>w}updateImageSpaceRasterInfo(p){const{extent:y,pixelSize:w}=p;if(-.5===y.xmin&&.5===y.ymax&&1===w.x&&1===w.y&&null==p.transform)return;const{width:_,height:b}=p,I=pe.A.WebMercator;p.spatialReference=I,p.extent=p.nativeExtent=new fe.A({xmin:-.5,ymax:.5,xmax:_-.5,ymin:.5-b,spatialReference:I}),p.isPseudoSpatialReference=!0,p.transform=null,p.pixelSize=new me.A({x:1,y:1,spatialReference:I});const{extent:R,storageInfo:T}=p;if(T){T.origin=new me.A({x:R.xmin,y:R.ymax,spatialReference:I});const{tileInfo:y}=T;if(y){y.origin=T.origin;const w=(p.nativePixelSize.x+p.nativePixelSize.y)/2;y.lods.forEach(((p,y)=>{p.resolution=w*2**y,p.scale=96*p.resolution/.0254}))}}}async _fetchPixels(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},b=(0,ue.OM)(p);if(b>=2)return{extent:p,pixelBlock:null};const I=this._getSourceDataInfo(p,y,w,_),{pyramidLevel:R,srcResolution:T,srcExtent:A,srcWidth:M,srcHeight:k,ul:C}=I;if(0===M||0===k)return{extent:p,srcExtent:A,pixelBlock:null};const{rasterInfo:P}=this,O=P.transform,D="gcs-shift"===(null===O||void 0===O?void 0:O.type),B=null!=(0,ue.FT)(p.spatialReference);!D&&B||(b=(0,ue.OM)(I.srcExtent,D));const N=await this._fetchRawTiles(R,C,{width:M,height:k,wrapCount:b},_);if(!N)return{extent:p,srcExtent:A,pixelBlock:null};const z=P.storageInfo,J=R>0?z.pyramidBlockWidth:z.blockWidth,E=R>0?z.pyramidBlockHeight:z.blockHeight;let{x:H,y:U}=P.pixelSize;if(R>0){const{pyramidResolutions:p,pyramidScalingFactor:y}=z;if(null!=p&&p[R-1])({x:H,y:U}=p[R-1]);else{const p=y**R;H*=p,U*=p}}const G=P.spatialReference,W=new me.A({x:H,y:U,spatialReference:G}),q=J===M&&E===k&&C.x%J==0&&C.y%E==0,Z=new me.A({x:(p.xmax-p.xmin)/y,y:(p.ymax-p.ymin)/w,spatialReference:p.spatialReference}),j=!p.spatialReference.equals(G),V=G.isGeographic?1e-9:1e-4,{datumTransformation:Y}=_;if(!j&&q&&1===N.pixelBlocks.length&&J===y&&E===w&&this._isSameResolution(T,Z,V))return{extent:p,srcExtent:A,srcTilePixelSize:W,pixelBlock:N.pixelBlocks[0]};const X=B&&null!=(0,ue.FT)(A.spatialReference)&&this._hasNoneOrGCSShiftTransform,K=_.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");K&&!this.rasterJobHandler&&await(0,ue.Hh)();const Q=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:p,srcBufferExtent:N.extent,pixelSize:Z.toJSON(),datumTransformation:Y,rasterTransform:O,hasWrapAround:b>0||X,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:K},_):(0,ue.l0)({projectedExtent:p,srcBufferExtent:N.extent,pixelSize:Z,datumTransformation:Y,rasterTransform:O,hasWrapAround:b>0||X,isAdaptive:!1,includeGCSGrid:K});let ee;const te=!_.requestRawData,ie={rows:Q.spacing[0],cols:Q.spacing[1]},ne=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(R,N.extent.xmin):void 0,{pixelBlocks:re,mosaicSize:se,isPartiallyFilled:ae}=N;let oe=null;if(this.rasterJobHandler){const p=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:re,srcMosaicSize:se,destDimension:te?{width:y,height:w}:null,coefs:te?Q.coefficients:null,sampleSpacing:te?ie:null,projectDirections:K,gcsGrid:K?Q.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:_.interpolation,alignmentInfo:ne,blockWidths:null},_);({pixelBlock:ee,localNorthDirections:oe}=p)}else{const p=(0,ce.z7)(re,se,{alignmentInfo:ne});ee=te?(0,ce.$i)(p,{width:y,height:w},Q.coefficients,ie,_.interpolation):p,K&&Q.gcsGrid&&(oe=(0,ce.QF)({width:y,height:w},Q.gcsGrid),ee=(0,he.Y2)(ee,this.rasterInfo.dataType,oe))}return _.requestRawData||K?{extent:p,srcExtent:A,srcTilePixelSize:W,pixelBlock:ee,transformGrid:Q,localNorthDirections:oe,isPartiallyFilled:ae}:{extent:p,srcExtent:A,srcTilePixelSize:W,pixelBlock:ee}}async _fetchRawTiles(p,y,w,_){const{origin:b,blockBoundary:I}=this.rasterInfo.storageInfo,{blockWidth:R,blockHeight:T}=this.getBlockWidthHeight(p);let{x:A,y:M}=y,{width:k,height:C,wrapCount:P}=w;const O=this._getRasterTileAlignmentInfo(p,0);_.buffer&&(A-=_.buffer.cols,M-=_.buffer.rows,k+=2*_.buffer.cols,C+=2*_.buffer.rows);let D=0,B=0,N=0;P&&null!=O&&(({worldColumnCountFromOrigin:B,originColumnOffset:N,rightPadding:D}=O),B*O.blockWidth-D>=A+k&&(D=0));const z=Math.floor(A/R),J=Math.floor(M/T),E=Math.floor((A+k+D-1)/R),H=Math.floor((M+C+D-1)/T),U=I[p];if(!U)return null;const{minRow:G,minCol:W,maxCol:q,maxRow:Z}=U;if(0===P&&(H<G||E<W||J>Z||z>q))return null;const j=new Array;let V=!1;const Y=null==this.ioConfig.allowPartialFill?_.allowPartialFill:this.ioConfig.allowPartialFill;for(let ne=J;ne<=H;ne++)for(let y=z;y<=E;y++){let w=y;if(!_.disableWrapAround&&P&&null!=O&&B<=y&&(w=y-B-N),ne>=G&&w>=W&&Z>=ne&&q>=w){const y=this._tileFetchQueue.push({pyramidLevel:p,row:ne,col:w,options:_},{signal:_.signal});Y?j.push(new Promise((p=>{y.then((y=>p(y))).catch((()=>{V=!0,p(null)}))}))):j.push(y)}else j.push(Promise.resolve(null))}if(0===j.length)return null;const X=await Promise.all(j),K={height:(H-J+1)*T,width:(E-z+1)*R},{spatialReference:Q}=this.rasterInfo,ee=this.getPyramidPixelSize(p),{x:te,y:ie}=ee;return{extent:new fe.A({xmin:b.x+z*R*te,xmax:b.x+(E+1)*R*te,ymin:b.y-(H+1)*T*ie,ymax:b.y-J*T*ie,spatialReference:Q}),pixelBlocks:X,mosaicSize:K,isPartiallyFilled:V}}_isSameResolution(p,y,w){return Math.abs(p.x-y.x)<w&&Math.abs(p.y-y.y)<w}_fetchRawTile(p,y,w,_){const b=this.rasterInfo.storageInfo.blockBoundary[p];if(!b)return Promise.resolve(null);const{minRow:I,minCol:R,maxCol:T,maxRow:A}=b;if(y<I||w<R||y>A||w>T)return Promise.resolve(null);const k=(0,ae.ph)(this.rasterId,_.sliceId),C="".concat(p,"/").concat(y,"/").concat(w);let P=(0,ae.gd)(k,_.registryId,C);if(null==P){const b=new AbortController;P=this.fetchRawTile(p,y,w,{..._,signal:b.signal}),(0,ae.no)(k,_.registryId,C,P,b),P.catch((()=>(0,ae.zo)(k,_.registryId,C)))}return _.signal&&(0,M.u7)(_,(()=>{(0,ae.jX)(k,_.registryId,C)})),P}_computeMagDirValues(p){var y;const{bandCount:w,dataType:_}=this.rasterInfo;if((2!==w||"vector-magdir"!==_)&&"vector-uv"!==_||2!==(null===p||void 0===p?void 0:p.length)||null===(y=p[0])||void 0===y||!y.length)return null;const b=p[0].length;if("vector-magdir"===_){const y=p[1].map((p=>(p+360)%360));return[p[0],y]}const[I,R]=p,T=[],A=[];for(let M=0;M<b;M++){const[p,y]=(0,he.Lu)([I[M],R[M]]);T.push(p),A.push(y)}return[T,A]}_getRasterTileAlignmentInfo(p,y){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=(0,ue.DO)(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:y,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[p]}}_getSourceDataInfo(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const b={datumTransformation:_.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};_.srcResolution&&(b.srcResolution=_.srcResolution,this._updateSourceDataInfo(p,b));const I=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:R,srcHeight:T,pyramidLevel:A}=b,M=R/y,k=T/w,C=A<I&&M*k>=16,P=A===I&&this._requireTooManySrcTiles(R,T,y,w);if(C||P||0===R||0===T){const R=new me.A({x:(p.xmax-p.xmin)/y,y:(p.ymax-p.ymin)/w,spatialReference:p.spatialReference});let T=(0,ue.Wo)(R,this.rasterInfo.spatialReference,p,b.datumTransformation);const P=!T||_.srcResolution&&T.x+T.y<_.srcResolution.x+_.srcResolution.y;if(C&&_.srcResolution&&P){const p=Math.round(Math.log(Math.max(M,k))/Math.LN2)-1;if(I-A+3>=p){const y=2**p;T={x:_.srcResolution.x*y,y:_.srcResolution.y*y}}}T&&(b.srcResolution=T,this._updateSourceDataInfo(p,b))}return this._requireTooManySrcTiles(b.srcWidth,b.srcHeight,y,w)&&(b.srcWidth=0,b.srcHeight=0),b}_requireTooManySrcTiles(p,y,w,_){const{tileInfo:b}=this.rasterInfo.storageInfo,I=p/w,R=y/_;return Math.ceil(p/b.size[0])*Math.ceil(y/b.size[1])>=256*Math.max(1,(w+_)/1024)||I>8||R>8}_updateSourceDataInfo(p,y){y.srcWidth=0,y.srcHeight=0;const{rasterInfo:w}=this,_=w.spatialReference,{srcResolution:b,datumTransformation:I}=y,{pyramidLevel:R,pyramidResolution:T,excessiveReading:A}=(0,ue.t$)(b,w,this.ioConfig.sampling);if(A)return;let M=y.srcExtent||(0,ue._l)(p,_,I);if(null==M)return;const k=w.transform;k&&(M=k.inverseTransform(M)),y.srcExtent=M;const{x:C,y:P}=w.storageInfo.origin,O=Math.floor((M.xmin-C)/T.x+.1),D=Math.floor((P-M.ymax)/T.y+.1),B=Math.floor((M.xmax-C)/T.x-.1),N=Math.floor((P-M.ymin)/T.y-.1),z=M.width<.1*T.x?0:B-O+1,J=M.height<.1*T.y?0:N-D+1;y.pyramidLevel=R,y.pyramidResolution=T,y.srcWidth=z,y.srcHeight=J,y.ul={x:O,y:D}}_getRequestOptionsWithSliceId(p){return null!=this.rasterInfo.multidimensionalInfo&&null==p.sliceId&&(p={...p,sliceId:this.getSliceIndex(p.multidimensionalDefinition)}),p}_processIdentifyResult(p,y){const{srcLocation:w,position:_,pyramidLevel:b,useTransposedTile:I}=y,R=p.pixels[0].length/p.width/p.height;if(p.mask&&!p.mask[_])return{location:w,value:null};const{multidimensionalInfo:T}=this.rasterInfo;if(null==T||!I){const y=p.pixels.map((p=>p[_])),I={location:w,value:y,pyramidLevel:b},R=this._computeMagDirValues(y.map((p=>[p])));return null!==R&&void 0!==R&&R.length&&(I.magdirValue=R.map((p=>p[0]))),I}let A=p.pixels.map((p=>p.slice(_*R,_*R+R))),M=this._computeMagDirValues(A);const{requestSomeSlices:k,identifyOptions:C}=y;let P=(0,se.QW)(T,C.transposedVariableName);if(k){var O;const p=(0,se.xx)(P,C.multidimensionalDefinition,C.timeExtent);A=A.map((y=>p.map((p=>y[p])))),M=null===(O=M)||void 0===O?void 0:O.map((y=>p.map((p=>y[p])))),P=p.map((p=>P[p]))}const D=p.noDataValues||this.rasterInfo.noDataValue,B={pixels:A,pixelType:p.pixelType};let N;return null!=D&&((0,oe.Sp)(B,D),N=B.mask),{location:w,value:null,dataSeries:P.map(((p,y)=>{var w,_;const b={value:0===(null===(w=N)||void 0===w?void 0:w[y])?null:A.map((p=>p[y])),multidimensionalDefinition:p.multidimensionalDefinition.map((p=>new V.A({...p,isSlice:!0})))};return null!==(_=M)&&void 0!==_&&_.length&&(b.magdirValue=[M[0][y],M[1][y]]),b})),pyramidLevel:b}}};(0,_._)([(0,C.MZ)()],ge.prototype,"_rasterTileAlignmentInfo",void 0),(0,_._)([(0,C.MZ)()],ge.prototype,"_tileFetchQueue",void 0),(0,_._)([(0,C.MZ)({readOnly:!0})],ge.prototype,"_isGlobalWrappableSource",null),(0,_._)([(0,C.MZ)({readOnly:!0})],ge.prototype,"_hasNoneOrGCSShiftTransform",null),(0,_._)([(0,C.MZ)()],ge.prototype,"rasterJobHandler",null),(0,_._)([(0,C.MZ)({readOnly:!0})],ge.prototype,"rasterId",null),(0,_._)([(0,C.MZ)(j.OZ)],ge.prototype,"url",null),(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],ge.prototype,"datasetName",void 0),(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],ge.prototype,"datasetFormat",void 0),(0,_._)([(0,C.MZ)()],ge.prototype,"hasUniqueSourceStorageInfo",void 0),(0,_._)([(0,C.MZ)()],ge.prototype,"rasterInfo",void 0),(0,_._)([(0,C.MZ)()],ge.prototype,"ioConfig",void 0),(0,_._)([(0,C.MZ)()],ge.prototype,"sourceJSON",void 0),ge=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.BaseRaster")],ge);const ve=ge;var xe=w(49049),we=w(68854);async function clipUtils_a(p,y,_){if("extent"===_.type)return function o(p,y,w){const{width:_,height:b}=p,I=new Uint8Array(_*b),R=y.width/_,T=y.height/b;if(w.width/R<.5||w.height/T<.5)return new we.A({pixelType:p.pixelType,width:_,height:b,mask:I,pixels:[...p.pixels]});const{xmin:A,xmax:M,ymin:k,ymax:C}=y,{xmin:P,xmax:O,ymin:D,ymax:B}=w,N=Math.max(A,P),z=Math.min(M,O),J=Math.max(k,D),E=Math.min(C,B),H=.5*R,U=.5*T;if(z-N<H||E-J<U||z<A+H||N>M-H||J>C-U||E<k+U)return new we.A({pixelType:p.pixelType,width:_,height:b,mask:I,pixels:[...p.pixels]});const G=Math.max(0,(N-A)/R),W=Math.min(_,Math.max(0,(z-A)/R)),q=Math.max(0,(C-E)/T),Z=Math.min(b,Math.max(0,(C-J)/T)),j=Math.round(G),V=Math.round(W)-1,Y=Math.round(q),X=Math.round(Z)-1;if(j===V&&G%1>.5&&W%1<.5||Y===X&&q%1>.5&&Z%1<.5)return new we.A({pixelType:p.pixelType,width:_,height:b,mask:I,pixels:[...p.pixels]});if(0===j&&0===Y&&V===_&&X===b)return p;const K=p.mask;for(let Q=Y;Q<=X;Q++)for(let p=j;p<=V;p++){const y=Q*_+p;I[y]=K?K[y]:255}return new we.A({pixelType:p.pixelType,width:_,height:b,mask:I,pixels:[...p.pixels]})}(p,y,_);const{width:b,height:I}=p,R=new Uint8Array(b*I),{contains:T,intersects:A}=await Promise.all([w.e(8300),w.e(8583)]).then(w.bind(w,78583));return A(y,_)?"polyline"===_.type?function r(p,y,w){const{width:_,height:b}=p,I=new Uint8Array(_*b),R=y.width/_,T=y.height/b,{xmin:A,ymax:M}=y,{paths:k}=w,C=p.mask;for(let P=0;P<k.length;P++){const p=k[P];for(let y=0;y<p.length-1;y++){const[w,k]=p[y],[P,O]=p[y+1];let D=Math.floor((M-k)/T),B=Math.floor((M-O)/T);if(B<D){const p=D;D=B,B=p}D=Math.max(0,D),B=Math.min(b-1,B);const N=(P-w)/(O-k);for(let p=D;p<=B;p++){const y=p===D?Math.max(k,O):(b+1-p)*T,M=p===B?Math.min(k,O):y-T;let z=O===k?Math.floor((w-A)/R):Math.floor((N*(y-k)+w-A)/R),J=O===k?Math.floor((P-A)/R):Math.floor((N*(M-k)+w-A)/R);if(J<z){const p=z;z=J,J=p}const E=p*_;z=Math.max(0,z),J=Math.min(_-1,J);for(let p=E+z;p<=E+J;p++)I[p]=C?C[p]:255}}}return new we.A({pixelType:p.pixelType,width:_,height:b,mask:I,pixels:[...p.pixels]})}(p,y,_):T(_,y)?p:function h(p,y,w){if(!p)return p;const{width:_,height:b}=p,I=y.width/_,R=y.height/b,{xmin:T,ymax:A}=y;let M;if("extent"===w.type){const p=(w.xmin-T)/I,y=(w.xmax-T)/I,_=(A-w.ymax)/R,b=(A-w.ymin)/R;M=[[[p,_],[p,b],[y,b],[y,_],[p,_]]]}else M=w.rings.map((p=>p.map((p=>{let[y,w]=p;return[(y-T)/I,(A-w)/R]}))));const k=document.createElement("canvas");k.width=_,k.height=b;const C=k.getContext("2d");C.fillStyle="#f00",C.beginPath(),M.forEach((p=>{C.moveTo(p[0][0],p[0][1]);for(let y=0;y<p.length;y++)C.lineTo(p[y][0],p[y][1]);C.closePath()})),C.fill();const P=C.getImageData(0,0,_,b).data,O=p.mask,D=_*b,B=new Uint8Array(D);for(let N=0;N<D;N++)O&&!O[N]||(B[N]=P[4*N+3]>127?255:0);return new we.A({pixelType:p.pixelType,width:_,height:b,mask:B,maskIsAlpha:!1,pixels:[...p.pixels]})}(p,y,_):new we.A({pixelType:p.pixelType,width:b,height:I,mask:R,maskIsAlpha:!1,pixels:[...p.pixels]})}function x(p,y,w){let _=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const{spatialReference:b}=p,{x:I,y:R}=function n(p,y){if(p.spatialReference.equals(y))return p;const w=(0,xe.GA)(p.spatialReference),_=(0,xe.GA)(y);if(w===_)return p;const b=w/_;return{x:p.x*b,y:p.y*b}}(w,b);let T,A,M;const k="extent"===y.type?y:y.extent;let{xmin:C,xmax:P,ymax:O,ymin:D}=k;const{xmin:B,ymax:N}=p.extent;return _?(C=B+(C>B?I*Math.round((C-B)/I):0),O=N-(O<N?R*Math.round((N-O)/R):0),P=B+(P>B?I*Math.round((P-B)/I):0),D=N-(D<N?R*Math.round((N-D)/R):0),T=new fe.A({xmin:C,ymax:O,xmax:P,ymin:D,spatialReference:b}),A=Math.round(T.width/I),M=Math.round(T.height/R)):(A=Math.floor((P-C)/I+.8),M=Math.floor((O-D)/R+.8),C=B+(C>B?I*Math.floor((C-B)/I+.1):0),O=N-(O<N?R*Math.floor((N-O)/R+.1):0),P=C+A*I,D=O-M*R,T=new fe.A({xmin:C,ymax:O,xmax:P,ymin:D,spatialReference:b})),{extent:T,width:A,height:M}}var _e=w(94309);let be=class extends ve{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async open(p){var y,w,_,b;await this.init();const{rasterFunction:I}=this;null!==(y=this.primaryRasters)&&void 0!==y&&null!==(y=y.rasters)&&void 0!==y&&y.length?I.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=I.getPrimaryRasters(),this.rasterJobHandler&&(null===(w=this.primaryRasters.rasters)||void 0===w||w.forEach((p=>p.rasterJobHandler=this.rasterJobHandler))));const{rasters:T,rasterIds:A}=this.primaryRasters,M=T.map((y=>y.rasterInfo?void 0:y.open(p)));await Promise.all(M);const k=T.map((p=>{let{rasterInfo:y}=p;return y})),C=I.bind({rasterInfos:k,rasterIds:A});if(I.rawSourceRasterInfos=k,!C.success||0===k.length)throw new R.A("raster-function:open","cannot bind the function: ".concat(null!==(_=C.error)&&void 0!==_?_:""));const P="Table"===I.functionName?I:null===(b=I.functionArguments)||void 0===b?void 0:b.raster;"Table"===(null===P||void 0===P?void 0:P.functionName)&&(I.rasterInfo.attributeTable=_e.A.fromJSON(P.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const O=k[0];this.hasUniqueSourceStorageInfo=1===k.length||k.slice(1).every((p=>this._hasSameStorageInfo(p,O))),this.set("sourceJSON",T[0].sourceJSON),this.set("rasterInfo",I.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var p;return null===(p=this.rasterJobHandler)||void 0===p?void 0:p.updateRasterFunction(this.rasterFunction)}async fetchPixels(p,y,w){var _,b,I;let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{rasters:T,rasterIds:A}=this.primaryRasters;let M=!1;const{interpolation:k}=R,C=null===(_=this.rasterFunction.flatWebGLFunctionChain)||void 0===_?void 0:_.hasFocalFunction;!R.requestRawData&&C&&(M=1===T.length&&!R.skipRasterFunction,R={...R,interpolation:"bilinear",requestRawData:M});const P=T.map((_=>_.fetchPixels(p,y,w,R))),O=await Promise.all(P),D=O.map((p=>p.pixelBlock)),B=M||R.requestRawData?O.map((p=>p.srcTilePixelSize)):null;if(R.skipRasterFunction||D.every((p=>null==p)))return O[0];const N=null!==(b=null===(I=O.find((p=>null!=p.pixelBlock)))||void 0===I?void 0:I.extent)&&void 0!==b?b:p;let z=this.rasterJobHandler?await this.rasterJobHandler.process({extent:N,primaryPixelBlocks:D,primaryPixelSizes:B,primaryRasterIds:A}):this.rasterFunction.process({extent:N,primaryPixelBlocks:D,primaryPixelSizes:B,primaryRasterIds:A});const{transformGrid:J}=O[0];if(!M||null==z||null==J){const p=R.noClip?null:this.getClippingGeometry(N.spatialReference);return R.noClip||R.requestRawData||null==z||!p||(z=await clipUtils_a(z,N,p)),{...O[0],pixelBlock:z}}const E={rows:J.spacing[0],cols:J.spacing[1]};let H;H=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[z],srcMosaicSize:{width:z.width,height:z.height},destDimension:{width:y,height:w},coefs:J.coefficients,sampleSpacing:E,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:k,alignmentInfo:void 0,blockWidths:null},R)).pixelBlock:(0,ce.$i)(z,{width:y,height:w},J.coefficients,E,k);const U=R.noClip?null:this.getClippingGeometry(p.spatialReference);return R.noClip||R.requestRawData||null==H||null==U||(H=await clipUtils_a(H,p,U)),{extent:p,srcExtent:O[0].srcExtent,pixelBlock:H}}getClippingGeometry(p){const y=this._clippingGeometry.get("0");if(!p||!y)return y;const w=this._getSRKey(p);let _=this._clippingGeometry.get(w);return null!=_||(_=p.equals(y.spatialReference)?y:(0,ue.uk)(y,p),this._clippingGeometry.set(w,_)),_}_hasSameStorageInfo(p,y){const{storageInfo:w,pixelSize:_,spatialReference:b,extent:I}=p,{storageInfo:R,pixelSize:T,spatialReference:A,extent:M}=y;return _.x===T.x&&_.y===T.y&&b.equals(A)&&I.equals(M)&&w.blockHeight===R.blockHeight&&w.blockWidth===R.blockWidth&&w.maximumPyramidLevel===R.maximumPyramidLevel}async _updateClipGeometry(){const p=this.rasterFunction.getClippingGeometries()[0];let y=null===p||void 0===p?void 0:p.clippingGeometry;if(y&&"inside"===p.clippingType){const{extent:p}=this.rasterInfo,{difference:_,densify:b}=await Promise.all([w.e(8300),w.e(8583)]).then(w.bind(w,78583));let I=b(ee.A.fromExtent(p),2*(p.width+p.height)/40);I=(0,ue.uk)(I,y.spatialReference),y=_(I,y)}this._clippingGeometry.clear(),y&&this._clippingGeometry.set("0",y)}_getSRKey(p){var y,w;return String(null!==(y=null!==(w=p.wkid)&&void 0!==w?w:p.wkt)&&void 0!==y?y:p.wkt2)}};(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],be.prototype,"datasetFormat",void 0),(0,_._)([(0,C.MZ)()],be.prototype,"tileType",void 0),(0,_._)([(0,C.MZ)()],be.prototype,"rasterFunction",void 0),(0,_._)([(0,C.MZ)()],be.prototype,"primaryRasters",void 0),be=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.FunctionRaster")],be);const Ie=be;var Se=w(12945),Re=w(37050),Te=w(39249),Ae=w(24766),Me=w(19266),ke=w(72013);const L=p=>{let y=class extends p{constructor(){var p;super(...arguments),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===(null===(p=arguments.length<=0?void 0:arguments[0])||void 0===p||null===(p=p.raster)||void 0===p?void 0:p.datasetFormat)}get fullExtent(){var p;return null===(p=this.serviceRasterInfo)||void 0===p?void 0:p.extent}set multidimensionalDefinition(p){this._set("multidimensionalDefinition",p),this.updateRenderer()}set rasterFunction(p){var y;"none"===(null===(y=p)||void 0===y||null===(y=y.functionName)||void 0===y?void 0:y.toLowerCase())&&(p=void 0),this._set("rasterFunction",p),this.updateRasterFunction()}get rasterInfo(){return(0,G.Lx)(T.A.getLogger(this),"rasterInfo",{replacement:"serviceRasterInfo",version:"4.29",warnOnce:!0}),this._get("serviceRasterInfo")}set url(p){this._set("url",(0,Z.Jf)(p,T.A.getLogger(this)))}set renderer(p){null==p&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",p),this.updateRenderer())}readRenderer(p,y,w){var _;const b=null===y||void 0===y||null===(_=y.layerDefinition)||void 0===_||null===(_=_.drawingInfo)||void 0===_?void 0:_.renderer;return(0,H.LF)(b,w)||void 0}async convertVectorFieldData(p,y){const{serviceRasterInfo:w}=this;if(null==p||!w)return null;const _=this._rasterJobHandler.instance,b=w.dataType;return _?_.convertVectorFieldData({pixelBlock:p,dataType:b},y):(0,he.FI)(p,b)}async computeStatisticsHistograms(p,y){var w;p=(0,P.PZ)(Me.A,p).clone();const{serviceRasterInfo:_}=this,{geometry:b}=p;if(null==b)throw new R.A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let I=b;const{spatialReference:T}=_;b.spatialReference.equals(T)||(await(0,ue.Hh)(),I="extent"===b.type?(0,ue._l)(b,T):(0,ue.uk)(b,T));const A=null!==(w=p.pixelSize)&&void 0!==w?w:new me.A({x:_.pixelSize.x,y:_.pixelSize.y,spatialReference:T}),{extent:M,width:k,height:C}=x(_,I,A),O=await this.fetchPixels(M,k,C,{...y,interpolation:"nearest"});if(null==O.pixelBlock)throw new R.A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const D=await clipUtils_a(O.pixelBlock,M,I),B=this._rasterJobHandler.instance;return B?B.computeStatisticsHistograms({pixelBlock:D},y):(0,Re.eH)(D)}async createFlowMesh(p,y){const w=this._rasterJobHandler.instance;return w?w.createFlowMesh(p,y):(0,ke.CW)(p.meshType,p.simulationSettings,p.flowData,null!=y.signal?y.signal:(new AbortController).signal)}normalizeRasterFetchOptions(p){var y,w;const{multidimensionalInfo:_}=null!==(y=this.serviceRasterInfo)&&void 0!==y?y:{};if(null==_)return p;let b=p.multidimensionalDefinition||this.multidimensionalDefinition;(null===(w=b)||void 0===w?void 0:w.length)||(b=(0,se.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const I=p.timeExtent||this.timeExtent;if(null!=b&&null!=I&&(null!=I.start||null!=I.end)){var R;b=b.map((p=>p.clone()));const y=null===(R=_.variables.find((p=>{let{name:y}=p;return y===b[0].variableName})))||void 0===R||null===(R=R.dimensions)||void 0===R?void 0:R.find((p=>{let{name:y}=p;return"StdTime"===y})),w=b.find((p=>{let{dimensionName:y}=p;return"StdTime"===y}));if(!y||!w)return{...p,multidimensionalDefinition:null};const{start:T,end:A}=I,M=null==T?null:T.getTime(),k=null==A?null:A.getTime(),C=null!==M&&void 0!==M?M:k,P=null!==k&&void 0!==k?k:M;if(null!=y.values){const p=y.values.filter((p=>{if(Array.isArray(p)){if(C===P)return p[0]<=C&&p[1]>=C;const y=p[0]<=C&&p[1]>C||p[0]<P&&p[1]>=P,w=p[0]>=C&&p[1]<=P||p[0]<C&&p[1]>P;return y||w}return C===P?p===C:p>=C&&p<=P}));if(p.length){const y=p.sort(((p,y)=>{const w=Array.isArray(p)?p[0]:p,_=Array.isArray(p)?p[1]:p,b=Array.isArray(y)?y[0]:y,I=Array.isArray(y)?y[1]:y;return C===P?w-b:Math.abs(_-P)-Math.abs(I-P)}))[0];w.values=[y]}else b=null}else if(y.hasRegularIntervals&&y.extent){const[p,_]=y.extent;C>_||P<p?b=null:w.values=C===P?[C]:[Math.max(p,C),Math.min(_,P)]}}return null!=b&&(0,se.sx)(b,this.multidimensionalSubset)?{...p,multidimensionalDefinition:null}:{...p,multidimensionalDefinition:b}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){var p;const y=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&y&&this._set("rasterFunction",X.A.fromJSON(y)),void(this._cachedRasterFunctionJson=null===(p=this.rasterFunction)||void 0===p?void 0:p.toJSON())}let y,w=this.raster,_=!1;"Function"===w.datasetFormat?(y=w.primaryRasters.rasters,w=y[0],_=!0):y=[w];const{rasterFunction:b}=this;if(b){var I,R,T;const p={raster:w};y.length>1&&y.forEach((y=>p[y.url]=y));const _=(0,Se.vt)(null!==(I=null===(R=b.functionDefinition)||void 0===R?void 0:R.toJSON())&&void 0!==I?I:b.toJSON(),p),A=new Ie({rasterFunction:_});A.rasterJobHandler=this._rasterJobHandler.instance,await A.open(),this._cachedRasterFunctionJson=null===(T=this.rasterFunction)||void 0===T?void 0:T.toJSON(),this.raster=A}else this.raster=w,this._cachedRasterFunctionJson=null,await w.when();if(this._cachedRendererJson=null,!_&&!b)return;const{bandIds:A}=this,{bandCount:M}=this.raster.rasterInfo,k=null!==A&&void 0!==A&&A.length?A.some((p=>p>=M)):M>=3;A&&(k||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:p,symbolizer:y}=this;if(!p||!y||!this.renderer)return;const{rasterInfo:w}=this.raster,_=(0,se.ct)(w,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),b=null===_||void 0===_?void 0:_.name,I=(0,Te.$P)({...this.renderer.toJSON(),variableName:b});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(I))return;const R=this._rasterJobHandler.instance;R&&(y.rasterInfo=(0,Te.m7)(w,b),y.rendererJSON=I,y.bind(),await R.updateSymbolizer(y),this._cachedRendererJson=I)}async applyRenderer(p,y){var w;const _=null===p||void 0===p?void 0:p.pixelBlock;if(!(null!=_&&_.pixels&&_.pixels.length>0))return null;let b;await this.updateRenderer();const I=this._rasterJobHandler.instance,R=null!==(w=this.bandIds)&&void 0!==w?w:[];return b=I?await I.symbolize({...p,simpleStretchParams:y,bandIds:R}):this.symbolizer.symbolize({...p,simpleStretchParams:y,bandIds:R}),b}getTileUrl(p,y,w){return"RasterTileServer"===this.raster.datasetFormat?"".concat(this.url,"/tile/").concat(p,"/").concat(y,"/").concat(w):""}getCompatibleTileInfo(p,y){let w=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this.loaded||null==y)return null;if(w&&p.equals(this.spatialReference))return this.tileInfo;const _=(0,q.Vp)(p);return Q.A.create({size:256,spatialReference:p,origin:_?{x:_.origin[0],y:_.origin[1]}:{x:y.xmin,y:y.ymax}})}getCompatibleFullExtent(p){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(p)||(this._compatibleFullExtent=this.raster.computeExtent(p)),this._compatibleFullExtent):null}async fetchTile(p,y,w){var _;let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if($(this),b.requestAsImageElement){const _=this.getTileUrl(p,y,w);return(0,U.A)(_,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:b.signal}).then((p=>p.data))}const{serviceRasterInfo:I}=this;if(null!=I.multidimensionalInfo&&null==(b=this.normalizeRasterFetchOptions(b)).multidimensionalDefinition){const _=b.tileInfo||I.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(p,y,w,_),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===(null===(_=this.renderer)||void 0===_?void 0:_.type)&&(b={...b,buffer:{cols:1,rows:1}}),this.raster.fetchTile(p,y,w,b)}async fetchPixels(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(_=this.normalizeRasterFetchOptions(_)).multidimensionalDefinition?{extent:p,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),y=Math.round(y),w=Math.round(w),this.raster.fetchPixels(p,y,w,_))}async identify(p){var y;let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{raster:_,serviceRasterInfo:b}=this;if(null!=b.multidimensionalInfo&&(!b.hasMultidimensionalTranspose||!((0,se.DY)(w.multidimensionalDefinition)||w.transposedVariableName||w.timeExtent))&&null==(w=this.normalizeRasterFetchOptions(w)).multidimensionalDefinition)return{location:p,value:null};const I=null===(y=this.multidimensionalSubset)||void 0===y?void 0:y.areaOfInterest;if(I&&!I.contains(p))throw new R.A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return _.identify(p,w)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var p,y,w;const _=null===(p=this.serviceRasterInfo)||void 0===p?void 0:p.multidimensionalInfo;if(null==_||"standard-time"!==(null===(y=this.serviceRasterInfo)||void 0===y?void 0:y.dataType))return!1;const b=this.multidimensionalDefinition,I=null===b||void 0===b||null===(w=b[0])||void 0===w?void 0:w.variableName;return _.variables.some((p=>p.name===I&&(!(null!==b&&void 0!==b&&b[0].dimensionName)||p.dimensions.some((p=>"StdTime"===p.name)))))}getStandardTimeValue(p){return new Date(24*(p-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(p){var y;const w=null!==p&&void 0!==p?p:null===(y=this.serviceRasterInfo)||void 0===y?void 0:y.multidimensionalInfo;return(0,se.z2)(this.multidimensionalSubset,w)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,se.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const p=new K.A;return this._rasterJobHandler.connectionPromise=p.initialize().then((async()=>{$(this),this._rasterJobHandler.instance=p,this.raster.rasterJobHandler=p,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){var p;$(this);const{raster:y}=this,w=(0,Te.w6)(y.rasterInfo,y.tileType,null===(p=this.sourceJSON)||void 0===p?void 0:p.defaultResamplingMethod);this._set("interpolation",w)}}_configDefaultRenderer(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"no";$(this);const{rasterInfo:y}=this.raster;!this.bandIds&&y.bandCount>1&&(this.bandIds=(0,Te.ci)(y));const w=(0,se.ct)(y,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),_=null===w||void 0===w?void 0:w.name;if(!this.renderer||"override"===p){var b,I;const p=(0,Te.PD)(y,{bandIds:this.bandIds,variableName:_}),w=y.statistics,R=w&&w.length>0?w[0]:null,T=null!==(b=null===R||void 0===R?void 0:R.max)&&void 0!==b?b:0,A=null!==(I=null===R||void 0===R?void 0:R.min)&&void 0!==I?I:0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===p.type&&(T>1e24||A<-1e24)&&(p.dynamicRangeAdjustment=!0,p.statistics=null,"none"===p.stretchType&&(p.stretchType="min-max")),this.renderer=p}const R=(0,Te.$P)({...this.renderer.toJSON(),variableName:_}),A=(0,Te.m7)(y,_);this.symbolizer?(this.symbolizer.rendererJSON=R,this.symbolizer.rasterInfo=A):this.symbolizer=new Ae.A({rendererJSON:R,rasterInfo:A});const M=this.symbolizer.bind();if(M.success){if("auto"===p){const{colormap:p}=this.raster.rasterInfo,y=this.renderer;if(null!=p&&"raster-colormap"===y.type){const p=(0,Te.PD)(this.raster.rasterInfo);JSON.stringify(p)!==JSON.stringify(y)&&this._configDefaultRenderer("override")}else if("raster-stretch"===y.type){var k,C;const p=null===(k=this.bandIds)||void 0===k?void 0:k.length,w=null===(C=y.statistics)||void 0===C?void 0:C.length;!y.dynamicRangeAdjustment&&w&&p&&w!==p&&this._configDefaultRenderer("override")}}}else T.A.getLogger(this).warn("imagery-tile-mixin",M.error||"The given renderer is not supported by the layer."),"auto"===p&&this._configDefaultRenderer("override")}};function $(p){if(!p.raster||!p.serviceRasterInfo)throw new R.A("imagery-tile","no raster")}return(0,_._)([(0,C.MZ)({clonable:!1})],y.prototype,"_cachedRendererJson",void 0),(0,_._)([(0,C.MZ)({clonable:!1})],y.prototype,"_cachedRasterFunctionJson",void 0),(0,_._)([(0,C.MZ)({clonable:!1})],y.prototype,"_compatibleFullExtent",void 0),(0,_._)([(0,C.MZ)({clonable:!1})],y.prototype,"_isConstructedFromFunctionRaster",void 0),(0,_._)([(0,C.MZ)({clonable:!1})],y.prototype,"_rasterJobHandler",void 0),(0,_._)([(0,C.MZ)()],y.prototype,"bandIds",void 0),(0,_._)([(0,C.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],y.prototype,"copyright",void 0),(0,_._)([(0,C.MZ)({json:{read:!1}})],y.prototype,"fullExtent",null),(0,_._)([(0,C.MZ)()],y.prototype,"interpolation",void 0),(0,_._)([(0,C.MZ)()],y.prototype,"ioConfig",void 0),(0,_._)([(0,C.MZ)({type:[V.A],json:{write:!0}})],y.prototype,"multidimensionalDefinition",null),(0,_._)([(0,C.MZ)({type:Y.A,json:{write:!0}})],y.prototype,"multidimensionalSubset",void 0),(0,_._)([(0,C.MZ)()],y.prototype,"raster",void 0),(0,_._)([(0,C.MZ)({type:X.A,json:{name:"renderingRule",write:!0}})],y.prototype,"rasterFunction",null),(0,_._)([(0,C.MZ)({readOnly:!0})],y.prototype,"rasterInfo",null),(0,_._)([(0,C.MZ)()],y.prototype,"serviceRasterInfo",void 0),(0,_._)([(0,C.MZ)()],y.prototype,"sourceJSON",void 0),(0,_._)([(0,C.MZ)({readOnly:!0,type:pe.A,json:{read:!1}})],y.prototype,"spatialReference",void 0),(0,_._)([(0,C.MZ)({type:Q.A})],y.prototype,"tileInfo",void 0),(0,_._)([(0,C.MZ)(j.OZ)],y.prototype,"url",null),(0,_._)([(0,C.MZ)({types:H.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var p;const y="raster-stretch"===(null===(p=this.renderer)||void 0===p?void 0:p.type)&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!y}}},origins:{"web-scene":{types:H.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:p=>({enabled:p&&"vector-field"!==p.type&&"flow"!==p.type})}}}}})],y.prototype,"renderer",null),(0,_._)([(0,W.w)("renderer")],y.prototype,"readRenderer",null),(0,_._)([(0,C.MZ)({clonable:!1})],y.prototype,"symbolizer",void 0),y=(0,_._)([(0,B.$)("esri.layers.ImageryTileMixin")],y),y};var Fe=w(1921),Ce=w(32465),Pe=w(68777),Oe=w(38362),De=w(26905),Be=w(67871),Ne=w(40878),ze=w(71767),Je=w(54507);function t(p){const y=p.fields,w=p.records,_=y.some((p=>"oid"===p.name.toLowerCase()))?"OBJECTID":"OID",b=[{name:_,type:"esriFieldTypeOID",alias:"OID"}].concat(y.map((p=>({name:p.name,type:"esriFieldType"+p.typeName,alias:p.name})))),I=b.map((p=>p.name)),R=[];let T=0,A=0;return w.forEach((p=>{const y={};for(y[_]=T++,A=1;A<I.length;A++)y[I[A]]=p[A-1];R.push({attributes:y})})),{displayFieldName:"",fields:b,features:R}}class DBFParser_r{static get supportedVersions(){return[5]}static parse(p){const y=new DataView(p),w=3&y.getUint8(0);if(3!==w)return{header:{version:w},recordSet:null};const _=y.getUint32(4,!0),b=y.getUint16(8,!0),I=y.getUint16(10,!0),R={version:w,recordCount:_,headerByteCount:b,recordByteCount:I};let T=32;const A=[],M=[];let k;if(3===w){for(;13!==y.getUint8(T);)k=String.fromCharCode(y.getUint8(T+11)).trim(),A.push({name:(0,Je.w)(new Uint8Array(p,T,11)),type:k,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(k)],length:y.getUint8(T+16)}),T+=32;if(T+=1,A.length>0)for(;M.length<_&&p.byteLength-T>I;){const w=[];32===y.getUint8(T)?(T+=1,A.forEach((y=>{if("C"===y.type)w.push((0,Je.w)(new Uint8Array(p,T,y.length)).trim());else if("N"===y.type)w.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(p,T,y.length)).trim(),10));else if("F"===y.type)w.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(p,T,y.length)).trim()));else if("D"===y.type){const _=String.fromCharCode.apply(null,new Uint8Array(p,T,y.length)).trim();w.push(new Date(parseInt(_.substring(0,4),10),parseInt(_.substring(4,6),10)-1,parseInt(_.substring(6,8),10)))}T+=y.length})),M.push(w)):T+=I}}return{header:R,fields:A,records:M,recordSet:t({fields:A,records:M})}}}var Ee=w(24746);const Le=new Map;Le.set("int16","esriFieldTypeSmallInteger"),Le.set("int32","esriFieldTypeInteger"),Le.set("int64","esriFieldTypeInteger"),Le.set("float32","esriFieldTypeSingle"),Le.set("float64","esriFieldTypeDouble"),Le.set("text","esriFieldTypeString");let He=class extends ve{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(p){await this.init();const{data:y}=await this.request(this.url+"/conf.json",{signal:null===p||void 0===p?void 0:p.signal});if(!this._validateHeader(y))throw new R.A("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:w,rasterInfo:_}=this._parseHeader(y);if("thematic"===_.dataType){const p=await this._fetchAuxiliaryInformation();_.attributeTable=p}this._set("storageInfo",w),this._set("rasterInfo",_),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{transposeInfo:b}=this.rasterInfo.storageInfo,{transposedVariableName:I}=_,R=!(!b||!I),T=R?0:this.rasterInfo.storageInfo.maximumPyramidLevel-p;if(T<0)return null;const A=this._buildCacheFilePath(T,y,w,_.multidimensionalDefinition,I),M=this._getIndexRecordFromBundle(y,w,R),k=await this.request(A,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:_.signal});if(!k)return null;const C=new Uint8Array(k.data),P=this._getTileEndAndContentType(C,M);if(0===P.recordSize)return null;const O=await this.request(A,{range:{from:P.position,to:P.position+P.recordSize},responseType:"array-buffer",signal:_.signal});if(!O)return null;const[D,B]=this._getTileSize(R);return this.decodePixelBlock(O.data,{width:D,height:B,planes:null,pixelType:null,returnInterleaved:R})}_validateHeader(p){return p&&"RasterInfo"===p.type&&!["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"].some((y=>!p[y]))}_parseHeader(p){var y,w,_,b;const I=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][p.pixelType],{bandCount:R,colormap:T,blockWidth:A,blockHeight:M,firstPyramidLevel:k,maximumPyramidLevel:C}=p,P=null===(y=p.statistics)||void 0===y?void 0:y.map((p=>({min:p.min,max:p.max,avg:p.mean,stddev:p.standardDeviation,median:p.median,mode:p.mode}))),O=null!==(w=p.histograms)&&void 0!==w&&null!==(w=w[0])&&void 0!==w&&null!==(w=w.counts)&&void 0!==w&&w.length?p.histograms:null,D=p.extent.spatialReference,B=null===(_=p.geodataXform)||void 0===_?void 0:_.spatialReference,N=new pe.A(null!==D&&void 0!==D&&D.wkid||null!==D&&void 0!==D&&D.wkt||null!==D&&void 0!==D&&D.wkt2?D:B);let z=new fe.A({xmin:p.extent.xmin,ymin:p.extent.ymin,xmax:p.extent.xmax,ymax:p.extent.ymax,spatialReference:N});const J=new me.A({x:p.pixelSizeX,y:p.pixelSizeY,spatialReference:N}),E=Math.round((z.xmax-z.xmin)/J.x),H=Math.round((z.ymax-z.ymin)/J.y),U=this._parseTransform(p.geodataXform),G=U?z:null;U&&(z=U.forwardTransform(z),J.x=(z.xmax-z.xmin)/E,J.y=(z.ymax-z.ymin)/H);const W=null!==(b=p.properties)&&void 0!==b?b:{},q=p.format.toLowerCase().replace("cache/",""),Z=new me.A(p.origin.x,p.origin.y,N);let j,V,Y,X;if(null!==T&&void 0!==T&&T.colors)for(j=[],V=0;V<T.colors.length;V++)Y=T.colors[V],X=T.values?T.values[V]:V,j.push([X,255&Y,Y<<16>>>24,Y<<8>>>24,Y>>>24]);const K=p.LODInfos,ee=[];for(V=0;V<K.levels.length;V++)ee.push(new ne.A({level:K.levels[V],resolution:K.resolutions[V],scale:96/.0254*K.resolutions[V]}));const te=new Q.A({dpi:96,lods:ee,format:q,origin:Z,size:[A,M],spatialReference:N}),ie={recordSize:8,packetSize:p.packetSize,headerSize:p.packetSize*p.packetSize*8+64},se=[{maxCol:Math.ceil(E/A)-1,maxRow:Math.ceil(H/M)-1,minCol:0,minRow:0}];let ae=2;if(C>0)for(V=0;V<C;V++)se.push({maxCol:Math.ceil(E/ae/A)-1,maxRow:Math.ceil(H/ae/M)-1,minCol:0,minRow:0}),ae*=2;const oe=p.mdInfo;let le=null;if(oe&&W._yxs){const p=W._yxs;le={packetSize:p.PacketSize,tileSize:[p.TileXSize,p.TileYSize]}}return{storageInfo:ie,rasterInfo:new ze.A({width:E,height:H,pixelType:I,bandCount:R,extent:z,nativeExtent:G,transform:U,spatialReference:N,pixelSize:J,keyProperties:W,statistics:P,histograms:O,multidimensionalInfo:oe,colormap:j,storageInfo:new re.A({blockWidth:A,blockHeight:M,pyramidBlockWidth:A,pyramidBlockHeight:M,origin:Z,tileInfo:te,transposeInfo:le,firstPyramidLevel:k,maximumPyramidLevel:C,blockBoundary:se})})}}_parseTransform(p){var y,w;if(!(0,Ee.J)(p))throw new R.A("cloudraster:open","the data contains unsupported geodata transform types");const _=(0,Ee.l)(p);if("identity"===_.type)return null;if("polynomial"!==_.type||null===(y=_.forwardCoefficients)||void 0===y||!y.length||null===(w=_.inverseCoefficients)||void 0===w||!w.length)throw new R.A("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return _}async _fetchAuxiliaryInformation(p){const y=this.request(this.url+"/conf.vat.json",{signal:p}).then((p=>p.data)).catch((()=>null)),w=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:p}).then((p=>p.data)).catch((()=>null)),_=await Promise.all([y,w]);let b;if(_[0]){let p=_[0].fields;const y=_[0].values;if(p&&y){p=p.map((p=>({type:"OID"===p.name?"esriFieldTypeOID":Le.get(p.type),name:p.name,alias:p.alias||p.name})));const w=y.map((p=>({attributes:p})));p&&y&&(b={fields:p,features:w})}}return!b&&_[1]&&(b=DBFParser_r.parse(_[1]).recordSet),_e.A.fromJSON(b)}_buildCacheFilePath(p,y,w,_,b){const I=this._getPackageSize(!!b),R=Math.floor(y/I)*I,T=Math.floor(w/I)*I,A="R"+this._toHexString4(R)+"C"+this._toHexString4(T);let M="L";M+=p>=10?p.toString():"0"+p.toString();const{multidimensionalInfo:k}=this.rasterInfo,C=null===_||void 0===_?void 0:_[0];if(null==k||!C)return"".concat(this.url,"/_alllayers/").concat(M,"/").concat(A,".bundle");let P="_yxs";if(!b){P=k.variables.find((p=>p.name===C.variableName)).dimensions[0].values.indexOf(C.values[0]).toString(16);const p=4-P.length;for(let y=0;y<p;y++)P="0"+P;P="S"+P}const O=this._getVariableFolderName(b||C.variableName);return"".concat(this.url,"/_alllayers/").concat(O,"/").concat(P,"/").concat(M,"/").concat(A,".bundle")}_getPackageSize(){var p;let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const{transposeInfo:w}=this.rasterInfo.storageInfo;return y&&null!=w?null!==(p=w.packetSize)&&void 0!==p?p:0:this.storageInfo.packetSize}_getTileSize(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const{storageInfo:y}=this.rasterInfo,{transposeInfo:w}=y;return p&&null!=w?w.tileSize:y.tileInfo.size}_getVariableFolderName(p){return""===(p=p.trim())?"_v":p.replaceAll(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(p,y){let w=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const _=this._getPackageSize(w),b=_*(p%_)+y%_;if(b<0)throw new Error("Invalid level / row / col");return 20+b*this.storageInfo.recordSize+44}_getTileEndAndContentType(p,y){const w=p.subarray(y,y+8);let _,b=0;for(_=0;_<5;_++)b|=(255&w[_])<<8*_;const I=0xffffffffff&b;for(b=0,_=5;_<8;_++)b|=(255&w[_])<<8*(_-5);return{position:I,recordSize:0xffffffffff&b}}_toHexString4(p){let y=p.toString(16);if(4!==y.length){let p=4-y.length;for(;p-- >0;)y="0"+y}return y}};(0,_._)([(0,C.MZ)({readOnly:!0})],He.prototype,"storageInfo",void 0),(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],He.prototype,"datasetFormat",void 0),He=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.CloudRaster")],He);const Ue=He;var Ge=w(22123),We=w(5410);function i(p){return["x","e","east","long","longitude"].includes(p.toLowerCase())}function covJSONParser_r(p){return["y","n","west","lat","latitude"].includes(p.toLowerCase())}function covJSONParser_o(p){const{axes:y}=p.domain,w=Object.keys(y),_=[],b=[];let I=-1,R=-1,T=[];for(let J=0;J<w.length;J++){const p=w[J];i(p)?I=J:covJSONParser_r(p)&&(R=J);const A=y[p],M=[];if("values"in A){A.values.forEach((p=>M.push("string"==typeof p?new Date(p).getTime():p)));const p=M[1]-M[0];_.push([M[0]-.5*p,M[M.length-1]+.5*p]),b.push(p)}else{const{start:p,stop:y,num:w}=A,I=(y-p)/(w-1);_.push([p-.5*I,y+.5*I]),b.push(I);for(let _=0;_<w;_++)M.push(p+I*_)}T.push({name:p,values:M,extent:[M[0],M[M.length-1]]})}I>-1&&-1===R?R=0===I?1:0:R>-1&&-1===I?I=0===R?1:0:-1===R&&-1===I&&(I=0,R=1),T=T.filter(((p,y)=>!(y===I||y===R)));const{referencing:A}=p.domain,M=A.find((p=>p.coordinates.includes(w[I]))).system.id,k=null===M||void 0===M?void 0:M.slice(M.lastIndexOf("/")+1),C=null==k||"CRS84"===k?4326:Number(k),P=new pe.A({wkid:C}),[O,D]=_[I],[B,N]=_[R],z=new fe.A({xmin:O,xmax:D,ymin:B,ymax:N,spatialReference:P});return{width:Math.round(z.width/b[I]),height:Math.round(z.height/b[R]),extent:z,dimensions:T}}function covJSONParser_u(p){var y;const w=(0,We.Z0)();return w&&null!==(y=p[w])&&void 0!==y?y:Object.values(p)[0]}function covJSONParser_m(){return Math.round(255*Math.random())}function d(p){let y=Number.MAX_VALUE,w=-Number.MAX_VALUE;for(let _=0;_<p.length;_++){const b=p[_];null!=b&&(b<y&&(y=b),b>w&&(w=b))}return(0,oe.X1)(y,w)}function f(p,y,w){const _=p.map(((p,w)=>({name:p,count:y[w]}))).sort(((p,y)=>p.name>y.name?-1:1)),b=(I=1,p=>I*=p.count);var I;const R=[..._.slice(1),{name:"",count:1}].reverse().map(b).reverse();let T=0;for(let A=p.length-1;A>=0;A--)T+=R[_.findIndex((y=>{let{name:w}=y;return w===p[A]}))]*(w%y[A]),w=Math.floor(w/y[A]);return T}function covJSONParser_p(p){var y;const{width:w,height:_,extent:b,dimensions:I}=covJSONParser_o(p),{ranges:R}=p,T=Object.keys(R).sort(((p,y)=>p<y?-1:1)),A=[];for(let O=0;O<T.length;O++){const p=T[O];(null===I||void 0===I?void 0:I.length)&&A.push({name:p,dimensions:I})}const M=function c(p){const y={},{parameters:w}=p;if(!w)return y;for(const[I,R]of Object.entries(w)){var _;const{type:p,description:w,unit:T,categoryEncoding:A,observedProperty:M}=R;if("Parameter"===p&&(y[I]={},w&&(y[I].description=covJSONParser_u(w)),T&&(y[I].unit=T.label?covJSONParser_u(T.label):null,y[I].symbol=null===(_=T.symbol)||void 0===_?void 0:_.value),A)){var b;const p=Object.entries(A).map(((p,y)=>({OID:y,Value:Number(p[1]),ClassName:p[0].slice(p[0].lastIndexOf("/")+1),Count:1})));let w=!1;(null===M||void 0===M||null===(b=M.categories)||void 0===b?void 0:b.length)&&(M.categories.forEach((y=>{if(!y.id)return;const _=y.id.slice(y.id.lastIndexOf("/")+1),b=p.find((p=>p.ClassName===_));if(!b)return;const I=y.label?covJSONParser_u(y.label):null;if(b.Label=I,y.preferredColor){const p=Ge.A.fromHex(y.preferredColor);p&&(w=!0,b.Red=p.r,b.Green=p.g,b.Blue=p.b)}})),w&&p.forEach((p=>{null==p.Red&&(p.Red=covJSONParser_m(),p.Green=covJSONParser_m(),p.Blue=covJSONParser_m())})));const _={objectIdFieldName:"",fields:[{name:"OID",type:"esriFieldTypeOID",alias:"OID",domain:null},{name:"Value",type:"esriFieldTypeInteger",alias:"Value",domain:null},{name:"Count",type:"esriFieldTypeDouble",alias:"Count",domain:null},{name:"ClassName",type:"esriFieldTypeString",alias:"ClassName",domain:null,length:50},{name:"Label",type:"esriFieldTypeString",alias:"Label",domain:null,length:50}],features:p.map((p=>({attributes:p})))};w&&_.fields.push({name:"Red",type:"esriFieldTypeInteger",alias:"Red",domain:null},{name:"Green",type:"esriFieldTypeInteger",alias:"Green",domain:null},{name:"Blue",type:"esriFieldTypeInteger",alias:"Blue",domain:null}),y[I].attributeTable=_}}return y}(p);A.forEach((p=>M[p.name]&&Object.assign(p,M[p.name])));const k=A.length?{variables:A}:void 0,C=[];for(let O=0;O<T.length;O++){const p=T[O],{values:y,dataType:b,axisNames:A,shape:M}=R[p],k=M.length>2?O*M.slice(0,-2).reduce(((p,y)=>p*y)):0,P=A.slice(0,-2),D=M.slice(0,-2),B="float"===b?"f32":d(y),N=w*_,z=y.length/N;for(let R=0;R<z;R++){const p=we.A.createEmptyBand(B,N),b=new Uint8Array(N).fill(255);let T=!1;const A=R*N;for(let w=0;w<N;w++){const _=y[A+w];null==_?(b[w]=0,T=!0):p[w]=_}if(0===O||null!==I&&void 0!==I&&I.length){const y=new we.A({width:w,height:_,mask:T?b:null,pixels:[p],pixelType:B});y.updateStatistics(),null!==I&&void 0!==I&&I.length?C[f(P,D,R)+k]=y:C.push(y)}else{const y=C[R];y.pixels.push(p),T?y.mask&&(y.mask=we.A.combineBandMasks([y.mask,b])):y.mask=T?b:null}}}const P=null===(y=Object.values(M).find((p=>p.attributeTable)))||void 0===y?void 0:y.attributeTable;return{extent:b,pixelBlocks:C,multidimensionalInfo:k,attributeTable:P,bandNames:k?void 0:T}}let qe=class extends ve{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.source=null}get url(){return""}async open(p){var y,w;await this.init();const _=this.source,{pixelBlocks:b,attributeTable:I,statistics:R,histograms:T,name:A,nativeExtent:M,transform:k}=_,C=b[0],{width:P,height:O,pixelType:D}=C,B=null!==(y=_.extent)&&void 0!==y?y:new fe.A({xmin:-.5,ymin:.5,xmax:P-.5,ymax:O-.5,spatialReference:new pe.A({wkid:3857})}),N=null!==(w=_.isPseudoSpatialReference)&&void 0!==w?w:!_.extent,z={x:B.width/P,y:B.height/O},J={..._.keyProperties};I&&(J.DataType="Thematic");const E=new ze.A({width:P,height:O,pixelType:D,extent:B,nativeExtent:M,attributeTable:I,transform:k,pixelSize:z,spatialReference:B.spatialReference,bandCount:C.pixels.length,keyProperties:J,multidimensionalInfo:_.multidimensionalInfo,statistics:R,isPseudoSpatialReference:N,histograms:T});this.ioConfig.skipMapInfo&&this.updateImageSpaceRasterInfo(E),this.createRemoteDatasetStorageInfo(E,512,512),this._set("rasterInfo",E),this.updateTileInfo(),E.multidimensionalInfo?await this._buildMDimStats(_.pixelBlocks,E.multidimensionalInfo):await this._buildInMemoryRaster(C,{width:512,height:512},p),E.multidimensionalInfo||(this.source=null),this.datasetName=A}fetchRawTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this._pixelBlockTiles){const{rasterInfo:b}=this,[I,R]=b.storageInfo.tileInfo.size,{sliceId:T}=_,{pixelBlocks:A}=this.source,M={pixelBlock:null==T?A[0]:A[T],useBilinear:"thematic"!==b.dataType,tileSize:{width:I,height:R},level:p,row:y,col:w},k=this.rasterJobHandler?this.rasterJobHandler.clipTile(M,_):(0,ce.J$)(M);return Promise.resolve(k)}const b=this._pixelBlockTiles.get("".concat(p,"/").concat(y,"/").concat(w));return Promise.resolve(b)}async _buildInMemoryRaster(p,y,w){var _,b,I;const{rasterInfo:T}=this,A=null!==(_=T.storageInfo.maximumPyramidLevel)&&void 0!==_?_:0,k="thematic"!==T.dataType,C=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:p,tileSize:y,maximumPyramidLevel:A,useBilinear:k},w):Promise.resolve((0,ce.lD)(p,y,A,k)),P=null!=T.statistics,O=null!=T.histograms,D=this.ioConfig.skipStatistics||P?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:p},w):Promise.resolve((0,Re.f4)(p)),B=await(0,M.Lx)([C,D]);if(!B[0].value&&B[1].value)throw new R.A("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=B[0].value,P||(T.statistics=null===(b=B[1].value)||void 0===b?void 0:b.statistics),O||(T.histograms=null===(I=B[1].value)||void 0===I?void 0:I.histograms)}async _buildMDimStats(p,y,w){for(let _=0;_<y.variables.length;_++){const b=y.variables[_];if(b.statistics)continue;const I=b.dimensions.map((p=>{var y,w,_;return new V.A({variableName:b.name,dimensionName:p.name,values:[null!==(y=null===(w=p.values)||void 0===w?void 0:w[0])&&void 0!==y?y:null===(_=p.extent)||void 0===_?void 0:_[0]],isSlice:!0})})),R=(0,se.NG)(I,y),T=null==R?null:p[R];if(null==T)continue;const A=this.rasterJobHandler?await this.rasterJobHandler.computeStatisticsHistograms({pixelBlock:T},w):(0,Re.eH)(T);b.statistics=A.statistics,b.histograms||(b.histograms=A.histograms)}}};(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],qe.prototype,"datasetFormat",void 0),(0,_._)([(0,C.MZ)()],qe.prototype,"source",void 0),(0,_._)([(0,C.MZ)()],qe.prototype,"url",null),qe=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.InMemoryRaster")],qe);const Ze=qe;let je=class extends ve{constructor(){super(...arguments),this.datasetFormat="CovJSON"}async open(p){await this.init();const{extent:y,pixelBlocks:w,multidimensionalInfo:_,attributeTable:b,bandNames:I}=await this._fetchData(p),{statistics:R,histograms:T}=(0,Re.eH)(w[0]),A=null===I||void 0===I?void 0:I.map((p=>({BandName:p}))),M={DataType:b?"Thematic":_?"Scientific":"Generic",BandProperties:A},k=new Ze({source:{extent:y,pixelBlocks:w,attributeTable:b?_e.A.fromJSON(b):null,multidimensionalInfo:_,statistics:R,histograms:T,keyProperties:M,isPseudoSpatialReference:!1}});await k.open(),this._inMemoryRaster=k;const C=this.source?"":this.url.slice(this.url.lastIndexOf("/")+1);this._set("datasetName",C.slice(0,C.indexOf("."))),this._set("rasterInfo",k.rasterInfo)}fetchRawTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this._inMemoryRaster.fetchRawTile(p,y,w,_)}async _fetchData(p){var y,w,_,b;const I=null!==(y=this.source)&&void 0!==y?y:(await this.request(this.url,{signal:null===p||void 0===p?void 0:p.signal})).data,T="imagery-tile-layer:open-coverage-json";if("coverage"!==(null===(w=I.type)||void 0===w?void 0:w.toLowerCase())||"grid"!==(null===(_=I.domain)||void 0===_||null===(_=_.domainType)||void 0===_?void 0:_.toLowerCase()))throw new R.A(T,"Only coverage with Grid domain type is supported");if(!I.ranges)throw new R.A(T,"Missing ranges in the grid coverage data");if(null===(b=I.domain.referencing)||void 0===b||!b.length)throw new R.A(T,"Missing domain referencing in the grid coverage data");const A=Object.values(I.ranges);for(let M=0;M<A.length;M++){const{axisNames:p,shape:y,type:w,values:_}=A[M];if(!("ndarray"===w.toLowerCase()&&null!==_&&void 0!==_&&_.length&&null!==p&&void 0!==p&&p.length&&null!==y&&void 0!==y&&y.length))throw new R.A(T,"Only ranges with valid NdArray, axisNames, shape, and inline values are supported");if(!i(p[p.length-1])||!covJSONParser_r(p[p.length-2]))throw new R.A(T,"Only row-major ordered pixel values are supported. X axis must be the last axis.")}return covJSONParser_p(I)}};(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],je.prototype,"datasetFormat",void 0),(0,_._)([(0,C.MZ)({constructOnly:!0})],je.prototype,"source",void 0),je=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.CovJSONRaster")],je);const Ve=je;var Ye=w(16842);function xmlUtilities_n(p,y){if(!p||!y)return[];let w=y;y.includes("/")?(w=y.slice(0,y.indexOf("/")),y=y.slice(y.indexOf("/")+1)):y="";const _=[];if(y){const b=xmlUtilities_n(p,w);for(let p=0;p<b.length;p++)xmlUtilities_n(b[p],y).forEach((p=>_.push(p)));return _}const b=p.getElementsByTagNameNS("*",w);if(!b||0===b.length)return[];for(let I=0;I<b.length;I++)_.push(b[I]||b.item(I));return _}function xmlUtilities_e(p,y){if(!p||!y)return null;let w=y;y.includes("/")?(w=y.slice(0,y.indexOf("/")),y=y.slice(y.indexOf("/")+1)):y="";const _=xmlUtilities_n(p,w);return _.length>0?y?xmlUtilities_e(_[0],y):_[0]:null}function xmlUtilities_t(p){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const w=y?xmlUtilities_e(p,y):p;let _;return w?(_=w.textContent||w.nodeValue,_?_.trim():null):null}function xmlUtilities_u(p,y){return function l(p,y){const w=xmlUtilities_n(p,y),_=[];let b;for(let I=0;I<w.length;I++)b=w[I].textContent||w[I].nodeValue,b&&(b=b.trim(),""!==b&&_.push(b));return _}(p,y).map((p=>Number(p)))}function xmlUtilities_o(p,y){const w=xmlUtilities_t(p,y);return Number(w)}function xmlUtilities_i(p,y){var w;const _=null===p||void 0===p||null===(w=p.nodeName)||void 0===w?void 0:w.toLowerCase(),b=y.toLowerCase();return _.slice(_.lastIndexOf(":")+1)===b}var $e=w(3058);function pamParser_u(p,y){if(!p||!y)return null;const w=[];for(let _=0;_<p.length;_++)w.push(p[_]),w.push(y[_]);return w}function pamParser_d(p){if(!p)return null;let y=Number(p);if(!isNaN(y)&&0!==y)return new pe.A({wkid:y});if(p=String(p).trim(),(0,q.jp)(p))return new pe.A({wkt2:p});const w=p.toUpperCase();if(w.startsWith("COMPD_CS")){if(!w.includes("VERTCS")||!w.includes("GEOGCS")&&!w.startsWith("PROJCS"))return null;const _=w.indexOf("VERTCS"),b=w.indexOf("PROJCS"),I=b>-1?b:w.indexOf("GEOGCS");if(-1===I)return null;const R=p.slice(I,p.lastIndexOf("]",_)+1).trim(),T=p.slice(_,p.lastIndexOf("]")).trim();y=pamParser_p(R);const A=new pe.A(y?{wkid:y}:{wkt:R}),M=pamParser_p(T);return M&&(A.vcsWkid=M),A}return w.startsWith("GEOGCS")||w.startsWith("PROJCS")?(y=pamParser_p(p),new pe.A(0!==y?{wkid:y}:{wkt:p})):null}function pamParser_p(p){var y;const w=p.replaceAll("]","[").replaceAll('"',"").split("[").map((p=>p.trim())).filter((p=>""!==p)),_=w[w.length-1].split(","),b=null===(y=_[0])||void 0===y?void 0:y.toLowerCase();if(("epsg"===b||"esri"===b)&&p.endsWith('"]]')){const p=Number(_[1]);if(!isNaN(p)&&0!==p)return p}return 0}function S(p){var y;if("pamdataset"!==(null===p||void 0===p||null===(y=p.documentElement.tagName)||void 0===y?void 0:y.toLowerCase()))return{};const w={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};p.documentElement.childNodes.forEach((p=>{if(1===p.nodeType)if(xmlUtilities_i(p,"SRS")){if(!w.spatialReference){const y=xmlUtilities_t(p);w.spatialReference=pamParser_d(y)}}else if(xmlUtilities_i(p,"Metadata"))if("xml:ESRI"===p.getAttribute("domain")){const{spatialReference:y,transform:_}=function pamParser_c(p){var y;const w=xmlUtilities_e(p,"GeodataXform"),_=pamParser_d(xmlUtilities_o(w,"SpatialReference/WKID")||xmlUtilities_t(w,"SpatialReference/WKT"));if("typens:PolynomialXform"!==w.getAttribute("xsi:type"))return{spatialReference:_,transform:null};const b=null!==(y=xmlUtilities_o(w,"PolynomialOrder"))&&void 0!==y?y:1,I=xmlUtilities_u(w,"CoeffX/Double"),R=xmlUtilities_u(w,"CoeffY/Double"),T=xmlUtilities_u(w,"InverseCoeffX/Double"),A=xmlUtilities_u(w,"InverseCoeffY/Double"),M=pamParser_u(I,R),k=pamParser_u(T,A);return{spatialReference:_,transform:M&&k&&M.length&&k.length?new $e.A({spatialReference:_,polynomialOrder:b,forwardCoefficients:M,inverseCoefficients:k}):null}}(p);w.transform=_,w.spatialReference||(w.spatialReference=y)}else xmlUtilities_n(p,"MDI").forEach((p=>w.metadata[p.getAttribute("key")]=xmlUtilities_t(p)));else if(xmlUtilities_i(p,"PAMRasterBand")){const y=function pamParser_m(p){var y;const w=xmlUtilities_o(p,"NoDataValue"),_=xmlUtilities_e(p,"Histograms/HistItem"),b=xmlUtilities_o(_,"HistMin"),I=xmlUtilities_o(_,"HistMax"),R=xmlUtilities_o(_,"BucketCount"),T=null===(y=xmlUtilities_t(_,"HistCounts"))||void 0===y?void 0:y.split("|").map((p=>Number(p)));let A,M,k,C;xmlUtilities_n(p,"Metadata/MDI").forEach((p=>{var y;const w=Number(null!==(y=p.textContent)&&void 0!==y?y:p.nodeValue);switch(p.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":A=w;break;case"STATISTICS_MAXIMUM":M=w;break;case"STATISTICS_MEAN":k=w;break;case"STATISTICS_STDDEV":C=w}}));const P=xmlUtilities_o(p,"Metadata/SourceBandIndex");return{noDataValue:w,histogram:null!==T&&void 0!==T&&T.length&&null!=b&&null!=I?{min:b,max:I,size:R||T.length,counts:T}:null,sourceBandIndex:P,statistics:null!=A&&null!=M?{min:A,max:M,avg:k,stddev:C}:null}}(p);null!=y.sourceBandIndex&&null==w.rasterBands[y.sourceBandIndex]?w.rasterBands[y.sourceBandIndex]=y:w.rasterBands.push(y)}}));const _=w.rasterBands;if(_.length){const p=!!_[0].statistics;w.statistics=p?_.map((p=>p.statistics)).filter(Ye.Ru):null;const y=!!_[0].histogram;w.histograms=y?_.map((p=>p.histogram)).filter(Ye.Ru):null}return w}let Xe=class extends ve{async open(p){await this.init();const y=await this._fetchData(p);let{spatialReference:w,statistics:_,histograms:b,transform:I}=await this._fetchAuxiliaryData(p);const R=!w;R&&(w=new pe.A({wkid:3857})),(null===b||void 0===b?void 0:b.length)&&null==_&&(_=(0,Re.Pg)(b));const{width:T,height:A}=y;let M=new fe.A({xmin:-.5,ymin:.5-A,xmax:T-.5,ymax:.5,spatialReference:w});const k=I?I.forwardTransform(M):M;let C=!0;if(I){const p=I.forwardCoefficients;C=p&&0===p[1]&&0===p[2],C&&(I=null,M=k)}const P=new Ze({source:{extent:k,nativeExtent:M,transform:I,pixelBlocks:[y],statistics:_,histograms:b,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:R},ioConfig:{sampling:"closest",skipStatistics:!0}});this.ioConfig.skipMapInfo&&(P.ioConfig.skipMapInfo=!0),await P.open(),P.source=null,this._set("rasterInfo",P.rasterInfo),this._inMemoryRaster=P}fetchRawTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this._inMemoryRaster.fetchRawTile(p,y,w,_)}async _fetchData(p){const{data:y}=await this.request(this.url,{responseType:"array-buffer",signal:null===p||void 0===p?void 0:p.signal}),w=(0,le.g)(y).toUpperCase();if("JPG"!==w&&"PNG"!==w&&"GIF"!==w&&"BMP"!==w)throw new R.A("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",w);const _=w.toLowerCase(),b="gif"===_||"bmp"===_||!(0,O.A)("ios"),I=await this.decodePixelBlock(y,{format:_,useCanvas:b,hasNoZlibMask:!0});if(null==I)throw new R.A("image-aux-raster:open","the data cannot be decoded");return I}async _fetchAuxiliaryData(p){var y;const w=null===p||void 0===p?void 0:p.signal,{skipExtensions:_=[],skipMapInfo:b}=this.ioConfig,I=b||_.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:w}),R=this.datasetFormat,T="JPG"===R?"jgw":"PNG"===R?"pgw":"BMP"===R?"bpw":null,A=T&&_.includes(T)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+T,{responseType:"text",signal:w}),k=await(0,M.Lx)([I,A]);if(null!==w&&void 0!==w&&w.aborted)throw(0,M.NK)();const C=S(null===(y=k[0].value)||void 0===y?void 0:y.data);if(!C.transform){const p=k[1].value?k[1].value.data.split("\n").slice(0,6).map((p=>Number(p))):null;C.transform=6===(null===p||void 0===p?void 0:p.length)?new $e.A({forwardCoefficients:[p[4],p[5],p[0],-p[1],p[2],-p[3]]}):null}return C}};(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],Xe.prototype,"datasetFormat",void 0),Xe=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.ImageAuxRaster")],Xe);const Ke=Xe;var Qe=w(35598),et=w(4270),tt=w(62964),it=w(23423),nt=w(80037);let rt=class extends ve{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(p){var y,w,_,b,I;await this.init();const T=null===p||void 0===p?void 0:p.signal,A=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:T});A.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const M=A.data;if(this.sourceJSON=M,!M)throw new R.A("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!M.tileInfo)throw new R.A("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();this.tileType=M.cacheType,null==this.tileType&&(["jpg","jpeg","png","png8","png24","png32","mixed"].includes(M.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===M.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=null!==(y=null===(w=M.name)||void 0===w?void 0:w.slice(M.name.indexOf("/")+1))&&void 0!==y?y:"";const k=await this._fetchRasterInfo({signal:T});if(null==k)throw new R.A("image-server-raster:open","cannot initialize image service");(0,nt.E9)(k,M);const C="Map"===this.tileType?function v(p,y){if(!p)return null;const{minScale:w,maxScale:_,minLOD:b,maxLOD:I}=y;if(null!=b&&null!=I)return Q.A.fromJSON({...p,lods:p.lods.filter((p=>{let{level:y}=p;return null!=y&&y>=b&&y<=I}))});if(0!==w&&0!==_){const t=p=>Math.round(1e4*p)/1e4,y=w?t(w):1/0,b=_?t(_):-1/0;return Q.A.fromJSON({...p,lods:p.lods.filter((p=>{const w=t(p.scale);return w<=y&&w>=b}))})}return Q.A.fromJSON(p)}(M.tileInfo,M):Q.A.fromJSON(M.tileInfo);(0,Qe.Lw)(C);const[P,O]=this._computeMinMaxLOD(k,C),{extent:D,pixelSize:B}=k,N=.5/k.width*B.x,z=Math.max(B.x,B.y),{lods:J}=C;("Map"!==this.tileType&&0!==M.maxScale||Math.abs(B.x-B.y)>N||!J.some((p=>Math.abs(p.resolution-z)<N)))&&(B.x=B.y=P.resolution,k.width=Math.ceil((D.xmax-D.xmin)/B.x-.1),k.height=Math.ceil((D.ymax-D.ymin)/B.y-.1));const E=P.level-O.level,[H,U]=C.size,G=[],W=[];J.forEach(((p,y)=>{p.level>=O.level&&p.level<=P.level&&G.push({x:p.resolution,y:p.resolution}),y<J.length-1&&W.push(Math.round(10*p.resolution/J[y+1].resolution)/10)})),G.sort(((p,y)=>p.x-y.x));const q=this.computeBlockBoundary(D,H,U,C.origin,G,E),Z=G.length>1?G.slice(1):null;let j;M.transposeInfo&&(j={tileSize:[M.transposeInfo.rows,M.transposeInfo.cols],packetSize:null!==(_=null===(b=k.keyProperties)||void 0===b?void 0:b._yxs.PacketSize)&&void 0!==_?_:0});const V=W.length<=1||W.length>=3&&W.slice(0,-1).every((p=>p===W[0]))?null!==(I=W[0])&&void 0!==I?I:2:Math.round(10/(O.resolution/P.resolution)**(-1/E))/10;if(k.storageInfo=new re.A({blockWidth:C.size[0],blockHeight:C.size[1],pyramidBlockWidth:C.size[0],pyramidBlockHeight:C.size[1],pyramidResolutions:Z,pyramidScalingFactor:V,compression:C.format,origin:C.origin,firstPyramidLevel:1,maximumPyramidLevel:E,tileInfo:C,transposeInfo:j,blockBoundary:q}),this._fixGCSShift(k),this._set("rasterInfo",k),M.capabilities.toLowerCase().includes("tilemap")){const p={tileInfo:k.storageInfo.tileInfo,parsedUrl:(0,et.An)(this.url),url:this.url,tileServers:[]};this._tilemapCache=new tt.d({layer:p})}}async fetchRawTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{storageInfo:b,extent:I}=this.rasterInfo,{transposeInfo:R}=b,T=null!=R&&!!_.transposedVariableName;if(this._slices&&!T&&null==_.sliceId)return null;const A=T?0:b.maximumPyramidLevel-p+this._levelOffset,M="".concat(this.url,"/tile/").concat(A,"/").concat(y,"/").concat(w),k=this._slices?T?{variable:_.transposedVariableName}:{sliceId:_.sliceId||0}:null,{data:C}=await this.request(M,{query:k,responseType:"array-buffer",signal:_.signal});if(!C)return null;const P=T?R.tileSize:b.tileInfo.size,O=await this.decodePixelBlock(C,{width:P[0],height:P[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:T,noDataValue:this.rasterInfo.noDataValue});if(null==O)return null;const D=b.blockBoundary[p];if("jpg"!==b.compression||w>D.minCol&&w<D.maxCol&&y>D.minRow&&y<D.maxRow)return O;const{origin:B,blockWidth:N,blockHeight:z}=b,{x:J,y:E}=this.getPyramidPixelSize(p),H=Math.round((I.xmin-B.x)/J)%N,U=Math.round((I.xmax-B.x)/J)%N||N,G=Math.round((B.y-I.ymax)/E)%z,W=Math.round((B.y-I.ymin)/E)%z||z,q=w===D.minCol?H:0,Z=y===D.minRow?G:0,j=w===D.maxCol?U:N,V=y===D.maxRow?W:z;return(0,ce.z$)(O,{x:q,y:Z},{width:j-q,height:V-Z}),O}getSliceIndex(p){if(!this._slices||null==p||0===p.length)return null;const y=p;for(let w=0;w<this._slices.length;w++){const p=this._slices[w].multidimensionalDefinition;if(p.length===y.length&&!p.some((p=>{const w=y.find((y=>p.variableName===y.variableName&&y.dimensionName===p.dimensionName));return!w||(Array.isArray(p.values[0])?"".concat(p.values[0][0],"-").concat(p.values[0][1]):p.values[0])!==(Array.isArray(w.values[0])?"".concat(w.values[0][0],"-").concat(w.values[0][1]):w.values[0])})))return w}return null}async fetchVariableStatisticsHistograms(p,y){var w;const _=this.request(this.url+"/statistics",{query:{variable:p,f:"json"},signal:y}).then((p=>{var y;return null===(y=p.data)||void 0===y?void 0:y.statistics})),b=this.request(this.url+"/histograms",{query:{variable:p,f:"json"},signal:y}).then((p=>{var y;return null===(y=p.data)||void 0===y?void 0:y.histograms})),I=await Promise.all([_,b]);return I[0]&&I[0].forEach((p=>{p.avg=p.mean,p.stddev=p.standardDeviation})),null!==(w=I[1])&&void 0!==w&&null!==(w=w[0])&&void 0!==w&&null!==(w=w.counts)&&void 0!==w&&w.length||(I[1]=null),{statistics:I[0]||null,histograms:I[1]||null}}async computeBestPyramidLevelForLocation(p){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this._tilemapCache)return 0;let w=this.identifyPixelLocation(p,0,y.datumTransformation);if(null===w)return null;let _=0;const{maximumPyramidLevel:b}=this.rasterInfo.storageInfo;let I=b-_+this._levelOffset;const R=w.srcLocation;for(;I>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(I,w.row,w.col,y))break}catch{}if(I--,_++,w=this.identifyPixelLocation(R,_,y.datumTransformation),null===w)return null}return-1===I||null==w?null:_}async _fetchRasterInfo(p){const y=this.sourceJSON;if("Map"===this.tileType){const p=y.fullExtent||y.extent,w=Math.ceil((p.xmax-p.xmin)/y.pixelSizeX-.1),_=Math.ceil((p.ymax-p.ymin)/y.pixelSizeY-.1),b=pe.A.fromJSON(y.spatialReference||p.spatialReference),I=new me.A({x:y.pixelSizeX,y:y.pixelSizeY,spatialReference:b});return new ze.A({width:w,height:_,bandCount:3,extent:fe.A.fromJSON(p),spatialReference:b,pixelSize:I,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:w}=p,_=(0,nt.Tw)(this.url,this.sourceJSON,{signal:w,query:this.ioConfig.customFetchParameters}),b=y.hasMultidimensions?this.request("".concat(this.url,"/slices"),{query:{f:"json"},signal:w}).then((p=>{var y;return null===(y=p.data)||void 0===y?void 0:y.slices})).catch((()=>null)):null,I=await Promise.all([_,b]);return this._slices=I[1],I[0]}_fixScaleInServiceInfo(){const{sourceJSON:p}=this;p.minScale&&p.minScale<0&&(p.minScale=0),p.maxScale&&p.maxScale<0&&(p.maxScale=0)}_fixGCSShift(p){const{extent:y,spatialReference:w}=p;y.xmin>-1&&y.xmax>181&&(null===w||void 0===w?void 0:w.wkid)&&w.isGeographic&&(p.nativeExtent=p.extent,p.transform=new it.A,p.extent=p.transform.forwardTransform(y))}_computeMinMaxLOD(p,y){var w,_;const{pixelSize:b}=p,I=.5/p.width*b.x,{lods:R}=y,T=y.lodAt(Math.max.apply(null,R.map((p=>p.level)))),A=y.lodAt(Math.min.apply(null,R.map((p=>p.level)))),{tileType:M}=this;if("Map"===M)return this._levelOffset=R[0].level,[T,A];var k;if("Raster"===M)return[null!==(k=R.find((p=>p.resolution===b.x)))&&void 0!==k?k:T,A];const{minScale:C,maxScale:P}=this.sourceJSON;let O=T;P>0&&(O=R.find((p=>Math.abs(p.scale-P)<I)),O||(O=null!==(w=R.filter((p=>p.scale>P)).sort(((p,y)=>p.scale>y.scale?1:-1))[0])&&void 0!==w?w:T));let D=A;return C>0&&(D=null!==(_=R.find((p=>Math.abs(p.scale-C)<I)))&&void 0!==_?_:A,this._levelOffset=D.level-A.level),[O,D]}};(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],rt.prototype,"datasetFormat",void 0),(0,_._)([(0,C.MZ)()],rt.prototype,"tileType",void 0),rt=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.ImageServerRaster")],rt);const st=rt;var at=w(94934);const ot=new Map;ot.set("Int8","s8"),ot.set("UInt8","u8"),ot.set("Int16","s16"),ot.set("UInt16","u16"),ot.set("Int32","s32"),ot.set("UInt32","u32"),ot.set("Float32","f32"),ot.set("Float64","f32"),ot.set("Double64","f32");const lt=new Map;lt.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),lt.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),lt.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),lt.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let ct=class extends ve{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(p){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const y=p?p.signal:null,w=await this.request(this.url,{responseType:"xml",signal:y}),{rasterInfo:_,files:b}=this._parseHeader(w.data),{skipMapInfo:I,skipExtensions:R=[]}=this.ioConfig;if(!R.includes("aux.xml")&&!I){var T;const y=await this._fetchAuxiliaryData(p);null!=y&&(_.statistics=null!==(T=y.statistics)&&void 0!==T?T:_.statistics,_.histograms=y.histograms,y.histograms&&null==_.statistics&&(_.statistics=(0,Re.Pg)(y.histograms)))}I&&this.updateImageSpaceRasterInfo(_),this._set("rasterInfo",_),this._files=b;const A=await this.request(b.index,{responseType:"array-buffer",signal:y});this._storageIndex=this._parseIndex(A.data);const{blockWidth:M,blockHeight:k}=this.rasterInfo.storageInfo,C=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:P,height:O}=this.rasterInfo,D=[],B=this._getBandSegmentCount();let N=0,z=-1;for(;N<this._storageIndex.length;){z++;const p=Math.ceil(P/M/C**z)-1,y=Math.ceil(O/k/C**z)-1;N+=(p+1)*(y+1)*B*4,D.push({maxRow:y,maxCol:p,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=D,z>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=z),this.updateTileInfo()}async fetchRawTile(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{blockWidth:b,blockHeight:I,blockBoundary:R}=this.rasterInfo.storageInfo,T=R[p];if(!T||T.maxRow<y||T.maxCol<w||T.minRow>y||T.minCol>w)return null;const{bandCount:A,pixelType:M}=this.rasterInfo,{ranges:k,actualTileWidth:C,actualTileHeight:P}=this._getTileLocation(p,y,w);if(!k||0===k.length)return null;if(0===k[0].from&&0===k[0].to){const p=new Uint8Array(b*I);return new we.A({width:b,height:I,pixels:null,mask:p,validPixelCount:0})}const{bandIds:O}=this.ioConfig,D=this._getBandSegmentCount(),B=[];let N=0;for(N=0;N<D;N++)O&&!O.includes(N)||B.push(this.request(this._files.data,{range:{from:k[N].from,to:k[N].to},responseType:"array-buffer",signal:_.signal}));const z=await Promise.all(B),J=z.map((p=>p.data.byteLength)).reduce(((p,y)=>p+y)),E=new Uint8Array(J),H=[];let U=0;for(N=0;N<D;N++)H.push(U),E.set(new Uint8Array(z[N].data),U),U+=z[N].data.byteLength;const G=lt.get(this.rasterInfo.storageInfo.compression).decoderFormat,W=await this.decodePixelBlock(E.buffer,{width:b,height:I,format:G,planes:(null===O||void 0===O?void 0:O.length)||A,offsets:H,pixelType:M});if(null==W)return null;let{noDataValue:q}=this.rasterInfo;if(null!=q&&"lerc"!==G&&!W.mask&&(q=q[0],null!=q)){const p=W.width*W.height,y=new Uint8Array(p);if(Math.abs(q)>1e24)for(N=0;N<p;N++)Math.abs((W.pixels[0][N]-q)/q)>1e-6&&(y[N]=1);else for(N=0;N<p;N++)W.pixels[0][N]!==q&&(y[N]=1);W.mask=y}let Z=0,j=0;if(C!==b||P!==I){let p=W.mask;if(p)for(N=0;N<I;N++)if(j=N*b,N<P)for(Z=C;Z<b;Z++)p[j+Z]=0;else for(Z=0;Z<b;Z++)p[j+Z]=0;else for(p=new Uint8Array(b*I),W.mask=p,N=0;N<P;N++)for(j=N*b,Z=0;Z<C;Z++)p[j+Z]=1}return W}_parseIndex(p){if(p.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let y,w,_,b,I,R;if(at.Z){for(w=new Uint8Array(p),b=new ArrayBuffer(p.byteLength),_=new Uint8Array(b),I=0;I<p.byteLength/4;I++)for(R=0;R<4;R++)_[4*I+R]=w[4*I+3-R];y=new Uint32Array(b)}else y=new Uint32Array(p);return y}_getBandSegmentCount(){return lt.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(p,y,w){const{blockWidth:_,blockHeight:b,pyramidScalingFactor:I}=this.rasterInfo.storageInfo,{width:R,height:T}=this.rasterInfo,A=this._getBandSegmentCount();let M,k,C,P=0,O=0;for(C=0;C<p;C++)O=I**C,M=Math.ceil(R/_/O),k=Math.ceil(T/b/O),P+=M*k;O=I**p,M=Math.ceil(R/_/O),k=Math.ceil(T/b/O),P+=y*M+w,P*=4*A;const D=this._storageIndex.subarray(P,P+4*A);let B=0,N=0;const z=[];for(let J=0;J<A;J++)B=D[4*J]*2**32+D[4*J+1],N=B+D[4*J+2]*2**32+D[4*J+3],z.push({from:B,to:N});return{ranges:z,actualTileWidth:w<M-1?_:Math.ceil(R/O)-_*(M-1),actualTileHeight:y<k-1?b:Math.ceil(T/O)-b*(k-1)}}_parseHeader(p){const y=xmlUtilities_e(p,"MRF_META/Raster");if(!y)throw new R.A("mrf:open","not a valid MRF format");const w=xmlUtilities_e(y,"Size"),_=parseInt(w.getAttribute("x"),10),b=parseInt(w.getAttribute("y"),10),I=parseInt(w.getAttribute("c"),10),T=(xmlUtilities_t(y,"Compression")||"none").toLowerCase();if(!lt.has(T))throw new R.A("mrf:open","currently does not support compression "+T);const A=xmlUtilities_t(y,"DataType")||"UInt8",M=ot.get(A);if(null==M)throw new R.A("mrf:open","currently does not support pixel type "+A);const k=xmlUtilities_e(y,"PageSize"),C=parseInt(k.getAttribute("x"),10),P=parseInt(k.getAttribute("y"),10),O=xmlUtilities_e(y,"DataValues");let D,B;if(O&&(B=O.getAttribute("NoData"),null!=B&&(D=B.trim().split(" ").map((p=>parseFloat(p))))),xmlUtilities_e(p,"MRF_META/CachedSource"))throw new R.A("mrf:open","currently does not support MRF referencing other data files");const N=xmlUtilities_e(p,"MRF_META/GeoTags"),z=xmlUtilities_e(N,"BoundingBox");let J,E=!1;if(null!=z){var H;const p=parseFloat(z.getAttribute("minx")),y=parseFloat(z.getAttribute("miny")),w=parseFloat(z.getAttribute("maxx")),_=parseFloat(z.getAttribute("maxy")),b=xmlUtilities_t(N,"Projection")||"";let I=pe.A.WGS84;if("LOCAL_CS[]"!==b)if(b.toLowerCase().startsWith("epsg:")){const p=Number(b.slice(5));isNaN(p)||0===p||(I=new pe.A({wkid:p}))}else I=null!==(H=pamParser_d(b))&&void 0!==H?H:pe.A.WGS84;else E=!0,I=new pe.A({wkid:3857});J=new fe.A(p,y,w,_),J.spatialReference=I}else E=!0,J=new fe.A({xmin:-.5,ymin:.5-b,xmax:_-.5,ymax:.5,spatialReference:new pe.A({wkid:3857})});const U=xmlUtilities_e(p,"MRF_META/Rsets"),G=parseInt((null===U||void 0===U?void 0:U.getAttribute("scale"))||"2",10),W=J.spatialReference,q=new re.A({origin:new me.A({x:J.xmin,y:J.ymax,spatialReference:W}),blockWidth:C,blockHeight:P,pyramidBlockWidth:C,pyramidBlockHeight:P,compression:T,pyramidScalingFactor:G}),Z=new me.A({x:J.width/_,y:J.height/b,spatialReference:W}),j=new ze.A({width:_,height:b,extent:J,isPseudoSpatialReference:E,spatialReference:W,bandCount:I,pixelType:M,pixelSize:Z,noDataValue:D,storageInfo:q}),V=xmlUtilities_t(p,"datafile"),Y=xmlUtilities_t(p,"IndexFile");return{rasterInfo:j,files:{mrf:this.url,index:Y||this.url.replace(".mrf",".idx"),data:V||this.url.replace(".mrf",lt.get(T).blobExtension)}}}async _fetchAuxiliaryData(p){try{const{data:y}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null===p||void 0===p?void 0:p.signal});return S(y)}catch{return null}}};(0,_._)([(0,C.MZ)()],ct.prototype,"_files",void 0),(0,_._)([(0,C.MZ)()],ct.prototype,"_storageIndex",void 0),(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],ct.prototype,"datasetFormat",void 0),ct=(0,_._)([(0,B.$)("esri.layers.support.rasterIO.MRFRaster")],ct);const ut=ct;var ht=w(35890),dt=w(73741);const TIFFRaster_S=(p,y)=>{var w;return null===(w=p.get(y))||void 0===w?void 0:w.values},F=(p,y)=>{var w;return null===(w=p.get(y))||void 0===w||null===(w=w.values)||void 0===w?void 0:w[0]};let ft=class extends ve{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(p){var y,w;await this.init();const _=p?p.signal:null,{data:b}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:_});if(!b)throw new R.A("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:I,firstIFDPos:A,isBigTiff:M}=(0,ht.uT)(b),k=[];await this._readIFDs(k,b,I,A,0,M?8:4,_);const{imageInfo:C,rasterInfo:P}=this._parseIFDs(k),O=(0,ht.zS)(k),D=(0,ht.r9)(k);if(this._headerInfo={littleEndian:I,isBigTiff:M,ifds:k,pyramidIFDs:O,maskIFDs:D,...C},this._set("rasterInfo",P),!C.isSupported)throw new R.A("tiffraster:open","this tiff is not supported: "+C.message);if(!C.tileWidth)throw new R.A("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");P.isPseudoSpatialReference&&T.A.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const B=null===(y=k[0].get("PREDICTOR"))||void 0===y||null===(y=y.values)||void 0===y?void 0:y[0];if(3===(null===(w=k[0].get("SAMPLEFORMAT"))||void 0===w||null===(w=w.values)||void 0===w?void 0:w[0])&&2===B)throw new R.A("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:N,skipExtensions:z=[]}=this.ioConfig;if(!z.includes("aux.xml")&&!N){const y=await this._fetchAuxiliaryMetaData(p);null!=y&&this._processPAMInfo(y,P)}z.includes("vat.dbf")||1!==P.bandCount||"u8"!==P.pixelType||N||(P.attributeTable=await this._fetchAuxiliaryTable(p),null!=P.attributeTable&&(P.keyProperties.DataType="thematic")),N&&this.updateImageSpaceRasterInfo(P),this.updateTileInfo()}async fetchRawTile(p,y,w){var _;let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(null===(_=this._headerInfo)||void 0===_||!_.isSupported||this.isBlockOutside(p,y,w))return null;const I=await this._fetchRawTiffTile(p,y,w,!1,b);if(null!=I&&this._headerInfo.hasMaskBand){const _=await this._fetchRawTiffTile(p,y,w,!0,b);null!=_&&_.pixels[0]instanceof Uint8Array&&(I.mask=_.pixels[0])}return I}_parseIFDs(p){var y,w;const _=(0,ht.uc)(p),{width:b,height:I,tileWidth:R,tileHeight:T,planes:A,pixelType:M,compression:k,firstPyramidLevel:C,maximumPyramidLevel:P,pyramidBlockWidth:O,pyramidBlockHeight:D,tileBoundary:B,affine:N,metadata:z}=_;let J=pamParser_d((null===(y=_.extent.spatialReference)||void 0===y?void 0:y.wkt)||(null===(w=_.extent.spatialReference)||void 0===w?void 0:w.wkid)),E=!!_.isPseudoGeographic;null==J&&(E=!0,J=new pe.A({wkid:3857}));const H=new fe.A({..._.extent,spatialReference:J}),U=new me.A(H?{x:H.xmin,y:H.ymax,spatialReference:J}:{x:0,y:0}),G=new re.A({blockWidth:R,blockHeight:T,pyramidBlockWidth:O,pyramidBlockHeight:D,compression:k,origin:U,firstPyramidLevel:C,maximumPyramidLevel:P,blockBoundary:B}),W=new me.A({x:(H.xmax-H.xmin)/b,y:(H.ymax-H.ymin)/I,spatialReference:J}),q=z?{BandProperties:z.bandProperties,DataType:z.dataType}:{};let Z=null;const j=F(p[0],"PHOTOMETRICINTERPRETATION"),V=TIFFRaster_S(p[0],"COLORMAP");if(j<=3&&(null===V||void 0===V?void 0:V.length)>3&&V.length%3==0){Z=[];const p=V.length/3;for(let y=0;y<p;y++)Z.push([y,V[y]>>>8,V[y+p]>>>8,V[y+2*p]>>>8])}const Y=new ze.A({width:b,height:I,bandCount:A,pixelType:M,pixelSize:W,storageInfo:G,spatialReference:J,isPseudoSpatialReference:E,keyProperties:q,extent:H,colormap:Z,statistics:z?z.statistics:null});return null!==N&&void 0!==N&&N.length&&(Y.nativeExtent=new fe.A({xmin:-.5,ymin:.5-I,xmax:b-.5,ymax:.5,spatialReference:J}),Y.transform=new $e.A({polynomialOrder:1,forwardCoefficients:[N[2]+N[0]/2,N[5]-N[3]/2,N[0],N[3],-N[1],-N[4]]}),Y.extent=Y.transform.forwardTransform(Y.nativeExtent),Y.pixelSize=new me.A({x:(H.xmax-H.xmin)/b,y:(H.ymax-H.ymin)/I,spatialReference:J}),G.origin.x=-.5,G.origin.y=.5),{imageInfo:_,rasterInfo:Y}}_processPAMInfo(p,y){var w;if(y.statistics=null!==(w=p.statistics)&&void 0!==w?w:y.statistics,y.histograms=p.histograms,p.histograms&&null==y.statistics&&(y.statistics=(0,Re.Pg)(p.histograms)),p.transform&&null==y.transform){y.transform=p.transform,y.nativeExtent=y.extent;const w=y.transform.forwardTransform(y.nativeExtent);y.pixelSize=new me.A({x:(w.xmax-w.xmin)/y.width,y:(w.ymax-w.ymin)/y.height,spatialReference:y.spatialReference}),y.extent=w}y.isPseudoSpatialReference&&p.spatialReference&&(y.spatialReference=p.spatialReference,y.extent.spatialReference=y.nativeExtent.spatialReference=y.storageInfo.origin.spatialReference=y.spatialReference)}async _readIFDs(p,y,w,_,b){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:4,R=arguments.length>6?arguments[6]:void 0;if(!_)return null;(_>=y.byteLength||_<0)&&(y=(await this.request(this.url,{range:{from:_+b,to:_+b+this._bufferSize},responseType:"array-buffer",signal:R})).data,b=_+b,_=0);const T=await this._readIFD(y,w,_,b,dt.A.tiffTags,I,R);if(p.push(T.ifd),!T.nextIFD)return null;await this._readIFDs(p,y,w,T.nextIFD-b,b,I,R)}async _readIFD(p,y,w,_){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:dt.A.tiffTags,I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:4,R=arguments.length>6?arguments[6]:void 0;if(!p)return null;const T=(0,ht.JM)(p,y,w,_,b,I);if(T.success){var A,M;const w=[];if(null!==(A=T.ifd)&&void 0!==A&&A.forEach((p=>{p.values||w.push(p)})),w.length>0){const b=w.map((p=>p.offlineOffsetSize)).filter(Ye.Ru),I=Math.min.apply(null,b.map((p=>p[0])));if(Math.min.apply(null,b.map((p=>p[0]+p[1])))-I<=this._bufferSize){const{data:b}=await this.request(this.url,{range:{from:I,to:I+this._bufferSize},responseType:"array-buffer",signal:R});p=b,_=I,w.forEach((w=>(0,ht.Cr)(p,y,w,_)))}}if(null!==(M=T.ifd)&&void 0!==M&&M.has("GEOKEYDIRECTORY")){const w=T.ifd.get("GEOKEYDIRECTORY"),b=null===w||void 0===w?void 0:w.values;if(b&&b.length>4){const I=b[0]+"."+b[1]+"."+b[2],T=await this._readIFD(p,y,w.valueOffset+6-_,_,dt.A.geoKeys,2,R);w.data=T.ifd,w.data&&w.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[I]})}}return T}if(T.requiredBufferSize&&T.requiredBufferSize!==p.byteLength){const w=await this.request(this.url,{range:{from:_,to:_+T.requiredBufferSize+4},responseType:"array-buffer",signal:R});return(p=w.data).byteLength<T.requiredBufferSize?null:this._readIFD(p,y,0,_,dt.A.tiffTags,4,R)}}async _fetchRawTiffTile(p,y,w,_){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const I=this._getTileLocation(p,y,w,_);if(!I)return null;const{ranges:R,actualTileWidth:T,actualTileHeight:A,ifd:M}=I,k=R.map((p=>this.request(this.url,{range:p,responseType:"array-buffer",signal:b.signal}))),C=await Promise.all(k),P=C.map((p=>p.data.byteLength)).reduce(((p,y)=>p+y)),O=1===C.length?C[0].data:new ArrayBuffer(P),D=[0],B=[0];if(C.length>1){const p=new Uint8Array(O);for(let y=0,w=0;y<C.length;y++){const _=C[y].data;p.set(new Uint8Array(_),w),D[y]=w,w+=_.byteLength,B[y]=_.byteLength}}const{blockWidth:N,blockHeight:z}=this.getBlockWidthHeight(p),J=await this.decodePixelBlock(O,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:M,offsets:D,sizes:B},width:N,height:z,planes:null,pixelType:null});if(null==J)return null;let E,H,U;if(T!==N||A!==z){let p=J.mask;if(p)for(E=0;E<z;E++)if(U=E*N,E<A)for(H=T;H<N;H++)p[U+H]=0;else for(H=0;H<N;H++)p[U+H]=0;else for(p=new Uint8Array(N*z),J.mask=p,E=0;E<A;E++)for(U=E*N,H=0;H<T;H++)p[U+H]=1}return J}_getTileLocation(p,y,w){let _=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{firstPyramidLevel:b,blockBoundary:I}=this.rasterInfo.storageInfo,R=0===p?0:p-(b-1),{_headerInfo:T}=this;if(!T)return null;const A=_?T.maskIFDs[R]:0===R?null===T||void 0===T?void 0:T.ifds[0]:null===T||void 0===T?void 0:T.pyramidIFDs[R-1];if(!A)return null;const M=(0,ht.XO)(A,T),k=TIFFRaster_S(A,"TILEOFFSETS");if(void 0===k)return null;const C=TIFFRaster_S(A,"TILEBYTECOUNTS"),{minRow:P,minCol:O,maxRow:D,maxCol:B}=I[R];if(y>D||w>B||y<P||w<O)return null;const N=F(A,"IMAGEWIDTH"),z=F(A,"IMAGELENGTH"),J=F(A,"TILEWIDTH"),E=F(A,"TILELENGTH"),H=[];if(M){const{bandCount:p}=this.rasterInfo;for(let _=0;_<p;_++){const p=_*(D+1)*(B+1)+y*(B+1)+w;H[_]={from:k[p],to:k[p]+C[p]-1}}}else{const p=y*(B+1)+w;H.push({from:k[p],to:k[p]+C[p]-1})}for(let U=0;U<H.length;U++)if(null==H[U].from||!H[U].to||H[U].to<0)return null;return{ranges:H,ifd:A,actualTileWidth:w===B&&N%J||J,actualTileHeight:y===D&&z%E||E}}async _fetchAuxiliaryMetaData(p){try{const{data:y}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null===p||void 0===p?void 0:p.signal});return S(y)}catch{return null}}async _fetchAuxiliaryTable(p){try{const{data:y}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:null===p||void 0===p?void 0:p.signal}),w=DBFParser_r.parse(y);return null!==w&&void 0!==w&&w.recordSet?_e.A.fromJSON(w.recordSet):null}catch{return null}}};(0,_._)([(0,C.MZ)()],ft.prototype,"_files",void 0),(0,_._)([(0,C.MZ)()],ft.prototype,"_headerInfo",void 0),(0,_._)([(0,C.MZ)()],ft.prototype,"_bufferSize",void 0),(0,_._)([(0,C.MZ)({type:String,json:{write:!0}})],ft.prototype,"datasetFormat",void 0),ft=(0,_._)([(0,B.$)("esri.layers.support.rasterDatasets.TIFFRaster")],ft);const mt=ft,pt=new Map;pt.set("CRF",{desc:"Cloud Raster Format",constructor:Ue}),pt.set("MRF",{desc:"Meta Raster Format",constructor:ut}),pt.set("TIFF",{desc:"GeoTIFF",constructor:mt}),pt.set("RasterTileServer",{desc:"Raster Tile Server",constructor:st}),pt.set("JPG",{desc:"JPG Raster Format",constructor:Ke}),pt.set("PNG",{desc:"PNG Raster Format",constructor:Ke}),pt.set("GIF",{desc:"GIF Raster Format",constructor:Ke}),pt.set("BMP",{desc:"BMP Raster Format",constructor:Ke}),pt.set("CovJSON",{desc:"COVJSON Raster Format",constructor:Ve}),pt.set("MEMORY",{desc:"In Memory Raster Format",constructor:Ze});class RasterFactory_l{static get supportedFormats(){const p=new Set;return pt.forEach(((y,w)=>p.add(w))),p}static async open(p){var y,w;const{url:_,ioConfig:b,source:I,sourceJSON:T}=p;let A=null!==(y=p.datasetFormat)&&void 0!==y?y:null===b||void 0===b?void 0:b.datasetFormat;null==A&&(_.includes(".")?A=_.slice(_.lastIndexOf(".")+1).toUpperCase():"coverage"===(null===I||void 0===I||null===(w=I.type)||void 0===w?void 0:w.toLowerCase())?A="CovJSON":(null===I||void 0===I?void 0:I.extent)&&I.pixelblocks&&(A="MEMORY")),"OVR"===A||"TIF"===A?A="TIFF":"JPG"===A||"JPEG"===A||"JFIF"===A?A="JPG":"COVJSON"===A&&(A="CovJSON"),_.toLowerCase().includes("/imageserver")&&!_.toLowerCase().includes("/wcsserver")&&(A="RasterTileServer");const M={url:_,source:I,sourceJSON:T,datasetFormat:A,ioConfig:null!==b&&void 0!==b?b:{bandIds:null,sampling:null}};if(Object.keys(M).forEach((p=>{null==M[p]&&delete M[p]})),A){if(!this.supportedFormats.has(A))throw new R.A("rasterfactory:open","not a supported format "+A);if("CRF"===A&&(null===b||void 0===b||!b.enableCRF))throw new R.A("rasterfactory:open","cannot open raster: ".concat(_));const y=new(0,pt.get(A).constructor)(M);return await y.open({signal:p.signal}),y}const k=Array.from(pt.keys()).filter((p=>"CovJSON"!==p&&"Memory"!==p));let C=0;const m=()=>{if(A=k[C++],!A)return null;if("CRF"===A&&(null===b||void 0===b||!b.enableCRF))return null;const y=new(0,pt.get(A).constructor)(M);return y.open({signal:p.signal}).then((()=>y)).catch((()=>m()))};return m()}static register(p,y,w){pt.has(p.toUpperCase())||pt.set(p.toUpperCase(),{desc:y,constructor:w})}}var yt=w(7445),gt=w(96253);let vt=class extends((0,J.d)((0,Oe.j)((0,Fe.q)((0,Ce.A)((0,E.d)(L((0,De.e)((0,z.b)((0,Pe.J)((0,A.P)((0,I.O)(N.A)))))))))))){constructor(){super(...arguments),this._primaryRasters=[],this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this.source=void 0,this._debouncedSaveOperations=(0,M.sg)((async(p,y,_)=>{const{save:b,saveAs:I}=await w.e(4732).then(w.bind(w,24732));switch(p){case gt.X.SAVE:return b(this,y);case gt.X.SAVE_AS:return I(this,_,y)}}))}normalizeCtorArgs(p,y){return"string"==typeof p?{url:p,...y}:p}load(p){const y=null!=p?p.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},p).catch(M.QP).then((()=>this._openRaster(y)))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){const p=[new Be.A({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"}),new Be.A({name:"Raster.ServicePixelValue.Raw",alias:"Raw Pixel Value",domain:null,editable:!1,length:50,type:"string"})],{serviceRasterInfo:y}=this,w=null===y||void 0===y?void 0:y.attributeTable,_=null!=w?w.fields:null;if(_){const y=_.filter((p=>"oid"!==p.type&&"value"!==p.name.toLowerCase())).map((p=>{const y=p.clone();return y.name="Raster."+p.name,y}));p.push(...y)}const b=null===y||void 0===y?void 0:y.dataType,I=null===y||void 0===y?void 0:y.multidimensionalInfo;if(("vector-magdir"===b||"vector-uv"===b)&&null!=I){var R;const y=null===(R=I.variables[0].unit)||void 0===R?void 0:R.trim(),w="Magnitude"+(y?" (".concat(y,")"):"");p.push(new Be.A({name:"Raster.Magnitude",alias:w,domain:null,editable:!1,type:"double"})),p.push(new Be.A({name:"Raster.Direction",alias:"Direction (\xb0)",domain:null,editable:!1,type:"double"}))}return p}createPopupTemplate(p){const{rasterFields:y}=this,w=new Set(y.map((p=>{let{name:y}=p;return y})).filter((p=>"raster.servicepixelvalue.raw"!==p.toLowerCase())));return(0,yt.tn)({fields:y,title:this.title},{...p,visibleFieldNames:w})}async generateRasterInfo(p,y){if(!(p=(0,P.PZ)(X.A,p)))return this.serviceRasterInfo;try{const{rasterInfo:w}=await this._openFunctionRaster(p,y);return w}catch(w){if(w instanceof R.A)throw w;throw new R.A("imagery-tile-layer","the given raster function is not supported")}}async save(p){return this._debouncedSaveOperations(gt.X.SAVE,p)}async saveAs(p,y){return this._debouncedSaveOperations(gt.X.SAVE_AS,y,p)}write(p,y){var w;const _=null!==(w=this._primaryRasters[0])&&void 0!==w?w:this.raster;if(this.loaded?"RasterTileServer"===_.datasetFormat&&("Raster"===_.tileType||"Map"===_.tileType):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(p,y);if(null!==y&&void 0!==y&&y.messages){const p="".concat(y.origin,"/").concat(y.layerContainerType||"operational-layers");y.messages.push(new R.A("layer:unsupported","Layers (".concat(this.title,", ").concat(this.id,") of type '").concat(this.declaredClass,"' are not supported in the context of '").concat(p,"'"),{layer:this}))}return null}async _openRaster(p){let y=!1;if(this.raster)await this._openFromRaster(this.raster,p),y="Function"===this.raster.datasetFormat;else{const{url:y,rasterFunction:w,source:_}=this;if(!y&&!_)throw new R.A("imagery-tile-layer:open","missing url or source parameter");_?await this._openFromSource(_,p):w?await this._openFromUrlWithRasterFunction(y,w,p):await this._openFromUrl(y,p)}const w=this.raster.rasterInfo;if(!w)throw new R.A("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("serviceRasterInfo",y?w:this._primaryRasters[0].rasterInfo),this._set("spatialReference",w.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,null!=this.sourceJSON){const p="Map"===this.raster.tileType&&null!=this.sourceJSON.minLOD&&null!=this.sourceJSON.maxLOD?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(p,{origin:"service"})}else this.read({tileInfo:this.serviceRasterInfo.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),"Map"===this.raster.tileType&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles((0,k.wB)((()=>this.customParameters),(p=>{this.raster&&(this.raster.ioConfig.customFetchParameters=p)})))}async _openFromRaster(p,y){p.rasterInfo||await p.open({signal:y}),this._primaryRasters="Function"===p.datasetFormat?p.primaryRasters.rasters:[p],this.url||(this.url=this._primaryRasters[0].url)}async _openFromUrlWithRasterFunction(p,y,w){const _=[p];y&&(0,Se.UD)(y.toJSON(),_);const b=await Promise.all(_.map((p=>RasterFactory_l.open({url:p,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:w})))),I=b.findIndex((p=>null==p));if(I>-1)throw new R.A("imagery-tile-layer:open","cannot open raster: ".concat(_[I]));return this._primaryRasters=b,this._initializeWithFunctionRaster(y)}async _openFromUrl(p,y){const w=await RasterFactory_l.open({url:p,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:y});if(null==w)throw new R.A("imagery-tile-layer:open","cannot open raster: ".concat(p));this._primaryRasters=[w],this.raster=w}async _openFromSource(p,y){var w;const _="the tiled imagery data source is not supported",b="coverage"===(null===(w=p.type)||void 0===w?void 0:w.toLowerCase())?"CovJSON":p.extent&&p.pixelBlock?"MEMORY":null;if(!b)throw new R.A("imagery-tile-layer:open",_);"MEMORY"===b&&(p={extent:p.extent,pixelBlocks:[p.pixelBlock]});const I=await RasterFactory_l.open({url:"",source:p,datasetFormat:b,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:y});if(null==I)throw new R.A("imagery-tile-layer:open",_);this._primaryRasters=[I],this.rasterFunction?await this._initializeWithFunctionRaster(this.rasterFunction):this.raster=I}async _openFunctionRaster(p,y){var w,_;const b={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach((p=>b[p.url]=p));const I=(0,Se.vt)(null!==(w=null===(_=p.functionDefinition)||void 0===_?void 0:_.toJSON())&&void 0!==w?w:p.toJSON(),b),R=new Ie({rasterFunction:I});return await R.open(y),R}async _initializeWithFunctionRaster(p,y){try{this.raster=await this._openFunctionRaster(p,y)}catch(w){w instanceof R.A&&T.A.getLogger(this).error("imagery-tile-layer:open",w.message),T.A.getLogger(this).warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=this._primaryRasters[0]}}};(0,_._)([(0,C.MZ)({clonable:!1})],vt.prototype,"_primaryRasters",void 0),(0,_._)([(0,C.MZ)({type:[P.jz],json:{write:{overridePolicy(){var p;return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==(null===(p=this.bandIds)||void 0===p?void 0:p.join(","))}}}}})],vt.prototype,"bandIds",void 0),(0,_._)([(0,C.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,D.e)(Ne.SZ)],vt.prototype,"interpolation",void 0),(0,_._)([(0,C.MZ)(j.fV)],vt.prototype,"legendEnabled",void 0),(0,_._)([(0,C.MZ)({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],vt.prototype,"isReference",void 0),(0,_._)([(0,C.MZ)({type:["show","hide"]})],vt.prototype,"listMode",void 0),(0,_._)([(0,C.MZ)({json:{read:!0,write:!0}})],vt.prototype,"blendMode",void 0),(0,_._)([(0,C.MZ)()],vt.prototype,"sourceJSON",void 0),(0,_._)([(0,C.MZ)({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],vt.prototype,"version",void 0),(0,_._)([(0,C.MZ)({readOnly:!0,json:{read:!1}})],vt.prototype,"type",void 0),(0,_._)([(0,C.MZ)({type:["ArcGISTiledImageServiceLayer"]})],vt.prototype,"operationalLayerType",void 0),(0,_._)([(0,C.MZ)({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(p,y)=>!y.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}},writer(p,y,w){y[w]=!p}}}})],vt.prototype,"popupEnabled",void 0),(0,_._)([(0,C.MZ)({type:b.A,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}}}}})],vt.prototype,"popupTemplate",void 0),(0,_._)([(0,C.MZ)({readOnly:!0})],vt.prototype,"defaultPopupTemplate",null),(0,_._)([(0,C.MZ)({readOnly:!0,type:[Be.A]})],vt.prototype,"fields",void 0),(0,_._)([(0,C.MZ)({readOnly:!0,type:[Be.A]})],vt.prototype,"rasterFields",null),(0,_._)([(0,C.MZ)({constructOnly:!0})],vt.prototype,"source",void 0),vt=(0,_._)([(0,B.$)("esri.layers.ImageryTileLayer")],vt);const xt=vt},62964:(p,y,w)=>{w.d(y,{d:()=>G});var _,b=w(80671),I=w(53705),R=w(18763),T=w(11277),A=w(4180),M=w(58285),k=w(20585),C=w(17244),P=w(81618),O=w(63390),D=w(59650),B=w(4270),N=w(57453),z=(w(50886),w(89412),w(76761),w(68682)),J=w(19156),E=w(16842),H=w(66004),U=w(49905);class Tilemap_r{constructor(p){this._validateJSON(p);const{location:y,data:w}=p;this.location=Object.freeze((0,H.o8)(y));const _=this.location.width,b=this.location.height;let I=!0,R=!0;const T=function UintArray_n(p){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return p<=U.y9?y?new Array(p).fill(0):new Array(p):new Uint32Array(p)}(Math.ceil(_*b/32));let A=0;for(let M=0;M<w.length;M++){const p=M%32;w[M]?(R=!1,T[A]|=1<<p):I=!1,31===p&&++A}R?(this._availability="unavailable",this.byteSize=40):I?(this._availability="available",this.byteSize=40):(this._availability=T,this.byteSize=40+(0,U.Ek)(T))}getAvailability(p,y){if("unavailable"===this._availability||"available"===this._availability)return this._availability;const w=(p-this.location.top)*this.location.width+(y-this.location.left),_=w%32,b=w>>5,I=this._availability;return b<0||b>I.length?"unknown":I[b]&1<<_?"available":"unavailable"}static fromDefinition(p,y){const w=p.service.request||I.A,{row:_,col:b,width:R,height:T}=p,M={query:{f:"json"}};return y=y?{...M,...y}:M,w(function s(p){var y;let w;if(null!==(y=p.service.tileServers)&&void 0!==y&&y.length){const y=p.service.tileServers;w="".concat(y&&y.length?y[p.row%y.length]:p.service.url,"/tilemap/").concat(p.level,"/").concat(p.row,"/").concat(p.col,"/").concat(p.width,"/").concat(p.height)}else w="".concat(p.service.url,"/tilemap/").concat(p.level,"/").concat(p.row,"/").concat(p.col,"/").concat(p.width,"/").concat(p.height);const _=p.service.query;return _&&(w="".concat(w,"?").concat(_)),w}(p),y).then((p=>p.data)).catch((p=>{if(p&&p.details&&422===p.details.httpStatus)return{location:{top:_,left:b,width:R,height:T},valid:!0,data:(0,E.dY)(R*T,0)};throw p})).then((p=>{if(p.location&&(p.location.top!==_||p.location.left!==b||p.location.width!==R||p.location.height!==T))throw new A.A("tilemap:location-mismatch","Tilemap response for different location than requested",{response:p,definition:{top:_,left:b,width:R,height:T}});return Tilemap_r.fromJSON(p)}))}static fromJSON(p){return Object.freeze(new Tilemap_r(p))}_validateJSON(p){if(null===p||void 0===p||!p.location)throw new A.A("tilemap:missing-location","Location missing from tilemap response");if(!1===p.valid)throw new A.A("tilemap:invalid","Tilemap response was marked as invalid");if(!p.data)throw new A.A("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(p.data))throw new A.A("tilemap:data-mismatch","Data must be an array of numbers");if(p.data.length!==p.location.width*p.location.height)throw new A.A("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function n(p){return"".concat(p.level,"/").concat(p.row,"/").concat(p.col,"/").concat(p.width,"/").concat(p.height)}let G=_=class extends R.A{constructor(p){super(p),this._pendingTilemapRequests={},this.request=I.A,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new k.q(2*T.u.MEGABYTES),this.addHandles((0,O.wB)((()=>{const{layer:p}=this;return[null===p||void 0===p?void 0:p.parsedUrl,null===p||void 0===p?void 0:p.tileServers,null===p||void 0===p?void 0:p.apiKey,null===p||void 0===p?void 0:p.customParameters]}),(()=>this._initializeTilemapDefinition()),O.Vh))}get effectiveMinLOD(){var p;return null!==(p=this.minLOD)&&void 0!==p?p:this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){var p;return null!==(p=this.maxLOD)&&void 0!==p?p:this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}fetchTilemap(p,y,w,_){var b;if(!this.layer.tileInfo.lodAt(p)||p<this.effectiveMinLOD||p>this.effectiveMaxLOD)return Promise.reject(new A.A("tilemap-cache:level-unavailable","Level ".concat(p," is unavailable in the service")));const I=this._tmpTilemapDefinition,R=this._tilemapFromCache(p,y,w,I);if(R)return Promise.resolve(R);const T=null===(b=_)||void 0===b?void 0:b.signal;return _={..._,signal:null},new Promise(((p,y)=>{(0,P.u7)(T,(()=>y((0,P.NK)())));const w=n(I);let b=this._pendingTilemapRequests[w];if(!b){b=Tilemap_r.fromDefinition(I,_).then((p=>(this._tilemapCache.put(w,p,p.byteSize),p)));const e=()=>{delete this._pendingTilemapRequests[w]};this._pendingTilemapRequests[w]=b,b.then(e,e)}b.then(p,y)}))}getAvailability(p,y,w){if(!this.layer.tileInfo.lodAt(p)||p<this.effectiveMinLOD||p>this.effectiveMaxLOD)return"unavailable";const _=this._tilemapFromCache(p,y,w,this._tmpTilemapDefinition);return _?_.getAvailability(y,w):"unknown"}fetchAvailability(p,y,w,_){return!this.layer.tileInfo.lodAt(p)||p<this.effectiveMinLOD||p>this.effectiveMaxLOD?Promise.reject(new A.A("tile-map:tile-unavailable","Tile is not available",{level:p,row:y,col:w})):this.fetchTilemap(p,y,w,_).catch((p=>p)).then((_=>{if(_ instanceof Tilemap_r){const b=_.getAvailability(y,w);if("unavailable"===b)throw new A.A("tile-map:tile-unavailable","Tile is not available",{level:p,row:y,col:w});return b}if((0,P.zf)(_))throw _;return"unknown"}))}fetchAvailabilityUpsample(p,y,w,_,b){_.level=p,_.row=y,_.col=w;const I=this.layer.tileInfo;I.updateTileInfo(_);const R=this.fetchAvailability(p,y,w,b).catch((p=>{if((0,P.zf)(p))throw p;if(I.upsampleTile(_))return this.fetchAvailabilityUpsample(_.level,_.row,_.col,_,b);throw p}));return this._fetchAvailabilityUpsamplePrefetch(_.id,p,y,w,b,R),R}async _fetchAvailabilityUpsamplePrefetch(p,y,w,b,I,R){if(!this._prefetchingEnabled||null==p)return;const T="prefetch-".concat(p);if(this.hasHandles(T))return;const A=new AbortController;R.then((()=>A.abort()),(()=>A.abort()));let k=!1;const C=(0,M.hA)((()=>{k||(k=!0,A.abort())}));if(this.addHandles(C,T),await(0,D.md)(10,A.signal).catch((()=>{})),k||(k=!0,this.removeHandles(T)),(0,P.G4)(A))return;const O=new J.U(p,y,w,b),B={...I,signal:A.signal},N=this.layer.tileInfo;for(let M=0;_._prefetches.length<_._maxPrefetch&&N.upsampleTile(O);++M){const p=this.fetchAvailability(O.level,O.row,O.col,B);_._prefetches.push(p);const t=()=>{_._prefetches.removeUnordered(p)};p.then(t,t)}}_initializeTilemapDefinition(){var p;if(!this.layer.parsedUrl)return;const{parsedUrl:y,apiKey:w,customParameters:_}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:y.path,query:(0,B.x0)({...y.query,..._,token:null!==w&&void 0!==w?w:null===(p=y.query)||void 0===p?void 0:p.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(p,y,w,_){_.level=p,_.row=y-y%this.size,_.col=w-w%this.size;const b=n(_);return this._tilemapCache.get(b)}get test(){const p=this;return{get prefetchingEnabled(){return p._prefetchingEnabled},set prefetchingEnabled(y){p._prefetchingEnabled=y},hasTilemap:(y,w,_)=>!!p._tilemapFromCache(y,w,_,p._tmpTilemapDefinition)}}};G._maxPrefetch=4,G._prefetches=new C.A({initialSize:_._maxPrefetch}),(0,b._)([(0,N.MZ)({constructOnly:!0})],G.prototype,"layer",void 0),(0,b._)([(0,N.MZ)({constructOnly:!0})],G.prototype,"minLOD",void 0),(0,b._)([(0,N.MZ)({constructOnly:!0})],G.prototype,"maxLOD",void 0),(0,b._)([(0,N.MZ)({constructOnly:!0})],G.prototype,"request",void 0),(0,b._)([(0,N.MZ)({constructOnly:!0})],G.prototype,"size",void 0),G=_=(0,b._)([(0,z.$)("esri.layers.support.TilemapCache")],G)},63741:(p,y,w)=>{w.d(y,{jX:()=>s,zo:()=>h,gd:()=>m,ph:()=>i,no:()=>x,kz:()=>u,ht:()=>a,yo:()=>g});w(30174);var _=w(13804),b=w(57264);const I=new Map,R=new class t{constructor(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:15e3,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=p,this._interval=Math.min(p,y)}decreaseRefCount(p,y){const w=p+"/"+y,_=this._cachedBlocks;if(_.has(w)){const p=_.get(w);return p.refCount--,p.refCount<=0&&(_.delete(w),p.controller&&p.controller.abort()),p.refCount}return 0}getBlock(p,y){const w=p+"/"+y,_=this._cachedBlocks;if(_.has(w)){const p=_.get(w);return p.ts=Date.now(),p.refCount++,_.delete(w),_.set(w,p),p.block}return null}putBlock(p,y,w,_){const b=this._cachedBlocks,I=p+"/"+y;if(b.has(I)){const p=b.get(I);p.ts=Date.now(),p.refCount++}else b.set(I,{block:w,ts:Date.now(),refCount:1,controller:_});this._trim(),this._updateTimer()}deleteBlock(p,y){const w=this._cachedBlocks,_=p+"/"+y;w.has(_)&&w.delete(_)}updateMaxSize(p){this._size=p,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const p=this._cachedBlocks;this._timer=setInterval((()=>{const y=Array.from(p),w=Date.now();for(let _=0;_<y.length&&y[_][1].ts<=w-this._duration;_++)p.delete(y[_][0]);0===p.size&&this._clearTimer()}),this._interval)}_trim(){const p=this._cachedBlocks;if(-1===this._size||this._size>=p.size)return;const y=Array.from(p);for(let w=0;w<y.length-this._size;w++)p.delete(y[w][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function i(p,y){return null==y?p:"".concat(p,"?sliceId=").concat(y)}function u(p,y){const w={extent:null,rasterInfo:y,cache:new Map},_=I.get(p);return _?(_.push(w),_.length-1):(I.set(p,[w]),0)}function a(p,y){const w=I.get(p);w&&(w[y]=null,w.some((p=>null!=p))||I.delete(p))}function s(p,y,w){var _;const b=I.get(p);if(!b)return null==y?R.decreaseRefCount(p,w):0;if(null==y||null==b[y])return R.decreaseRefCount(p,w);const T=null===(_=b[y])||void 0===_?void 0:_.cache,A=null===T||void 0===T?void 0:T.get(w);if(T&&A){if(A.refCount--,0===A.refCount){T.delete(w);for(let p=0;p<b.length;p++){var M;null===(M=b[p])||void 0===M||M.cache.delete(w)}A.controller&&A.controller.abort()}return A.refCount}return 0}function m(p,y,w){var _;const b=I.get(p);if(!b)return null==y?R.getBlock(p,w):null;if(null==y||null==b[y]){for(let p=0;p<b.length;p++){var T;const y=null===(T=b[p])||void 0===T?void 0:T.cache.get(w);if(y)return y.refCount++,y.block}return R.getBlock(p,w)}const A=null===(_=b[y])||void 0===_?void 0:_.cache.get(w);if(A)return A.refCount++,A.block;for(let I=0;I<b.length;I++){var M;if(I===y||!b[I])continue;const p=null===(M=b[I])||void 0===M?void 0:M.cache,_=null===p||void 0===p?void 0:p.get(w);if(p&&_)return _.refCount++,p.set(w,_),_.block}return null}function x(p,y,w,_){var b;let T=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const A=I.get(p);if(!A)return void(null==y&&R.putBlock(p,w,_,T));if(null==y||null==A[y])return void R.putBlock(p,w,_,T);const M={refCount:1,block:_,isResolved:!1,isRejected:!1,controller:T};_.then((()=>M.isResolved=!0)).catch((()=>M.isRejected=!0)),null===(b=A[y])||void 0===b||b.cache.set(w,M)}function h(p,y,w){var _;const b=I.get(p);b?null!=y&&null!=b[y]?null===(_=b[y])||void 0===_||_.cache.delete(w):R.deleteBlock(p,w):null==y&&R.deleteBlock(p,w)}function d(p,y){var w;const _=I.get(p);return _&&null!==(w=_[y])&&void 0!==w?w:null}function g(p,y,w,I,R,T){var A;let M=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const k=d(p,y);if(!k)return;const C=k.extent,{cache:P,rasterInfo:O}=k;if(C&&C.xmin===w.xmin&&C.xmax===w.xmax&&C.ymin===w.ymin&&C.ymax===w.ymax)return;I=null!==(A=I)&&void 0!==A?A:0;const D=w.clone().normalize(),{spatialReference:B,transform:N}=O,z=new Set;for(let J=0;J<D.length;J++){const p=D[J];if(p.xmax-p.xmin<=I||p.ymax-p.ymin<=I)continue;let y=(0,_._l)(p,B,M);null!=N&&(y=N.inverseTransform(y));const w=new b.A({x:I,y:I,spatialReference:p.spatialReference});if(null==R&&!(R=(0,_.Wo)(w,B,p,M)))return;const{pyramidLevel:A,pyramidResolution:k,excessiveReading:C}=(0,_.t$)(R,O,T||"closest");if(C)return;const{storageInfo:P}=O,{origin:E}=P,H={x:Math.max(0,Math.floor((y.xmin-E.x)/k.x)),y:Math.max(0,Math.floor((E.y-y.ymax)/k.y))},U=Math.ceil((y.xmax-y.xmin)/k.x-.1),G=Math.ceil((y.ymax-y.ymin)/k.y-.1),W=A>0?P.pyramidBlockWidth:P.blockWidth,q=A>0?P.pyramidBlockHeight:P.blockHeight,Z=1,j=Math.max(0,Math.floor(H.x/W)-Z),V=Math.max(0,Math.floor(H.y/q)-Z),Y=Math.floor((H.x+U-1)/W)+Z,X=Math.floor((H.y+G-1)/q)+Z;for(let _=V;_<=X;_++)for(let p=j;p<=Y;p++)z.add("".concat(A,"/").concat(_,"/").concat(p))}P.forEach(((p,y)=>{if(!z.has(y)){const p=P.get(y);(null==p||p.isResolved||p.isRejected)&&P.delete(y)}})),k.extent={xmin:w.xmin,ymin:w.ymin,xmax:w.xmax,ymax:w.ymax}}}}]);
//# sourceMappingURL=3293.b9449af8.chunk.js.map