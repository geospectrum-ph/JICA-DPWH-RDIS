"use strict";(self.webpackChunkSEEDs_v2_0_Client=self.webpackChunkSEEDs_v2_0_Client||[]).push([[2214],{56103:(s,l,p)=>{p.d(l,{d:()=>$});var E=p(16842),v=p(4180),F=p(83375),S=p(66004),A=p(35598),R=p(97745),O=p(81618),M=p(49049),D=p(54208),k=p(21374),L=p(88965),V=p(12439),Q=p(31670),U=p(30172),z=p(78395),B=p(32050),Y=p(20585),H=p(92541);var J=p(68471);const W=new class r{constructor(s,l){this._cache=new Y.q(s),this._invalidCache=new Y.q(l)}get(s,l){const p="".concat(l.uid,":").concat(s),E=this._cache.get(p);if(E)return E;if(null!=this._invalidCache.get(p))return null;try{const E=H.WhereClause.create(s,l);return this._cache.put(p,E),E}catch(K){return this._invalidCache.put(p,K),null}}getError(s,l){var p;const E="".concat(l.uid,":").concat(s);return null!==(p=this._invalidCache.get(E))&&void 0!==p?p:null}}(50,500),X="unsupported-query",K=" as ",ee=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),te=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),ie=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...ee,...te]);function d(s,l){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const E=attributeSupport_c(l,s);if(!E){const p=W.getError(l,s);throw new v.A(X,"invalid SQL expression",{expression:l,error:p})}const F=p.expressionName||"expression";if(p.validateStandardized&&!E.isStandardized)throw new v.A(X,"".concat(F," is not standard"),{expression:l});if(p.validateAggregate&&!E.isAggregate)throw new v.A(X,"".concat(F," does not contain a valid aggregate function"),{expression:l});return E.fieldNames}function f(s,l,p,E,F){if(!p)return!0;const S="having clause",A=d(s,p,{validateAggregate:!0,expressionName:S});g(s,l,A,{expressionName:S,query:F});const R=attributeSupport_c(p,s),O=null===R||void 0===R?void 0:R.getExpressions().every((l=>{var p;const{aggregateType:v,field:F}=l,S=null===(p=s.get(F))||void 0===p?void 0:p.name;return E.some((l=>{var p;const{onStatisticField:E,statisticType:F}=l;return(null===(p=s.get(E))||void 0===p?void 0:p.name)===S&&F.toLowerCase().trim()===v}))}));if(!O)throw new v.A(X,"expressions in having clause should also exist in outStatistics",{having:p});return!0}function attributeSupport_c(s,l){return s?W.get(s,l):null}function attributeSupport_u(s){return/\((.*?)\)/.test(s)?s:s.split(K)[0]}function y(s){return s.split(K)[1]}function g(s,l,p){var E;let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const S=new Map;if(function m(s,l,p,E,v){const F=v.includes("*")?[...p,...v.filter((s=>"*"!==s))]:v;for(const A of F)if(l.get(A))T(s,l,p,E,A);else try{const v=d(l,attributeSupport_u(A),{validateStandardized:!0});for(const F of v)T(s,l,p,E,F)}catch(S){s.set(A,{type:"expression-error",expression:A,error:S})}}(S,s,l,null!==(E=F.allowedFieldTypes)&&void 0!==E?E:ie,p),S.size){var A;const s=null!==(A=F.expressionName)&&void 0!==A?A:"expression";throw new v.A(X,"".concat(s," contains invalid or missing fields"),{errors:Array.from(S.values()),query:F.query})}}function T(s,l,p,E,v){const F=l.get(v);F?p.has(F.name)?"all"!==E&&!1===(null===E||void 0===E?void 0:E.has(F.type))&&s.set(v,{type:"invalid-type",fieldName:F.name,fieldType:J.m.fromJSON(F.type),allowedFieldTypes:Array.from(E,(s=>J.m.fromJSON(s)))}):s.set(v,{type:"missing-field",fieldName:F.name}):s.set(v,{type:"invalid-field",fieldName:v})}var se=p(23047),re=p(22786),ae=p(24450),ne=p(61077),le=p(25076),oe=p(89343),ue=p(57022),ce=p(2967),he=p(86523),de=p(39368);class AttributesBuilder_c{constructor(s,l,p){var E;this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=null!==(E=s.returnDistinctValues)&&void 0!==E&&E,this.fieldsIndex=p,this.featureAdapter=l;const v=s.outFields;if(v&&!v.includes("*")){this.outFields=v;let s=0;for(const l of v){const E=attributeSupport_u(l),v=this.fieldsIndex.get(E),F=v?null:attributeSupport_c(E,p),S=v?v.name:y(l)||"FIELD_EXP_"+s++;this._fieldDataCache.set(l,{alias:S,clause:F})}}}countDistinctValues(s){return this.returnDistinctValues?(s.forEach((s=>this.getAttributes(s))),this._returnDistinctMap.size):s.length}getAttributes(s){const l=this._processAttributesForOutFields(s);return this._processAttributesForDistinctValues(l)}getFieldValue(s,l,p){var E,v;const F=p?p.name:l;let S=null;return this._fieldDataCache.has(F)?S=null===(E=this._fieldDataCache.get(F))||void 0===E?void 0:E.clause:p||(S=attributeSupport_c(l,this.fieldsIndex),this._fieldDataCache.set(F,{alias:F,clause:S})),p?this.featureAdapter.getAttribute(s,F):null===(v=S)||void 0===v?void 0:v.calculateValue(s,this.featureAdapter)}getDataValues(s,l){let p=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const E=l.normalizationType,v=l.normalizationTotal,F=this.fieldsIndex.get(l.field),S=(0,ue.zD)(F)||(0,ue.Ah)(F),A=(0,ue.OH)(F);return s.map((s=>{let F=l.field&&this.getFieldValue(s,l.field,this.fieldsIndex.get(l.field));if(l.field2?(F="".concat((0,he.gJ)(F)).concat(l.fieldDelimiter).concat((0,he.gJ)(this.getFieldValue(s,l.field2,this.fieldsIndex.get(l.field2)))),l.field3&&(F="".concat(F).concat(l.fieldDelimiter).concat((0,he.gJ)(this.getFieldValue(s,l.field3,this.fieldsIndex.get(l.field3)))))):"string"==typeof F&&p&&(S?F=F?new Date(F).getTime():null:A&&(F=F?(0,ce.rb)(F):null)),E&&Number.isFinite(F)){const p="field"===E&&l.normalizationField?this.getFieldValue(s,l.normalizationField,this.fieldsIndex.get(l.normalizationField)):null;F=(0,he.zS)(F,E,p,v)}return F}))}async getExpressionValues(s,l,p,E,v){const{arcadeUtils:F}=await(0,de.lw)(),S=F.hasGeometryOperations(l);S&&await F.enableGeometryOperations();const A=F.createFunction(l),R=F.getViewInfo(p),O={fields:this.fieldsIndex.fields};return s.map((s=>{const l={attributes:this.featureAdapter.getAttributes(s),layer:O,geometry:S?{...(0,se.pL)(E.geometryType,E.hasZ,E.hasM,this.featureAdapter.getGeometry(s)),spatialReference:null===p||void 0===p?void 0:p.spatialReference}:null},M=F.createExecContext(l,R,v);return F.executeFunction(A,M)}))}validateItem(s,l){var p,E;return this._fieldDataCache.has(l)||this._fieldDataCache.set(l,{alias:l,clause:attributeSupport_c(l,this.fieldsIndex)}),null!==(p=null===(E=this._fieldDataCache.get(l))||void 0===E||null===(E=E.clause)||void 0===E?void 0:E.testFeature(s,this.featureAdapter))&&void 0!==p&&p}validateItems(s,l){var p,E;return this._fieldDataCache.has(l)||this._fieldDataCache.set(l,{alias:l,clause:attributeSupport_c(l,this.fieldsIndex)}),null!==(p=null===(E=this._fieldDataCache.get(l))||void 0===E||null===(E=E.clause)||void 0===E?void 0:E.testSet(s,this.featureAdapter))&&void 0!==p&&p}_processAttributesForOutFields(s){const l=this.outFields;if(null===l||void 0===l||!l.length)return this.featureAdapter.getAttributes(s);const p={};for(const E of l){const{alias:l,clause:v}=this._fieldDataCache.get(E);p[l]=v?v.calculateValue(s,this.featureAdapter):this.featureAdapter.getAttribute(s,l)}return p}_processAttributesForDistinctValues(s){if(null==s||!this.returnDistinctValues)return s;const l=this.outFields,p=[];if(l)for(const F of l){const{alias:l}=this._fieldDataCache.get(F);p.push(s[l])}else for(const F in s)p.push(s[F]);const E="".concat((l||["*"]).join(","),"=").concat(p.join(","));let v=this._returnDistinctMap.get(E)||0;return this._returnDistinctMap.set(E,++v),v>1?null:s}}var me=p(32051);class q{constructor(s,l,p){this.items=s,this.query=l,this.geometryType=p.geometryType,this.hasM=p.hasM,this.hasZ=p.hasZ,this.fieldsIndex=p.fieldsIndex,this.objectIdField=p.objectIdField,this.spatialReference=p.spatialReference,this.featureAdapter=p.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const s=new AttributesBuilder_c(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return s.countDistinctValues(this.items);const{groupByFieldsForStatistics:l,having:p,outStatistics:E}=this.query;if(!(null===l||void 0===l?void 0:l.length))return 1;const v=new Map,F=new Map,S=new Set;for(const A of E){const{statisticType:E}=A,R="exceedslimit"!==E?A.onStatisticField:void 0;if(!F.has(R)){const p=[];for(const E of l){const l=this._getAttributeValues(s,E,v);p.push(l)}F.set(R,this._calculateUniqueValues(p,s.returnDistinctValues))}const O=F.get(R);for(const l in O){const{data:E,items:v}=O[l],F=E.join(",");p&&!s.validateItems(v,p)||S.add(F)}}return S.size}async createQueryResponse(){let s;if(s=this.query.outStatistics?this.query.outStatistics.some((s=>"exceedslimit"===s.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const l=this.query.geometry;(0,z.fn)(this.query.outSR)&&!(0,z.aI)(l.spatialReference,this.query.outSR)?s.queryGeometry=(0,se.ag)({spatialReference:this.query.outSR,...(0,re.Cv)(l,l.spatialReference,this.query.outSR)}):s.queryGeometry=(0,se.ag)({spatialReference:this.query.outSR,...l})}return s}createSnappingResponse(s,l){const p=this.featureAdapter,E=C(this.hasZ,this.hasM),{point:v,mode:F}=s,S="number"==typeof s.distance?s.distance:s.distance.x,A="number"==typeof s.distance?s.distance:s.distance.y,R={candidates:[]},O="esriGeometryPolygon"===this.geometryType,M=this._getPointCreator(F,this.spatialReference,l),D=new G(null,0),k=new G(null,0),L={x:0,y:0,z:0};for(const V of this.items){const l=p.getGeometry(V);if(null==l)continue;const{coords:F,lengths:Q}=l;if(D.coords=F,k.coords=F,s.returnEdge){let s=0;for(let l=0;l<Q.length;l++){const F=Q[l];for(let l=0;l<F;l++,s+=E){const O=D;if(O.coordsIndex=s,l!==F-1){const l=k;l.coordsIndex=s+E;const F=L;N(L,v,O,l);const D=(v.x-F.x)/S,Q=(v.y-F.y)/A,U=D*D+Q*Q;U<=1&&R.candidates.push((0,me.P)(p.getObjectId(V),M(F),Math.sqrt(U),M(O),M(l)))}}}}if("none"!==s.vertexMode){const l=O?F.length-E:F.length;if("all"===s.vertexMode)for(let s=0;s<l;s+=E){const l=D;l.coordsIndex=s;const E=(v.x-l.x)/S,F=(v.y-l.y)/A,O=E*E+F*F;O<=1&&R.candidates.push((0,me.k)(p.getObjectId(V),M(l),Math.sqrt(O)))}else if("ends"===s.vertexMode){const s=[0];O||s.push(F.length-E);for(const l of s){const s=D;s.coordsIndex=l;const E=(v.x-s.x)/S,F=(v.y-s.y)/A,O=E*E+F*F;O<=1&&R.candidates.push((0,me.k)(p.getObjectId(V),M(s),Math.sqrt(O)))}}}}return R.candidates.sort(((s,l)=>s.distance-l.distance)),R}_getPointCreator(s,l,p){const E=null==p||(0,z.aI)(l,p)?s=>s:s=>(0,re.Cv)(s,l,p),{hasZ:v}=this;return"3d"===s?v?s=>{let{x:l,y:p,z:v}=s;return E({x:l,y:p,z:v})}:s=>{let{x:l,y:p}=s;return E({x:l,y:p,z:0})}:s=>{let{x:l,y:p}=s;return E({x:l,y:p})}}async createSummaryStatisticsResponse(s){const{field:l,valueExpression:p,normalizationField:E,normalizationType:v,normalizationTotal:F,minValue:S,maxValue:A,scale:R,timeZone:O}=s,M=this.fieldsIndex.get(l),D=(0,ue.vE)(M)||(0,ue.zD)(M)||(0,ue.Ah)(M),k=await this._getDataValues({field:l,valueExpression:p,normalizationField:E,normalizationType:v,normalizationTotal:F,scale:R,timeZone:O}),L=(0,he.Vb)({normalizationType:v,normalizationField:E,minValue:S,maxValue:A}),V={value:.5,fieldType:null===M||void 0===M?void 0:M.type},Q=(0,ue.yM)(M)?(0,he.z9)({values:k,supportsNullCount:L,percentileParams:V}):(0,he.G_)({values:k,minValue:S,maxValue:A,useSampleStdDev:!v,supportsNullCount:L,percentileParams:V});return(0,he.oZ)(Q,D)}async createUniqueValuesResponse(s){const{field:l,valueExpression:p,domains:E,returnAllCodedValues:v,scale:F,timeZone:S}=s,A=await this._getDataValues({field:l,field2:s.field2,field3:s.field3,fieldDelimiter:s.fieldDelimiter,valueExpression:p,scale:F,timeZone:S},!1),R=(0,he.b3)(A);return(0,he.lv)(R,E,v,s.fieldDelimiter)}async createClassBreaksResponse(s){const{field:l,valueExpression:p,normalizationField:E,normalizationType:v,normalizationTotal:F,classificationMethod:S,standardDeviationInterval:A,minValue:R,maxValue:O,numClasses:M,scale:D,timeZone:k}=s,L=await this._getDataValues({field:l,valueExpression:p,normalizationField:E,normalizationType:v,normalizationTotal:F,scale:D,timeZone:k}),V=(0,he.Rw)(L,{field:l,normalizationField:E,normalizationType:v,normalizationTotal:F,classificationMethod:S,standardDeviationInterval:A,minValue:R,maxValue:O,numClasses:M});return(0,he.jM)(V,S)}async createHistogramResponse(s){const{field:l,valueExpression:p,normalizationField:E,normalizationType:v,normalizationTotal:F,classificationMethod:S,standardDeviationInterval:A,minValue:R,maxValue:O,numBins:M,scale:D,timeZone:k}=s,L=await this._getDataValues({field:l,valueExpression:p,normalizationField:E,normalizationType:v,normalizationTotal:F,scale:D,timeZone:k});return(0,he.$y)(L,{field:l,normalizationField:E,normalizationType:v,normalizationTotal:F,classificationMethod:S,standardDeviationInterval:A,minValue:R,maxValue:O,numBins:M})}_sortFeatures(s,l,p){if(s.length>1&&null!==l&&void 0!==l&&l.length)for(const E of l.reverse()){const l=E.split(" "),v=l[0],F=this.fieldsIndex.get(v),S=!!l[1]&&"desc"===l[1].toLowerCase(),A=(0,he.FM)(null===F||void 0===F?void 0:F.type,S);s.sort(((s,l)=>{const E=p(s,v,F),S=p(l,v,F);return A(E,S)}))}}_createFeatureQueryResponse(s){const l=this.items,{geometryType:p,hasM:E,hasZ:v,objectIdField:F,spatialReference:S}=this,{outFields:A,outSR:R,quantizationParameters:O,resultRecordCount:M,resultOffset:D,returnZ:k,returnM:L}=s,V=null!=M&&l.length>(D||0)+M,Q=A&&(A.includes("*")?[...this.fieldsIndex.fields]:A.map((s=>this.fieldsIndex.get(s))));return{exceededTransferLimit:V,features:this._createFeatures(s,l),fields:Q,geometryType:p,hasM:E&&L,hasZ:v&&k,objectIdFieldName:F,spatialReference:(0,se.ag)(R||S),transform:O&&(0,oe.VV)(O)||null}}_createFeatures(s,l){const p=new AttributesBuilder_c(s,this.featureAdapter,this.fieldsIndex),{hasM:E,hasZ:v}=this,{orderByFields:F,quantizationParameters:S,returnGeometry:A,returnCentroid:R,maxAllowableOffset:O,resultOffset:M,resultRecordCount:D,returnZ:k=!1,returnM:L=!1}=s,V=v&&k,Q=E&&L;let U=[],z=0;const B=[...l];if(this._sortFeatures(B,F,((s,l,E)=>p.getFieldValue(s,l,E))),this.geometryType&&(A||R)){var Y;const s=null!==(Y=(0,oe.VV)(S))&&void 0!==Y?Y:void 0,l="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(A&&!R)for(const E of B){const v=this.featureAdapter.getGeometry(E),F={attributes:p.getAttributes(E),geometry:(0,se.pL)(this.geometryType,this.hasZ,this.hasM,v,O,s,V,Q)};l&&v&&!F.geometry&&(F.centroid=(0,se.LQ)(this,this.featureAdapter.getCentroid(E,this),s)),U[z++]=F}else if(!A&&R)for(const E of B)U[z++]={attributes:p.getAttributes(E),centroid:(0,se.LQ)(this,this.featureAdapter.getCentroid(E,this),s)};else for(const E of B)U[z++]={attributes:p.getAttributes(E),centroid:(0,se.LQ)(this,this.featureAdapter.getCentroid(E,this),s),geometry:(0,se.pL)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(E),O,s,V,Q)}}else for(const J of B){const s=p.getAttributes(J);s&&(U[z++]={attributes:s})}const H=M||0;if(null!=D){const s=H+D;U=U.slice(H,Math.min(U.length,s))}return U}_createExceedsLimitQueryResponse(s){let l=!1,p=Number.POSITIVE_INFINITY,E=Number.POSITIVE_INFINITY,v=Number.POSITIVE_INFINITY;for(const S of null!==(F=s.outStatistics)&&void 0!==F?F:[]){var F;if("exceedslimit"===S.statisticType){p=null!=S.maxPointCount?S.maxPointCount:Number.POSITIVE_INFINITY,E=null!=S.maxRecordCount?S.maxRecordCount:Number.POSITIVE_INFINITY,v=null!=S.maxVertexCount?S.maxVertexCount:Number.POSITIVE_INFINITY;break}}if("esriGeometryPoint"===this.geometryType)l=this.items.length>p;else if(this.items.length>E)l=!0;else{const s=C(this.hasZ,this.hasM),p=this.featureAdapter;l=this.items.reduce(((s,l)=>{const E=p.getGeometry(l);return s+(null!=E&&E.coords.length||0)}),0)/s>v}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(l)}}]}}async _createStatisticsQueryResponse(s){const l={attributes:{}},p=[],E=new Map,v=new Map,F=new Map,S=new Map,A=new AttributesBuilder_c(s,this.featureAdapter,this.fieldsIndex),R=s.outStatistics,{groupByFieldsForStatistics:O,having:M,orderByFields:D,resultRecordCount:k}=s,L=null===O||void 0===O?void 0:O.length,V=!!L,Q=V?O[0]:null,U=V&&!this.fieldsIndex.get(Q);for(const Y of null!==R&&void 0!==R?R:[]){var z;const{outStatisticFieldName:s,statisticType:R}=Y,D=Y,k="exceedslimit"!==R?Y.onStatisticField:void 0,B="percentile_disc"===R||"percentile_cont"===R,H="EnvelopeAggregate"===R||"CentroidAggregate"===R||"ConvexHullAggregate"===R,J=V&&1===L&&(k===Q||U)&&"count"===R;if(V){if(!F.has(k)){const s=[];for(const l of O){const p=this._getAttributeValues(A,l,E);s.push(p)}F.set(k,this._calculateUniqueValues(s,!H&&A.returnDistinctValues))}const l=F.get(k);if(!l)continue;const p=Object.keys(l);for(const v of p){const{count:p,data:F,items:R,itemPositions:L}=l[v],V=F.join(",");if(!M||A.validateItems(R,M)){const l=S.get(V)||{attributes:{}};if(H){l.aggregateGeometries||(l.aggregateGeometries={});const{aggregateGeometries:s,outStatisticFieldName:p}=await this._getAggregateGeometry(D,R);l.aggregateGeometries[p]=s}else{let v=null;if(J)v=p;else{const s=this._getAttributeValues(A,k,E),l=L.map((l=>s[l]));v=B&&"statisticParameters"in D?this._getPercentileValue(D,l):this._getStatisticValue(D,l,null,A.returnDistinctValues)}l.attributes[s]=v}let v=0;O.forEach(((s,p)=>l.attributes[this.fieldsIndex.get(s)?s:"EXPR_"+ ++v]=F[p])),S.set(V,l)}}}else if(H){l.aggregateGeometries||(l.aggregateGeometries={});const{aggregateGeometries:s,outStatisticFieldName:p}=await this._getAggregateGeometry(D,this.items);l.aggregateGeometries[p]=s}else{const p=this._getAttributeValues(A,k,E);l.attributes[s]=B&&"statisticParameters"in D?this._getPercentileValue(D,p):this._getStatisticValue(D,p,v,A.returnDistinctValues)}const W="min"!==R&&"max"!==R||!(0,ue.yM)(this.fieldsIndex.get(k))&&!this._isAnyDateField(k)?null:null===(z=this.fieldsIndex.get(k))||void 0===z?void 0:z.type;p.push({name:s,alias:s,type:W||"esriFieldTypeDouble"})}const B=V?Array.from(S.values()):[l];return this._sortFeatures(B,D,((s,l)=>s.attributes[l])),k&&(B.length=Math.min(k,B.length)),{fields:p,features:B}}_isAnyDateField(s){const l=this.fieldsIndex.get(s);return(0,ue.vE)(l)||(0,ue.zD)(l)||(0,ue.Ah)(l)||(0,ue.OH)(l)}async _getAggregateGeometry(s,l){const{convexHull:E,union:v}=await Promise.all([p.e(8300),p.e(6282)]).then(p.bind(p,93901)),{statisticType:F,outStatisticFieldName:S}=s,{featureAdapter:A,spatialReference:R,geometryType:O,hasZ:M,hasM:D}=this,k=l.map((s=>(0,se.pL)(O,M,D,A.getGeometry(s)))),L=E(R,k,!0)[0],V={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===F){const s=L?(0,le.v)(L):(0,le.HA)(v(R,k));V.aggregateGeometries={...s,spatialReference:R},V.outStatisticFieldName=S||"extent"}else if("CentroidAggregate"===F){const s=L?(0,ne.l8)(L):(0,ne.Z4)((0,le.HA)(v(R,k)));V.aggregateGeometries={x:s[0],y:s[1],spatialReference:R},V.outStatisticFieldName=S||"centroid"}else"ConvexHullAggregate"===F&&(V.aggregateGeometries=L,V.outStatisticFieldName=S||"convexHull");return V}_getStatisticValue(s,l,p,E){const{onStatisticField:v,statisticType:F}=s;let S=null;return S=null!==p&&void 0!==p&&p.has(v)?p.get(v):(0,ue.yM)(this.fieldsIndex.get(v))||this._isAnyDateField(v)?(0,he.z9)({values:l,returnDistinct:E}):(0,he.G_)({values:E?[...new Set(l)]:l,minValue:null,maxValue:null,useSampleStdDev:!0}),p&&p.set(v,S),S["var"===F?"variance":F]}_getPercentileValue(s,l){const{onStatisticField:p,statisticParameters:E,statisticType:v}=s,{value:F,orderBy:S}=E,A=this.fieldsIndex.get(p);return(0,he.qg)(l,{value:F,orderBy:S,fieldType:null===A||void 0===A?void 0:A.type,isDiscrete:"percentile_disc"===v})}_getAttributeValues(s,l,p){if(p.has(l))return p.get(l);const E=this.fieldsIndex.get(l),v=this.items.map((p=>s.getFieldValue(p,l,E)));return p.set(l,v),v}_calculateUniqueValues(s,l){const p={},E=this.items,v=E.length;for(let F=0;F<v;F++){const v=E[F],S=[];for(const l of s)S.push(l[F]);const A=S.join(",");null==p[A]?p[A]={count:1,data:S,items:[v],itemPositions:[F]}:(l||p[A].count++,p[A].items.push(v),p[A].itemPositions.push(F))}return p}async _getDataValues(s){let l=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const p=new AttributesBuilder_c(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:E,scale:v,timeZone:F}=s;return E?p.getExpressionValues(this.items,E,{viewingMode:"map",scale:v,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},F):p.getDataValues(this.items,(0,S.o8)(s),l)}}function N(s,l,p,E){const v=E.x-p.x,F=E.y-p.y,S=v*v+F*F,A=(l.x-p.x)*v+(l.y-p.y)*F,R=Math.min(1,Math.max(0,A/S));s.x=p.x+v*R,s.y=p.y+F*R}function C(s,l){return s?l?4:3:l?3:2}class G{constructor(s,l){this.coords=s,this.coordsIndex=l}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}var fe=p(70857),ge=p(70564);const _e="unsupported-query";async function queryValidationUtils_p(s,l){var p;let{fieldsIndex:E,geometryType:F,spatialReference:S,availableFields:A}=l;if((null!==(p=s.distance)&&void 0!==p?p:0)<0||null!=s.geometryPrecision||s.multipatchOption&&"xyFootprint"!==s.multipatchOption||s.pixelSize||s.relationParam||s.text)throw new v.A(_e,"Unsupported query options",{query:s});return c(E,A,s),function queryValidationUtils_f(s,l,p){const{outStatistics:E,groupByFieldsForStatistics:F,having:S}=p,A=null===F||void 0===F?void 0:F.length,R=null===E||void 0===E?void 0:E.length;if(S){if(!A||!R)throw new v.A(_e,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:p});f(s,l,S,E,p)}if(R){if(!function h(s){return null!=s&&s.every((s=>"exceedslimit"!==s.statisticType))}(E))return;g(s,l,E.map((s=>s.onStatisticField)).filter(Boolean),{expressionName:"onStatisticFields",query:p}),A&&g(s,l,F,{expressionName:"groupByFieldsForStatistics",query:p});for(const F of E){const{onStatisticField:E,statisticType:S}=F;if("percentile_disc"!==S&&"percentile_cont"!==S||!("statisticParameters"in F))s.get(E)&&"count"!==S&&"min"!==S&&"max"!==S&&g(s,l,[E],{expressionName:"outStatistics with '".concat(S,"' statistic type"),allowedFieldTypes:pe,query:p});else{const{statisticParameters:s}=F;if(!s)throw new v.A(_e,"statisticParameters should be set for percentile type",{definition:F,query:p})}}}}(E,A,s),Promise.all([(0,ge.c0)(s,F,S),(0,re.Nk)(S,s.outSR)]).then((()=>s))}function c(s,l,p){const{outFields:E,orderByFields:F,returnDistinctValues:S,outStatistics:A}=p,R=A?A.map((s=>s.outStatisticFieldName&&s.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(F&&F.length>0){const E=" asc",v=" desc",S=F.map((s=>{const l=s.toLowerCase();return l.includes(E)?l.split(E)[0]:l.includes(v)?l.split(v)[0]:s})).filter((s=>!R.includes(s)));g(s,l,S,{expressionName:"orderByFields",query:p})}if(E&&E.length>0)g(s,l,E,{expressionName:"outFields",query:p,allowedFieldTypes:"all"});else if(S)throw new v.A(_e,"outFields should be specified for returnDistinctValues",{query:p});!function attributeSupport_p(s,l,p,E){if(!p)return!0;const v="where clause";return g(s,l,d(s,p,{validateStandardized:!0,expressionName:v}),{expressionName:v,query:E}),!0}(s,l,p.where,p)}const pe=new Set([...ee,...te]);async function queryValidationUtils_y(s,l,p,E){let F=[];if(p.valueExpression){const{arcadeUtils:s}=await(0,de.lw)();F=s.extractFieldNames(p.valueExpression)}if(p.field&&F.push(p.field),p.field2&&F.push(p.field2),p.field3&&F.push(p.field3),p.normalizationField&&F.push(p.normalizationField),!F.length&&!p.valueExpression)throw new v.A(_e,"field or valueExpression is required",{params:p});g(s,l,F,{expressionName:"statistics",query:E})}var ye=p(66174),Ie=p(8084),Te=p(53727);const Ee=new R.F(2e6);let xe=0;class ${constructor(s){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:ae.F},this.geometryType=s.geometryType,this.hasM=!!s.hasM,this.hasZ=!!s.hasZ,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.definitionExpression=s.definitionExpression,this.featureStore=s.featureStore,this.aggregateAdapter=s.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=s.timeInfo,s.cacheSpatialQueries&&(this._geometryQueryCache=new R.Mn(xe+++"$$",Ee)),this.fieldsIndex=(0,F.Wj)(s.fieldsIndex)?s.fieldsIndex:Ie.A.fromJSON(s.fieldsIndex),!s.availableFields||1===s.availableFields.length&&"*"===s.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map((s=>s.name))):this.availableFields=new Set(s.availableFields.map((s=>{var l;return null===(l=this.fieldsIndex.get(s))||void 0===l?void 0:l.name})).filter((s=>null!=s))),s.scheduler&&s.priority&&(this._frameTask=s.scheduler.registerTask(s.priority))}destroy(){this._frameTask=(0,A.xt)(this._frameTask),this.clearCache(),(0,A.pR)(this._geometryQueryCache),this._changeHandle=(0,A.xt)(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){var s;null!==(s=this._geometryQueryCache)&&void 0!==s&&s.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(s,l){const p=(0,O.Mq)(l);try{return(await this._executeQuery(s,{},p)).createQueryResponse()}catch(W){if(W!==fe.v8)throw W;return new q([],s,this).createQueryResponse()}}async executeQueryForCount(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=arguments.length>1?arguments[1]:void 0;const p=(0,O.Mq)(l);try{return(await this._executeQuery(s,{returnGeometry:!1,returnCentroid:!1,outSR:null},p)).createQueryResponseForCount()}catch(W){if(W!==fe.v8)throw W;return 0}}async executeQueryForExtent(s,l){const p=(0,O.Mq)(l),E=s.outSR;try{const l=await this._executeQuery(s,{returnGeometry:!0,returnCentroid:!1,outSR:null},p),v=l.size;return v?{count:v,extent:await this._getBounds(l.items,l.spatialReference,E||this.spatialReference)}:{count:0,extent:null}}catch(r){if(r===fe.v8)return{count:0,extent:null};throw r}}async executeQueryForIds(s,l){return this.executeQueryForIdSet(s,l).then((s=>Array.from(s)))}async executeQueryForIdSet(s,l){const p=(0,O.Mq)(l);try{const l=await this._executeQuery(s,{returnGeometry:!0,returnCentroid:!1,outSR:null},p),E=l.items,v=new Set;return await this._reschedule((()=>{for(const s of E)v.add(l.featureAdapter.getObjectId(s))}),p),v}catch(W){if(W===fe.v8)return new Set;throw W}}async executeQueryForSnapping(s,l){const p=(0,O.Mq)(l),{point:E,distance:v,returnEdge:F,vertexMode:A}=s;if(!F&&"none"===A)return{candidates:[]};let R=(0,S.o8)(s.query);R=await this._schedule((()=>(0,fe.T2)(R,this.definitionExpression,this.spatialReference)),p),R=await this._reschedule((()=>queryValidationUtils_p(R,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),p);const M=!(0,z.aI)(E.spatialReference,this.spatialReference);M&&await(0,re.Nk)(E.spatialReference,this.spatialReference);const D="number"==typeof v?v:v.x,k="number"==typeof v?v:v.y,L={xmin:E.x-D,xmax:E.x+D,ymin:E.y-k,ymax:E.y+k,spatialReference:E.spatialReference},V=M?(0,re.Cv)(L,this.spatialReference):L;if(!V)return{candidates:[]};const B=(await(0,U.el)((0,Q.rS)(E),null,{signal:p}))[0],Y=(await(0,U.el)((0,Q.rS)(V),null,{signal:p}))[0];if(null==B||null==Y)return{candidates:[]};const H=new q(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(Y.toJSON()))),p),R,this);await this._reschedule((()=>this._executeObjectIdsQuery(H)),p),await this._reschedule((()=>this._executeTimeQuery(H)),p),await this._reschedule((()=>this._executeAttributesQuery(H)),p),await this._reschedule((()=>this._executeGeometryQueryForSnapping(H,p)),p);const J=B.toJSON(),W=M?(0,re.Cv)(J,this.spatialReference):J,X=M?Math.max(V.xmax-V.xmin,V.ymax-V.ymin)/2:v;return H.createSnappingResponse({...s,point:W,distance:X},E.spatialReference)}async executeQueryForLatestObservations(s,l){var p;const E=(0,O.Mq)(l);if(null===(p=this.timeInfo)||void 0===p||!p.trackIdField)throw new v.A("unsupported-query","Missing timeInfo or timeInfo.trackIdField",{query:s,timeInfo:this.timeInfo});try{const l=await this._executeQuery(s,{},E);return await this._reschedule((()=>this._filterLatest(l)),E),l.createQueryResponse()}catch(r){if(r!==fe.v8)throw r;return new q([],s,this).createQueryResponse()}}async executeQueryForSummaryStatistics(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=arguments.length>1?arguments[1]:void 0,p=arguments.length>2?arguments[2]:void 0;const E=(0,O.Mq)(p),{field:v,normalizationField:F,valueExpression:S}=l;return(await this._executeQueryForStatistics(s,{field:v,normalizationField:F,valueExpression:S},E)).createSummaryStatisticsResponse(l)}async executeQueryForUniqueValues(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=arguments.length>1?arguments[1]:void 0,p=arguments.length>2?arguments[2]:void 0;const E=(0,O.Mq)(p),{field:v,field2:F,field3:S,valueExpression:A}=l;return(await this._executeQueryForStatistics(s,{field:v,field2:F,field3:S,valueExpression:A},E)).createUniqueValuesResponse(l)}async executeQueryForClassBreaks(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=arguments.length>1?arguments[1]:void 0,p=arguments.length>2?arguments[2]:void 0;const E=(0,O.Mq)(p),{field:v,normalizationField:F,valueExpression:S}=l;return(await this._executeQueryForStatistics(s,{field:v,normalizationField:F,valueExpression:S},E)).createClassBreaksResponse(l)}async executeQueryForHistogram(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=arguments.length>1?arguments[1]:void 0,p=arguments.length>2?arguments[2]:void 0;const E=(0,O.Mq)(p),{field:v,normalizationField:F,valueExpression:S}=l;return(await this._executeQueryForStatistics(s,{field:v,normalizationField:F,valueExpression:S},E)).createHistogramResponse(l)}async fetchRecomputedExtents(s){const l=(0,O.Mq)(s);this._timeExtentPromise||(this._timeExtentPromise=(0,ye.W)(this.timeInfo,this.featureStore));const[p,E]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return(0,O.Te)(l),{fullExtent:p,timeExtent:E}}async _getBounds(s,l,p){const E=(0,k.hZ)((0,k.vt)(),k.qv);await this.featureStore.forEachBounds(s,(s=>(0,k.RF)(E,s)));const v={xmin:E[0],ymin:E[1],xmax:E[3],ymax:E[4],spatialReference:(0,se.ag)(this.spatialReference)};this.hasZ&&isFinite(E[2])&&isFinite(E[5])&&(v.zmin=E[2],v.zmax=E[5]);const F=(0,re.Cv)(v,l,p);if(F.spatialReference=(0,se.ag)(p),F.xmax-F.xmin==0){const s=(0,M.GA)(F.spatialReference);F.xmin-=s,F.xmax+=s}if(F.ymax-F.ymin==0){const s=(0,M.GA)(F.spatialReference);F.ymin-=s,F.ymax+=s}if(this.hasZ&&null!=F.zmin&&null!=F.zmax&&F.zmax-F.zmin==0){const s=(0,M.GA)(F.spatialReference);F.zmin-=s,F.zmax+=s}return F}_getFullExtent(){return this._fullExtentPromise||(this._fullExtentPromise="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((s=>this._getBounds(s,this.spatialReference,this.spatialReference)))),this._fullExtentPromise}async _schedule(s,l){return null!=this._frameTask?this._frameTask.schedule(s,l):s(Te.Bb)}async _reschedule(s,l){return null!=this._frameTask?this._frameTask.reschedule(s,l):s(Te.Bb)}async _getAllFeaturesQueryEngineResult(s){return new q(await this._getAllFeatures(),s,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const s=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((l=>s.push(l)))})().then((()=>s))}const s=this._allFeaturesPromise,l=await s;return s===this._allFeaturesPromise?l.slice():this._getAllFeatures()}async _executeQuery(s,l,p){s=(0,S.o8)(s),s=await this._schedule((()=>(0,fe.GC)(s,this.definitionExpression,this.spatialReference)),p),s=await this._reschedule((()=>queryValidationUtils_p(s,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),p),s={...s,...l};const E=await this._reschedule((()=>this._executeSceneFilterQuery(s,p)),p),v=await this._reschedule((()=>this._executeGeometryQuery(s,E,p)),p);return await this._reschedule((()=>this._executeAggregateIdsQuery(v)),p),await this._reschedule((()=>this._executeObjectIdsQuery(v)),p),await this._reschedule((()=>this._executeTimeQuery(v)),p),await this._reschedule((()=>this._executeAttributesQuery(v)),p),v}async _executeSceneFilterQuery(s,l){if(null==s.sceneFilter)return null;const{outSR:p,returnGeometry:E,returnCentroid:v}=s,F=this.featureStore.featureSpatialReference,S=s.sceneFilter.geometry,A=null==F||(0,z.aI)(F,S.spatialReference)?S:(0,re.Cv)(S,F);if(!A)return null;const R=E||v,O=(0,z.fn)(p)&&!(0,z.aI)(this.spatialReference,p)&&R?async s=>this._project(s,p):s=>s,M=this.featureAdapter,D=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(A))),l);if("disjoint"===s.sceneFilter.spatialRelationship){if(!D.length)return null;const p=new Set;for(const s of D)p.add(M.getObjectId(s));const E=await this._reschedule((()=>this._getAllFeatures()),l),v=await this._reschedule((async()=>{const v=await(0,ge.xt)("esriSpatialRelDisjoint",A,this.geometryType,this.hasZ,this.hasM),F=await this._runSpatialFilter(E,(s=>!p.has(M.getObjectId(s))||v(M.getGeometry(s))),l);return new q(F,s,this)}),l);return O(v)}if(!D.length)return new q([],s,this);if(this._canExecuteSinglePass(A,s))return O(new q(D,s,this));const k=await(0,ge.xt)("esriSpatialRelContains",A,this.geometryType,this.hasZ,this.hasM),L=await this._runSpatialFilter(D,(s=>k(M.getGeometry(s))),l);return O(new q(L,s,this))}async _executeGeometryQuery(s,l,p){if(null!=l&&0===l.items.length)return l;s=null!=l?l.query:s;const{geometry:v,outSR:F,spatialRel:S,returnGeometry:A,returnCentroid:R}=s,O=this.featureStore.featureSpatialReference,M=!v||null==O||(0,z.aI)(O,v.spatialReference)?v:(0,re.Cv)(v,O),D=A||R,k=(0,z.fn)(F)&&!(0,z.aI)(this.spatialReference,F),L=this._geometryQueryCache&&null==l?k&&D?JSON.stringify({originalFilterGeometry:v,spatialRelationship:S,outSpatialReference:F}):JSON.stringify({originalFilterGeometry:v,spatialRelationship:S}):null,V=L?this._geometryQueryCache.get(L):null;if(null!=V)return new q(V,s,this);const d=async s=>(k&&D&&await this._project(s,F),L&&this._geometryQueryCache.put(L,s.items,s.items.length+1),s);if(!M)return d(null!=l?l:await this._getAllFeaturesQueryEngineResult(s));const Q=this.featureAdapter;let U=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(v))),p);if("esriSpatialRelDisjoint"===S){if(!U.length)return d(null!=l?l:await this._getAllFeaturesQueryEngineResult(s));const E=new Set;for(const s of U)E.add(Q.getObjectId(s));const v=null!=l?l.items:await this._reschedule((()=>this._getAllFeatures()),p),F=await this._reschedule((async()=>{const l=await(0,ge.xt)(S,M,this.geometryType,this.hasZ,this.hasM),F=await this._runSpatialFilter(v,(s=>!E.has(Q.getObjectId(s))||l(Q.getGeometry(s))),p);return new q(F,s,this)}),p);return d(F)}if(null!=l){const s=new E.vW;U=U.filter((p=>(0,E.qh)(l.items,p,l.items.length,s)>=0))}if(!U.length){const l=new q([],s,this);return L&&this._geometryQueryCache.put(L,l.items,1),l}if(this._canExecuteSinglePass(M,s))return d(new q(U,s,this));const B=await(0,ge.xt)(S,M,this.geometryType,this.hasZ,this.hasM),Y=await this._runSpatialFilter(U,(s=>B(Q.getGeometry(s))),p);return d(new q(Y,s,this))}async _executeGeometryQueryForSnapping(s,l){var p;const{query:E}=s,{spatialRel:v}=E;if(null===s||void 0===s||null===(p=s.items)||void 0===p||!p.length||!E.geometry||!v)return;const F=await(0,ge.xt)(v,E.geometry,this.geometryType,this.hasZ,this.hasM),S=await this._runSpatialFilter(s.items,(s=>F(s.geometry)),l);s.items=S}_executeAggregateIdsQuery(s){var l;if(0===s.items.length||null===(l=s.query.aggregateIds)||void 0===l||!l.length||null==this.aggregateAdapter)return;const p=new Set;for(const v of s.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(v).forEach((s=>p.add(s)));const E=this.featureAdapter.getObjectId;s.items=s.items.filter((s=>p.has(E(s))))}_executeObjectIdsQuery(s){var l;if(0===s.items.length||null===(l=s.query.objectIds)||void 0===l||!l.length)return;const p=new Set(s.query.objectIds),E=this.featureAdapter.getObjectId;s.items=s.items.filter((s=>p.has(E(s))))}_executeTimeQuery(s){if(0===s.items.length)return;const l=(0,ye.I)(this.timeInfo,s.query.timeExtent,this.featureAdapter);null!=l&&(s.items=s.items.filter(l))}_executeAttributesQuery(s){if(0===s.items.length)return;const l=attributeSupport_c(s.query.where,this.fieldsIndex);if(l){if(!l.isStandardized)throw new TypeError("Where clause is not standardized");s.items=s.items.filter((s=>l.testFeature(s,this.featureAdapter)))}}async _runSpatialFilter(s,l,p){if(!l)return s;if(null==this._frameTask)return s.filter((s=>l(s)));let E=0;const v=new Array,a=async F=>{for(;E<s.length;){const S=s[E++];l(S)&&(v.push(S),F.madeProgress()),F.done&&await this._reschedule((s=>a(s)),p)}};return this._reschedule((s=>a(s)),p).then((()=>v))}_filterLatest(s){const{trackIdField:l,startTimeField:p,endTimeField:E}=this.timeInfo,v=E||p,F=new Map,S=this.featureAdapter.getAttribute;for(const A of s.items){const s=S(A,l),p=S(A,v),E=F.get(s);(!E||p>S(E,v))&&F.set(s,A)}s.items=Array.from(F.values())}_canExecuteSinglePass(s,l){const{spatialRel:p}=l;return(0,ge.tC)(s)&&("esriSpatialRelEnvelopeIntersects"===p||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===p||"esriSpatialRelContains"===p))}async _project(s,l){if(!l||(0,z.aI)(this.spatialReference,l))return s;const p=this.featureAdapter;let E;try{const s=await this._getFullExtent();E=(0,D.getTransformation)(this.spatialReference,l,s)}catch{}const v=await(0,re.lK)(s.items.map((s=>(0,se.pL)(this.geometryType,this.hasZ,this.hasM,p.getGeometry(s)))),this.spatialReference,l,E);return s.items=v.map(((l,E)=>p.cloneWithGeometry(s.items[E],(0,B.Ux)(l,this.hasZ,this.hasM)))),s}_getQueryBBoxes(s){if((0,ge.tC)(s)){if((0,Q.ZC)(s))return[(0,L.fA)(Math.min(s.xmin,s.xmax),Math.min(s.ymin,s.ymax),Math.max(s.xmin,s.xmax),Math.max(s.ymin,s.ymax))];if((0,Q.Bi)(s))return s.rings.map((s=>(0,L.fA)(Math.min(s[0][0],s[2][0]),Math.min(s[0][1],s[2][1]),Math.max(s[0][0],s[2][0]),Math.max(s[0][1],s[2][1]))))}return[(0,V.Rg)((0,L.vt)(),s)]}async _searchFeatures(s){const l=new Set;await Promise.all(s.map((s=>this.featureStore.forEachInBounds(s,(s=>l.add(s))))));const p=Array.from(l.values());return l.clear(),p}async _executeQueryForStatistics(s,l,p){s=(0,S.o8)(s);try{s=await this._schedule((()=>(0,fe.GC)(s,this.definitionExpression,this.spatialReference)),p),s=await this._reschedule((()=>async function queryValidationUtils_m(s,l,p){var E;let{fieldsIndex:F,geometryType:S,spatialReference:A,availableFields:R}=p;if((null!==(E=s.distance)&&void 0!==E?E:0)<0||null!=s.geometryPrecision||s.multipatchOption||s.pixelSize||s.relationParam||s.text||s.outStatistics||s.groupByFieldsForStatistics||s.having||s.orderByFields)throw new v.A(_e,"Unsupported query options",{query:s});return c(F,R,s),Promise.all([queryValidationUtils_y(F,R,l,s),(0,ge.c0)(s,S,A),(0,re.Nk)(A,s.outSR)]).then((()=>s))}(s,l,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),p);const E=await this._reschedule((()=>this._executeSceneFilterQuery(s,p)),p),F=await this._reschedule((()=>this._executeGeometryQuery(s,E,p)),p);return await this._reschedule((()=>this._executeAggregateIdsQuery(F)),p),await this._reschedule((()=>this._executeObjectIdsQuery(F)),p),await this._reschedule((()=>this._executeTimeQuery(F)),p),await this._reschedule((()=>this._executeAttributesQuery(F)),p),F}catch(W){if(W!==fe.v8)throw W;return new q([],s,this)}}}},32051:(s,l,p)=>{function t(s,l,p){return{objectId:s,target:l,distance:p,type:"vertex"}}function e(s,l,p,E,v){return{objectId:s,target:l,distance:p,type:"edge",start:E,end:v,draped:arguments.length>5&&void 0!==arguments[5]&&arguments[5]}}p.d(l,{P:()=>e,k:()=>t})},19464:(s,l,p)=>{function t(s,l){return s?l?4:3:l?3:2}function n(s,l,p,E){if(null===l||void 0===l||!l.lengths.length)return null;s.lengths.length&&(s.lengths.length=0),s.coords.length&&(s.coords.length=0);const v=s.coords,F=[],S=p?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:A,coords:R}=l,O=t(p,E);let M=0;for(const D of A){const s=e(S,R,M,D,p,E);s&&F.push(s),M+=D*O}if(F.sort(((s,l)=>{let E=s[2]-l[2];return 0===E&&p&&(E=s[4]-l[4]),E})),F.length){let s=6*F[0][2];v[0]=F[0][0]/s,v[1]=F[0][1]/s,p&&(s=6*F[0][4],v[2]=0!==s?F[0][3]/s:0),(v[0]<S[0]||v[0]>S[1]||v[1]<S[2]||v[1]>S[3]||p&&(v[2]<S[4]||v[2]>S[5]))&&(v.length=0)}if(!v.length){const s=l.lengths[0]?r(R,0,A[0],p,E):null;if(!s)return null;v[0]=s[0],v[1]=s[1],p&&s.length>2&&(v[2]=s[2])}return s}function e(s,l,p,E,v,F){const S=t(v,F);let A=p,R=p+S,O=0,M=0,D=0,k=0,L=0;for(let Q=0,U=E-1;Q<U;Q++,A+=S,R+=S){const p=l[A],E=l[A+1],F=l[A+2],S=l[R],V=l[R+1],Q=l[R+2];let U=p*V-S*E;k+=U,O+=(p+S)*U,M+=(E+V)*U,v&&(U=p*Q-S*F,D+=(F+Q)*U,L+=U),p<s[0]&&(s[0]=p),p>s[1]&&(s[1]=p),E<s[2]&&(s[2]=E),E>s[3]&&(s[3]=E),v&&(F<s[4]&&(s[4]=F),F>s[5]&&(s[5]=F))}if(k>0&&(k*=-1),L>0&&(L*=-1),!k)return null;const V=[O,M,.5*k];return v&&(V[3]=D,V[4]=.5*L),V}function r(s,l,p,E,v){const F=t(E,v);let S=l,A=l+F,R=0,O=0,M=0,D=0;for(let k=0,L=p-1;k<L;k++,S+=F,A+=F){const l=s[S],p=s[S+1],v=s[S+2],F=s[A],k=s[A+1],L=s[A+2],V=E?u(l,p,v,F,k,L):I(l,p,F,k);if(V)if(R+=V,E){const s=N(l,p,v,F,k,L);O+=V*s[0],M+=V*s[1],D+=V*s[2]}else{const s=o(l,p,F,k);O+=V*s[0],M+=V*s[1]}}return R>0?E?[O/R,M/R,D/R]:[O/R,M/R]:p>0?E?[s[l],s[l+1],s[l+2]]:[s[l],s[l+1]]:null}function I(s,l,p,E){const v=p-s,F=E-l;return Math.sqrt(v*v+F*F)}function u(s,l,p,E,v,F){const S=E-s,A=v-l,R=F-p;return Math.sqrt(S*S+A*A+R*R)}function o(s,l,p,E){return[s+.5*(p-s),l+.5*(E-l)]}function N(s,l,p,E,v,F){return[s+.5*(E-s),l+.5*(v-l),p+.5*(F-p)]}p.d(l,{T:()=>F});var E=p(57224),v=p(41156);const F={getObjectId:s=>s.objectId,getAttributes:s=>s.attributes,getAttribute:(s,l)=>s.attributes[l],cloneWithGeometry:(s,l)=>new E.Om(l,s.attributes,null,s.objectId),getGeometry:s=>s.geometry,getCentroid:(s,l)=>(null==s.centroid&&(s.centroid=n(new v.A,s.geometry,l.hasZ,l.hasM)),s.centroid)}},59159:(s,l,p)=>{p.d(l,{T:()=>i});var E=p(81618),v=p(82428),F=p(16848);class i{constructor(){this._tasks=new Array,this._runningTasks=(0,v.v)(0)}get length(){return this._tasks.length}get running(){return this._runningTasks.value>0}destroy(){this.cancelAll()}runTask(s){if(0===this.length)return F.G;for(;!s.done&&this._process(s);)s.madeProgress()}push(s,l,p){return++this._runningTasks.value,new Promise(((E,v)=>this._tasks.push(new a(E,v,s,l,p)))).finally((()=>--this._runningTasks.value))}unshift(s,l,p){return++this._runningTasks.value,new Promise(((E,v)=>this._tasks.unshift(new a(E,v,s,l,p)))).finally((()=>--this._runningTasks.value))}_process(s){if(0===this._tasks.length)return!1;const l=this._tasks.shift();try{const v=(0,E.G4)(l.signal);if(v&&!l.abortCallback)l.reject((0,E.NK)());else{var p;const F=v?null===(p=l.abortCallback)||void 0===p?void 0:p.call(l,(0,E.NK)()):l.callback(s);(0,E.$X)(F)?F.then(l.resolve,l.reject):l.resolve(F)}}catch(i){l.reject(i)}return!0}cancelAll(){const s=(0,E.NK)();for(const l of this._tasks)if(l.abortCallback){const p=l.abortCallback(s);l.resolve(p)}else l.reject(s);this._tasks.length=0}}class a{constructor(s,l,p){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:void 0,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;this.resolve=s,this.reject=l,this.callback=p,this.signal=E,this.abortCallback=v}}},2967:(s,l,p)=>{p.d(l,{$r:()=>j,Jc:()=>b,gV:()=>x,rb:()=>w});p(30174),p(4180);var E=p(62555),v=p(44952),F=p(98664),S=p(89343),A=p(78395),R=p(57022),O=p(73126),M=p(86241),D=p(86523),k=p(39368),L=p(57264);let V=null;const Q=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;function j(s,l,p,E){const v=(0,A.d9)(p)?(0,A.Vp)(p):null,F=v?Math.round((v.valid[1]-v.valid[0])/l.scale[0]):null;return s.map((s=>{const p=new L.A(s.geometry);return(0,S.Gy)(l,p,p,p.hasZ,p.hasM),s.geometry=v?function I(s,l,p){return s.x<0?s.x+=l:s.x>p&&(s.x-=l),s}(p,null!==F&&void 0!==F?F:0,E[0]):p,s}))}function x(s){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:18,p=arguments.length>2?arguments[2]:void 0,v=arguments.length>3?arguments[3]:void 0,F=arguments.length>4?arguments[4]:void 0;const S=new Float64Array(v*F);l=Math.round((0,E.Lz)(l));let A=Number.POSITIVE_INFINITY,R=Number.NEGATIVE_INFINITY;const M=(0,O.YW)(p);for(const{geometry:E,attributes:D}of s){const{x:s,y:p}=E,k=Math.max(0,s-l),L=Math.max(0,p-l),V=Math.min(F,p+l),Q=Math.min(v,s+l),U=+M(D);for(let E=L;E<V;E++)for(let F=k;F<Q;F++){const M=E*v+F,D=(0,O.hv)(F-s,E-p,l)*U,k=S[M]+=D;A=Math.min(A,k),R=Math.max(R,k)}}return{min:A,max:R}}function w(s){const l=Q.exec(s);if(!l)return null;const{hh:p,mm:E,ss:F,ms:S}=l.groups;return Number(p)*v.vf.hours+Number(E)*v.vf.minutes+Number(F)*v.vf.seconds+Number(S||0)}async function b(s,l){let p=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!l)return[];const{field:E,field2:v,field3:S,fieldDelimiter:A,fieldInfos:O,timeZone:L}=s,Q=E&&(null===O||void 0===O?void 0:O.find((s=>s.name.toLowerCase()===E.toLowerCase()))),U=!!Q&&(0,R.OH)(Q),z=!!Q&&(0,M.fs)(Q),B=s.valueExpression,Y=s.normalizationType,H=s.normalizationField,J=s.normalizationTotal,W=[],X=s.viewInfoParams;let K=null,ee=null;if(B){if(!V){const{arcadeUtils:s}=await(0,k.lw)();V=s}V.hasGeometryOperations(B)&&await V.enableGeometryOperations(),K=V.createFunction(B),ee=X?V.getViewInfo({viewingMode:X.viewingMode,scale:X.scale,spatialReference:new F.A(X.spatialReference)}):null}const te=s.fieldInfos,ie=l[0]&&"declaredClass"in l[0]&&"esri.Graphic"===l[0].declaredClass||!te?null:{fields:te};return l.forEach((s=>{const l=s.attributes;let F;if(B){const l=ie?{...s,layer:ie}:s,p=V.createExecContext(l,ee,L);F=V.executeFunction(K,p)}else l&&(F=l[E],v?(F="".concat((0,D.gJ)(F)).concat(A).concat((0,D.gJ)(l[v])),S&&(F="".concat(F).concat(A).concat((0,D.gJ)(l[S])))):"string"==typeof F&&p&&(z?F=F?new Date(F).getTime():null:U&&(F=F?w(F):null)));if(Y&&"number"==typeof F&&isFinite(F)){const s=l&&parseFloat(l[H]);F=(0,D.zS)(F,Y,s,J)}W.push(F)})),W}},86241:(s,l,p)=>{p.d(l,{fs:()=>Z,i0:()=>N});var E=p(87328),v=p(57022),F=(p(39368),p(22132),p(52994));new Set(["integer","small-integer"]);function Z(s){return(0,v.vE)(s)||(0,v.zD)(s)||(0,v.Ah)(s)}function N(s,l){const{format:p,timeZoneOptions:v,fieldType:S}=null!==l&&void 0!==l?l:{};let A,R;if(v&&({timeZone:A,timeZoneName:R}=(0,F.hv)(v.layerTimeZone,v.datesInUnknownTimezone,v.viewTimeZone,(0,E.J2)(p||"short-date-short-time"),S)),"string"==typeof s&&isNaN(Date.parse("time-only"===S?"1970-01-01T".concat(s,"Z"):s)))return s;switch(S){case"date-only":{const l=(0,E.J2)(p||"short-date");return"string"==typeof s?(0,E.iS)(s,{...l}):(0,E.Yq)(s,{...l,timeZone:F.n$})}case"time-only":{const l=(0,E.J2)(p||"short-time");return"string"==typeof s?(0,E.F8)(s,l):(0,E.Yq)(s,{...l,timeZone:F.n$})}case"timestamp-offset":{if(!A&&"string"==typeof s&&new Date(s).toISOString()!==s)return s;const l=p||v?(0,E.J2)(p||"short-date-short-time"):void 0,F=l?{...l,timeZone:A,timeZoneName:R}:void 0;return"string"==typeof s?(0,E.Ey)(s,F):(0,E.Yq)(s,F)}default:{const l=p||v?(0,E.J2)(p||"short-date-short-time"):void 0;return(0,E.Yq)("string"==typeof s?new Date(s):s,l?{...l,timeZone:A,timeZoneName:R}:void 0)}}}},57492:(s,l,p)=>{var E;p.d(l,{M:()=>E}),function(s){s[s.ANIMATING=0]="ANIMATING",s[s.INTERACTING=1]="INTERACTING",s[s.IDLE=2]="IDLE"}(E||(E={}))},53727:(s,l,p)=>{p.d(l,{nu:()=>ne,W6:()=>Y,Bb:()=>ae});var E=p(30073),v=(p(50886),p(89412)),F=p(35598),S=p(87810),A=p(17244),R=p(81618),O=p(63390),M=p(82428),D=p(73905),k=p(59159),L=p(80671),V=p(18763),Q=p(57453),U=(p(76761),p(68682));let z=class extends V.A{constructor(){super(...arguments),this.SCHEDULER_LOG_SLOW_TASKS=!1,this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES=!1}};(0,L._)([(0,Q.MZ)()],z.prototype,"SCHEDULER_LOG_SLOW_TASKS",void 0),(0,L._)([(0,Q.MZ)()],z.prototype,"FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES",void 0),z=(0,L._)([(0,U.$)("esri.views.support.DebugFlags")],z);const B=new z;var Y,H=p(57492),J=p(16848);!function(s){s.RESOURCE_CONTROLLER_IMMEDIATE="immediate",s.RESOURCE_CONTROLLER="schedule",s.SLIDE="slide",s.STREAM_DATA_LOADER="stream loader",s.ELEVATION_QUERY="elevation query",s.TERRAIN_SURFACE="terrain",s.SURFACE_GEOMETRY_UPDATES="surface geometry updates",s.LOD_RENDERER="LoD renderer",s.GRAPHICS_CORE="Graphics3D",s.I3S_CONTROLLER="I3S",s.POINT_CLOUD_LAYER="point cloud",s.FEATURE_TILE_FETCHER="feature fetcher",s.OVERLAY="overlay",s.STAGE="stage",s.GRAPHICS_DECONFLICTOR="graphics deconflictor",s.FILTER_VISIBILITY="Graphics3D filter visibility",s.SCALE_VISIBILITY="Graphics3D scale visibility",s.FRUSTUM_VISIBILITY="Graphics3D frustum visibility",s.POINT_OF_INTEREST_FREQUENT="POI frequent",s.POINT_OF_INTEREST_INFREQUENT="POI infrequent",s.LABELER="labeler",s.FEATURE_QUERY_ENGINE="feature query",s.FEATURE_TILE_TREE="feature tile tree",s.FEATURE_TILE_TREE_ACTIVE="fast feature tile tree",s.ELEVATION_ALIGNMENT="elevation alignment",s.ELEVATION_ALIGNMENT_SCENE="elevation alignment scene",s.TEXT_TEXTURE_ATLAS="text texture atlas",s.TEXTURE_UNLOAD="texture unload",s.LINE_OF_SIGHT_TOOL="line of sight tool",s.LINE_OF_SIGHT_TOOL_INTERACTIVE="interactive line of sight tool",s.ELEVATION_PROFILE="elevation profile",s.SNAPPING="snapping",s.SHADOW_ACCUMULATOR="shadow accumulator",s.CLOUDS_GENERATOR="clouds generator",s[s.NONE=0]="NONE",s[s.TEST_PRIO=1]="TEST_PRIO"}(Y||(Y={}));const W=new Map([[Y.RESOURCE_CONTROLLER_IMMEDIATE,0],[Y.RESOURCE_CONTROLLER,4],[Y.SLIDE,0],[Y.STREAM_DATA_LOADER,0],[Y.ELEVATION_QUERY,0],[Y.TERRAIN_SURFACE,1],[Y.SURFACE_GEOMETRY_UPDATES,1],[Y.LOD_RENDERER,2],[Y.GRAPHICS_CORE,2],[Y.I3S_CONTROLLER,2],[Y.POINT_CLOUD_LAYER,2],[Y.FEATURE_TILE_FETCHER,2],[Y.OVERLAY,4],[Y.STAGE,4],[Y.GRAPHICS_DECONFLICTOR,4],[Y.FILTER_VISIBILITY,4],[Y.SCALE_VISIBILITY,4],[Y.FRUSTUM_VISIBILITY,4],[Y.CLOUDS_GENERATOR,4],[Y.POINT_OF_INTEREST_FREQUENT,6],[Y.POINT_OF_INTEREST_INFREQUENT,30],[Y.LABELER,8],[Y.FEATURE_QUERY_ENGINE,8],[Y.FEATURE_TILE_TREE,16],[Y.FEATURE_TILE_TREE_ACTIVE,0],[Y.ELEVATION_ALIGNMENT,12],[Y.ELEVATION_ALIGNMENT_SCENE,14],[Y.TEXT_TEXTURE_ATLAS,12],[Y.TEXTURE_UNLOAD,12],[Y.LINE_OF_SIGHT_TOOL,16],[Y.LINE_OF_SIGHT_TOOL_INTERACTIVE,0],[Y.SNAPPING,0],[Y.SHADOW_ACCUMULATOR,30]]);function f(s){return W.has(s)?W.get(s):"number"==typeof s?s:1}const X=(0,D.l5)(6.5),K=(0,D.l5)(1),ee=(0,D.l5)(30),te=(0,D.l5)(1e3/30),ie=(0,D.l5)(100);var se,re;!function(s){s.Scheduler=class n{get updating(){return this._updating.value}_updatingChanged(){this._updating.value=this._tasks.some((s=>s.needsUpdate))}constructor(){this._updating=(0,M.v)(!0),this._microTaskQueued=!1,this._frameNumber=0,this.performanceInfo={total:new S.A("total"),tasks:new Map},this._frameTaskTimes=new Map,this._budget=new g,this._state=H.M.INTERACTING,this._tasks=new A.A,this._runQueue=new A.A,this._load=0,this._idleStateCallbacks=new A.A,this._idleUpdatesStartFired=!1,this._forceTask=!1,this._debug=!1,this._debugHandle=(0,O.wB)((()=>B.SCHEDULER_LOG_SLOW_TASKS),(s=>this._debug=s),O.Vh);for(const l of Object.keys(Y))this.performanceInfo.tasks.set(Y[l],new S.A(Y[l]));const s=this;this._test={FRAME_SAFETY_BUDGET:X,INTERACTING_BUDGET:te,IDLE_BUDGET:ie,get availableBudget(){return s._budget.budget},usedBudget:0,getBudget:()=>s._budget,setBudget:l=>s._budget=l,updateTask:s=>this._updateTask(s),getState:s=>this._getState(s),getRuntime:s=>this._getRuntime(s),frameTaskTimes:this._frameTaskTimes,resetRuntimes:()=>this._resetRuntimes(),getRunning:()=>this._getRunning()}}destroy(){this._tasks.toArray().forEach((s=>s.remove())),this._tasks.clear(),(0,F.xt)(this._debugHandle),this._microTaskQueued=!1,this._updatingChanged()}taskRunningChanged(s){this._updatingChanged(),s&&this._budget.remaining>0&&!this._microTaskQueued&&(this._microTaskQueued=!0,queueMicrotask((()=>{this._microTaskQueued&&(this._microTaskQueued=!1,this._budget.remaining>0&&this._schedule()&&this.frame())})))}registerTask(s,l){const p=new _(this,s,l);return this._tasks.push(p),this._updatingChanged(),this.performanceInfo.tasks.has(s)||this.performanceInfo.tasks.set(s,new S.A(s)),p}registerIdleStateCallbacks(s,l){const p={idleBegin:s,idleEnd:l};this._idleStateCallbacks.push(p),this.state===H.M.IDLE&&this._idleUpdatesStartFired&&p.idleBegin();const E=this;return{remove:()=>this._removeIdleStateCallbacks(p),set idleBegin(s){E._idleUpdatesStartFired&&(p.idleEnd(),E._state===H.M.IDLE&&s()),p.idleBegin=s},set idleEnd(s){p.idleEnd=s}}}get load(){return this._load}set state(s){this._state!==s&&(this._state=s,this.state!==H.M.IDLE&&this._idleUpdatesStartFired&&(this._idleUpdatesStartFired=!1,this._idleStateCallbacks.forAll((s=>s.idleEnd()))))}get state(){return this._state}updateBudget(s){this._test.usedBudget=0,++this._frameNumber;let l=X,p=s.frameDuration,E=K;switch(this.state){case H.M.IDLE:l=(0,D.l5)(0),p=(0,D.l5)(Math.max(ie,s.frameDuration)),E=ee;break;case H.M.INTERACTING:p=(0,D.l5)(Math.max(te,s.frameDuration));case H.M.ANIMATING:}return p=(0,D.l5)(p-s.elapsedFrameTime-l),this.state!==H.M.IDLE&&p<K&&!this._forceTask?(this._forceTask=!0,!1):(p=(0,D.l5)(Math.max(p,E)),this._budget.reset(p,this.state),this._updateLoad(),this._schedule())}frame(){switch(this._forceTask=!1,this._microTaskQueued=!1,this.state){case H.M.IDLE:this._idleUpdatesStartFired||(this._idleUpdatesStartFired=!0,this._idleStateCallbacks.forAll((s=>s.idleBegin()))),this._runIdle();break;case H.M.INTERACTING:this._runInteracting();break;default:this._runAnimating()}this._test.usedBudget=this._budget.elapsed}stopFrame(){this._budget.reset((0,D.l5)(0),this._state),this._budget.madeProgress()}_removeIdleStateCallbacks(s){this._idleUpdatesStartFired&&s.idleEnd(),this._idleStateCallbacks.removeUnordered(s)}removeTask(s){this._tasks.removeUnordered(s),this._runQueue.removeUnordered(s),this._updatingChanged()}_updateTask(s){this._tasks.forAll((l=>{l.name===s&&l.setPriority(s)}))}_getState(s){if(this._runQueue.some((l=>l.name===s)))return re.SCHEDULED;let l=re.IDLE;return this._tasks.forAll((p=>{p.name===s&&p.needsUpdate&&(p.schedulePriority<=1?l=re.READY:l!==re.READY&&(l=re.WAITING))})),l}_getRuntime(s){let l=0;return this._tasks.forAll((p=>{p.name===s&&(l+=p.runtime)})),l}_resetRuntimes(){this._tasks.forAll((s=>s.runtime=0))}_getRunning(){const s=new Map;if(this._tasks.forAll((l=>{l.needsUpdate&&s.set(l.name,(s.get(l.name)||0)+1)})),0===s.size)return null;let l="";return s.forEach(((s,p)=>{l+=s>1?" ".concat(s,"x ").concat(p):" ".concat(p)})),l}_runIdle(){this._run()}_runInteracting(){this._run()}_runAnimating(){this._run()}_updateLoad(){const s=this._tasks.reduce(((s,l)=>l.needsUpdate?++s:s),0);this._load=.9*this._load+s*(1-.9)}_schedule(){for(this._runQueue.filterInPlace((s=>!!s.needsUpdate||(s.schedulePriority=s.basePriority,!1))),this._tasks.forAll((s=>{0===s.basePriority&&s.needsUpdate&&!this._runQueue.includes(s)&&s.blockFrame!==this._frameNumber&&this._runQueue.unshift(s)}));0===this._runQueue.length;){let s=!1,l=0;if(this._tasks.forAll((p=>{p.needsUpdate&&0!==p.schedulePriority&&0!==p.basePriority&&p.blockFrame!==this._frameNumber&&(s=!0,l=Math.max(l,p.basePriority),1===p.schedulePriority?(p.schedulePriority=0,this._runQueue.push(p)):--p.schedulePriority)})),!s)return this._updatingChanged(),!1}return this._updatingChanged(),!0}_run(){const s=this._budget.now();this._startFrameTaskTimes();do{for(;this._runQueue.length>0;){const p=this._budget.now(),E=this._runQueue.pop();this._budget.resetProgress();try{E.task.runTask(this._budget)===J.G&&(E.blockFrame=this._frameNumber)}catch(l){v.A.getLogger("esri.views.support.Scheduler").error('Exception in task "'.concat(E.name,'"'),l),E.blockFrame=this._frameNumber}!this._budget.hasProgressed&&E.blockFrame!==this._frameNumber&&E.needsUpdate&&(E.name,Y.I3S_CONTROLLER,E.blockFrame=this._frameNumber),E.schedulePriority=E.basePriority;const F=this._budget.now()-p;if(E.runtime+=F,this._frameTaskTimes.set(E.priority,this._frameTaskTimes.get(E.priority)+F),this._debug&&F>2*this._budget.budget&&console.log("Task",E.name,"used",F,"of max",this._budget.budget,"ms"),this._budget.remaining<=0)return this._updatingChanged(),void this._recordFrameTaskTimes(this._budget.now()-s)}}while(this._schedule());this._updatingChanged(),this._recordFrameTaskTimes(this._budget.now()-s)}_startFrameTaskTimes(){for(const s of Object.keys(Y))this._frameTaskTimes.set(Y[s],0)}_recordFrameTaskTimes(s){this._frameTaskTimes.forEach(((s,l)=>this.performanceInfo.tasks.get(l).record(s))),this.performanceInfo.total.record(s)}get test(){return this._test}};class _{get task(){return this._task.value}get updating(){return this._queue.running}constructor(s,l,p){this._scheduler=s,this.name=l,this.blockFrame=0,this.runtime=0,this._queue=new k.T,this._handles=new E.A,this._basePriority=f(l),this.schedulePriority=this._basePriority,this._task=(0,M.v)(null!=p?p:this._queue),this._handles.add((0,O.z7)((()=>this.task.running),(l=>s.taskRunningChanged(l))))}remove(){this.processQueue(ae),this._scheduler.removeTask(this),this.schedule=ne.schedule,this.reschedule=ne.reschedule,this._handles.destroy()}get basePriority(){return this._basePriority}setPriority(s){if(this.name===s)return;this.name=s;const l=f(s);0!==this._basePriority&&0===this.schedulePriority||(this.schedulePriority=l),this._basePriority=l}get priority(){return this.name}set priority(s){this.setPriority(s)}get needsUpdate(){return this.updating||this.task.running}schedule(s,l,p){return this._queue.push(s,l,p)}reschedule(s,l,p){return this._queue.unshift(s,l,p)}processQueue(s){return this._queue.runTask(s)}}class g{constructor(){this._begin="undefined"!=typeof performance?performance.now():0,this._budget=0,this._state=H.M.IDLE,this._done=!1,this._progressed=!1,this._enabled=!0}run(s){return!this.done&&(!0===s()&&this.madeProgress(),!0)}get done(){return this._done}get budget(){return this._budget}madeProgress(){return this._progressed=!0,this._done=this.elapsed>=this._budget&&this._enabled,this._done}get state(){return this._state}get enabled(){return this._enabled}set enabled(s){this._enabled=s}reset(s,l){this._begin=this.now(),this._budget=s,this._state=l,this.resetProgress()}get remaining(){return Math.max(this._budget-this.elapsed,0)}now(){return performance.now()}get elapsed(){return performance.now()-this._begin}resetProgress(){this._progressed=!1,this._done=!1}get hasProgressed(){return this._progressed}}s.Budget=g}(se||(se={})),function(s){s.SCHEDULED="s",s.READY="r",s.WAITING="w",s.IDLE="i"}(re||(re={}));const ae=(()=>{const s=new se.Budget;return s.enabled=!1,s})();const ne=new class P{remove(){}processQueue(){}schedule(s,l,p){try{if((0,R.G4)(l)){const s=(0,R.NK)();return p?Promise.resolve(p(s)):Promise.reject(s)}return(0,R.z7)(s(ae))}catch(E){return Promise.reject(E)}}reschedule(s,l,p){return this.schedule(s,l,p)}}},16848:(s,l,p)=>{p.d(l,{G:()=>E});const E=Symbol("Yield")}}]);
//# sourceMappingURL=2214.d349eb47.chunk.js.map