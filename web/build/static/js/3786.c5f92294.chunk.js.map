{"version":3,"file":"static/js/3786.c5f92294.chunk.js","mappings":";+NAAO,MAAMA,EACA,YAMAC,EAAoB,4BCJjBC,EAA6BC,GAC3C,MAAM,iBAAEC,GAAqBD,EAE7B,OAC+B,kBAArBC,GAAgCC,EAAAA,EAAAA,GAAkBF,EAAS,CAAEG,GAAIF,IAAsBA,IAC/F,IAEJ,CCVA,MCiCMG,EAAU,UC5BhBC,WAAAA,GAOU,KAAAC,mBAAqB,IAAIC,QAEzB,KAAAC,2BAA6B,IAAID,QAEjC,KAAAE,iBAA2B,KAE3B,KAAAC,kBAA4B,KAE5B,KAAAC,cAA2C,KAE3C,KAAAC,uBAAyB,EA4CzB,KAAAC,aAAgBC,IACtB,MAAM,mBAAER,GAAuBS,KAEzBC,EAAqBF,EAA+BG,MAAMC,GAAWZ,EAAmBa,IAAID,KAElG,OAAOZ,EAAmBc,IAAIJ,EAAkB,EAG1C,KAAAK,eAAkBC,IACxB,GAAkB,WAAdA,EAAMC,MAAqBD,EAAME,iBAAkB,CACrD,MAAM,cAAEb,GAAkBI,KAE1B,GAAiB,OAAbJ,QAAa,IAAbA,GAAAA,EAAec,KAAM,CACvBV,KAAKW,oBACLX,KAAKY,qBAEL,MAAM1B,EAAmBF,EAA6BY,GAElDV,aAA4B2B,SAAW3B,EAAiB4B,SAASP,EAAMQ,SACzER,EAAMS,oBAMN,KAAAC,mBAAsBV,IAC5B,MAAMR,EAAeQ,EAAMR,gBACrB,cAAEH,GAAkBI,KAEpBf,EAAUe,KAAKF,aAAaC,GAE9BC,KAAKkB,mBAAmBjC,EAASc,GACnCC,KAAKW,oBAIH1B,EACFe,KAAKmB,mBAAmBlC,GACF,OAAbW,QAAa,IAAbA,GAAAA,EAAec,MACxBV,KAAKoB,uBAYD,KAAAC,aAAgBd,IACtB,MAAMR,EAAeQ,EAAMR,eACrBd,EAAUe,KAAKF,aAAaC,GAE9BC,KAAKkB,mBAAmBjC,EAASc,GACnCC,KAAKW,qBAIPX,KAAKY,qBAEA3B,IAILe,KAAKW,oBAED1B,EAAQqC,aACVtB,KAAKuB,cAActC,GAAS,GAI9Be,KAAKuB,cAActC,GAAS,IAAK,EAG3B,KAAAuC,YAAc,KACpBxB,KAAKY,oBAAoB,EAGnB,KAAAa,eAAkBlB,IACxB,MAAMR,EAAeQ,EAAMR,eACrBd,EAAUe,KAAKF,aAAaC,GAElCC,KAAK0B,wBAAwBzC,GAExBA,GAILe,KAAK2B,qBAAqB1C,GAAS,EAAK,EAsElC,KAAAkC,mBAAsBlC,IAAkC,IAAA2C,EAC9D5B,KAAKN,iBAAmBmC,OAAOC,YAC7B,KACgC,OAA1B9B,KAAKN,mBAITM,KAAK+B,yBACL/B,KAAK0B,wBAAwBzC,GAC7Be,KAAKuB,cAActC,GAAS,GAAK,GAEjB,QAAlB2C,EAAA5B,KAAKJ,qBAAa,IAAAgC,GAAlBA,EAAoBlB,KAAO,EJzOI,II0OhC,EAGK,KAAAU,oBAAsB,KAC5BpB,KAAKL,kBAAoBkC,OAAOC,YAAW,KACV,OAA3B9B,KAAKL,mBAITK,KAAKY,oBAAoB,GJlPO,IImPR,EA1N5BoB,eAAAA,CAAgBC,EAA+BhD,GAC7Ce,KAAKH,yBACLG,KAAKT,mBAAmB2C,IAAID,EAAahD,GACzC,MAAMkD,EAAanC,KAAKoC,6BAA6BH,GAEjDE,GACFnC,KAAKqC,mBAAmBF,GAGU,IAAhCnC,KAAKH,wBACPG,KAAKsC,eAITC,iBAAAA,CAAkBN,GAChB,MAAME,EAAanC,KAAKoC,6BAA6BH,GAEjDE,GACFnC,KAAKwC,qBAAqBL,GAGxBnC,KAAKT,mBAAmBkD,OAAOR,IACjCjC,KAAKH,yBAG6B,IAAhCG,KAAKH,wBACPG,KAAK0C,kBAqDDxB,kBAAAA,CAAmBjC,EAAoCc,GAC7D,MAAM,cAAEH,GAAkBI,KAE1B,OACgB,OAAbJ,QAAa,IAAbA,OAAa,EAAbA,EAAec,OAAQX,EAAa4C,SAAS/C,KAA2B,OAAPX,QAAO,IAAPA,OAAO,EAAPA,EAASyB,OAAQX,EAAa4C,SAAS1D,GA8CrG2D,kBAAAA,CAAmBT,GACzBA,EAAWU,iBAAiB,UAAW7C,KAAKyB,eAAgB,CAAEqB,SAAS,IAGjEC,qBAAAA,CAAsBZ,GAC5BA,EAAWa,oBAAoB,UAAWhD,KAAKyB,eAAgB,CAAEqB,SAAS,IAGpER,YAAAA,GACNT,OAAOgB,iBAAiB,UAAW7C,KAAKM,eAAgB,CAAEwC,SAAS,IACnEjB,OAAOgB,iBAAiB,cAAe7C,KAAKiB,mBAAoB,CAAE6B,SAAS,IAC3EjB,OAAOgB,iBAAiB,QAAS7C,KAAKqB,aAAc,CAAEyB,SAAS,IAC/DjB,OAAOgB,iBAAiB,UAAW7C,KAAKyB,eAAgB,CAAEqB,SAAS,IACnEjB,OAAOgB,iBAAiB,OAAQ7C,KAAKwB,aAG/BkB,eAAAA,GACNb,OAAOmB,oBAAoB,UAAWhD,KAAKM,eAAgB,CAAEwC,SAAS,IACtEjB,OAAOmB,oBAAoB,cAAehD,KAAKiB,mBAAoB,CAAE6B,SAAS,IAC9EjB,OAAOmB,oBAAoB,QAAShD,KAAKqB,aAAc,CAAEyB,SAAS,IAClEjB,OAAOmB,oBAAoB,UAAWhD,KAAKyB,eAAgB,CAAEqB,SAAS,IACtEjB,OAAOmB,oBAAoB,OAAQhD,KAAKwB,aAGlCyB,qBAAAA,GACNpB,OAAOqB,aAAalD,KAAKN,kBACzBM,KAAKN,iBAAmB,KAGlBqC,sBAAAA,GACNF,OAAOqB,aAAalD,KAAKL,mBACzBK,KAAKL,kBAAoB,KAGnBgB,iBAAAA,GACNX,KAAKiD,wBACLjD,KAAK+B,yBAGCL,uBAAAA,CAAwBzC,GAC1Be,KAAKJ,gBAAkBX,GACzBe,KAAKY,qBAIDA,kBAAAA,GACN,MAAM,cAAEhB,GAAkBI,KAET,OAAbJ,QAAa,IAAbA,GAAAA,EAAec,MACjBV,KAAKuB,cAAc3B,GAAe,GAI9B+B,oBAAAA,CAAqB1C,EAAoCyB,GAC3DA,GACFV,KAAKW,oBAGPX,KAAKuB,cAActC,EAASyB,GAGtBa,aAAAA,CAActC,EAAoCyB,GACxDzB,EAAQyB,KAAOA,EAEfV,KAAKJ,cAAgBc,EAAOzB,EAAU,KA4BhCoD,kBAAAA,CAAmBF,GACzB,MAAM,2BAAE1C,GAA+BO,KAEjCmD,EAAQ1D,EAA2BY,IAAI8B,GACvCiB,EAAWC,KAAKC,KAAsB,kBAAVH,EAAqBA,EAAQ,GAAK,EAAG,GAEtD,IAAbC,GACFpD,KAAK4C,mBAAmBT,GAG1B1C,EAA2ByC,IAAIC,EAAYiB,GAGrCZ,oBAAAA,CAAqBL,GAC3B,MAAM,2BAAE1C,GAA+BO,KAEjCmD,EAAQ1D,EAA2BY,IAAI8B,GACvCiB,EAAWC,KAAKE,KAAsB,kBAAVJ,EAAqBA,EAAQ,GAAK,EAAG,GAEtD,IAAbC,GACFpD,KAAK+C,sBAAsBZ,GAG7B1C,EAA2ByC,IAAIC,EAAYiB,GAGrChB,4BAAAA,CAA6BH,GACnC,OAAOA,aAAuBpB,SAAU2C,EAAAA,EAAAA,GAAkBvB,GAAe,OD3OhEwB,GAAOC,EAAAA,EAAAA,IAAA,cAAAC,EAAAA,sWAuGlB,KAAAC,KAAO,mBAAHC,QAAsBD,EAAAA,EAAAA,MAE1B,KAAAE,WAAY,EAEZ,KAAAC,mBAAqB,UAkHb,KAAAC,gBAAmBC,IACzBjE,KAAKkE,aAAeD,CAAE,EAGxB,KAAAE,sBAAwB,WAAY,IAAXC,IAAIC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAC3BG,EAAKC,mBACLD,EAAKE,0BAA4B1F,EAA6BwF,EAAKP,KACnEU,EAAAA,EAAAA,GAAkBH,EAAMA,EAAKE,0BAA2BF,EAAKP,IAE7D,MAAM,GAAEA,EAAE,iBAAE/E,EAAgB,0BAAEwF,GAA8BF,EACxDJ,GAAQlF,IAAqBwF,GAC/BE,QAAQR,KAAK,GAADP,OAAII,EAAGY,QAAO,4BAAAhB,OAA2B3E,EAAgB,oBAAoB,CACvF+E,OAIJO,EAAKM,iBAGP,KAAAC,MAAQ,IACC/E,KAAKiE,GAAG7E,IAAMY,KAAK4D,KAG5B,KAAAkB,cAAgB,KACd,MAAM,0BAAEJ,GAA8B1E,KAEtC,IAAK0E,EACH,OAGF,MAAMtF,EAAKY,KAAK+E,QAEZ,iBAAkBL,GACpBA,EAA0BM,aAAajG,EAAmBK,GAG5DC,EAAQ2C,gBAAgB0C,EAA2B1E,KAAKiE,GAAG,EAG7D,KAAAQ,iBAAmB,KACjB,MAAM,0BAAEC,GAA8B1E,KAEjC0E,IAID,oBAAqBA,GACvBA,EAA0BO,gBAAgBlG,GAG5CM,EAAQkD,kBAAkBmC,GAA0B,qBAvQd,wCAcEQ,EAAAA,sBAUA,aAUV,0BAgBkC,0BAUX,8FA+Bb,WA1E1CC,2BAAAA,GACEnF,KAAKoF,YAAW,GASlBC,qBAAAA,GACErF,KAAKoF,YAAW,GASlBE,WAAAA,IACEC,EAAAA,EAAAA,GAA2BvF,MAC3BA,KAAKoF,YAAW,GAclBI,yBAAAA,GACExF,KAAKoF,YAAW,GASlBK,gBAAAA,GACEzF,KAAKoF,YAAW,GAalBM,uBAAAA,GACE1F,KAAKmE,wBA+BPwB,iBAAAA,GACE3F,KAAKmE,uBAAsB,GACvBnE,KAAKU,OACP6E,EAAAA,EAAAA,GAA2BvF,MAI/B,uBAAM4F,GACA5F,KAAKU,OACP6E,EAAAA,EAAAA,GAA2BvF,MAI/B6F,gBAAAA,GACM7F,KAAKd,mBAAqBc,KAAK0E,2BACjC1E,KAAKmE,wBAEPnE,KAAK8D,WAAY,EAGnBgC,oBAAAA,GACE9F,KAAKyE,oBACLsB,EAAAA,EAAAA,GAAqB/F,KAAMA,KAAK0E,0BAA2B1E,KAAKiE,IAiClE,gBAAMmB,GAA0B,IAAfY,EAAO3B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACtB,MAAM,GACJJ,EAAE,0BACFS,EAAyB,UACzBuB,EAAS,mBACTC,EAAkB,eAClBC,EAAc,eACdC,EAAc,QACdC,GACErG,KAEJ,OAAOoF,EAAAA,EAAAA,GACLpF,KACA,CACEsG,WAAYrC,EACZhC,YAAayC,EACbwB,qBACAD,YACAE,iBACAC,iBACAC,UACAE,KAAM,WAERP,GAUJQ,YAAAA,GACExG,KAAKyG,yBAAyBC,OAGhCC,MAAAA,GACE3G,KAAK4G,mBAAmBF,OAG1BG,aAAAA,GACE7G,KAAK8G,0BAA0BJ,OAGjCK,OAAAA,GACE/G,KAAKgH,oBAAoBN,OA8D3BO,MAAAA,GACE,MAAM,0BAAEvC,EAAyB,MAAEwC,EAAK,KAAExG,EAAI,eAAEyG,GAAmBnH,KAC7DoH,EAAY1C,GAA6BhE,EACzC2G,GAAUD,EAEhB,OACEE,EAAAA,EAAAA,GAACC,EAAAA,GAAI,CAAA/G,IAAA,0DACUgH,EAAAA,EAAAA,GAAcH,GAAO,aACtBH,EAAK,YACP,SAAQ,0BACOG,EACzBjI,GAAIY,KAAK+E,QACT0C,KAAK,YAELH,EAAAA,EAAAA,GAAA,OAAA9G,IAAA,2CACEkH,MAAO,CACL,CAACC,EAAAA,EAAYC,YAAY,EACzB,CAACD,EAAAA,EAAYE,iBAAkBT,GAEjCU,IAAK9H,KAAKgE,kBAEVsD,EAAAA,EAAAA,GAACS,EAAAA,EAAa,CAAAvH,IAAA,2CACZ2G,eAAgBA,EAChBW,IAAMzB,GAAyBrG,KAAKqG,QAAUA,KAEhDiB,EAAAA,EAAAA,GAAA,OAAA9G,IAAA,2CAAKkH,MAAO5I,IACVwI,EAAAA,EAAAA,GAAA,QAAA9G,IAAA,sWD7VO,0gFGMZ,MAAMwH,EAAmBC,EAAAA,GA0DhC,SAASC,EAAOC,GACd,MAAO,WAAYA,EAAYA,EAAUC,OAASD,EAAUzH,IAC9D,UAqBgB6E,EAA2B4C,GACzCH,GAAiB,KACVG,EAAUjE,eAIfmE,EAAAA,EAAAA,GACEF,EAAUjE,aACViE,EAAUpE,oBACV,KACMmE,EAAOC,GACTA,EAAU3B,eAEV2B,EAAUtB,mBAGd,KACMqB,EAAOC,GACTA,EAAUxB,SAEVwB,EAAUpB,YAGf,GAEL","sources":["../node_modules/@esri/calcite-components/dist/components/src/components/tooltip/resources.ts","../node_modules/@esri/calcite-components/dist/components/src/components/tooltip/utils.ts","../node_modules/@esri/calcite-components/dist/components/src/components/tooltip/tooltip.scss?tag=calcite-tooltip&encapsulation=shadow","../node_modules/@esri/calcite-components/dist/components/src/components/tooltip/tooltip.tsx","../node_modules/@esri/calcite-components/dist/components/src/components/tooltip/TooltipManager.ts","../node_modules/@esri/calcite-components/dist/components/src/utils/openCloseComponent.ts"],"sourcesContent":["export const CSS = {\n  container: \"container\",\n};\n\nexport const TOOLTIP_OPEN_DELAY_MS = 300;\nexport const TOOLTIP_CLOSE_DELAY_MS = 500;\n\nexport const ARIA_DESCRIBED_BY = \"aria-describedby\";\n","import { ReferenceElement } from \"../../utils/floating-ui\";\nimport { queryElementRoots } from \"../../utils/dom\";\n\nexport function getEffectiveReferenceElement(tooltip: HTMLCalciteTooltipElement): ReferenceElement {\n  const { referenceElement } = tooltip;\n\n  return (\n    (typeof referenceElement === \"string\" ? queryElementRoots(tooltip, { id: referenceElement }) : referenceElement) ||\n    null\n  );\n}\n","/**\n * CSS Custom Properties\n *\n * These properties can be overridden using the component's tag as selector.\n *\n * @prop --calcite-tooltip-z-index: Sets the z-index value for the component.\n */\n\n:host {\n  --calcite-floating-ui-z-index: var(--calcite-tooltip-z-index, theme(\"zIndex.tooltip\"));\n}\n\n@include floatingUIHost();\n@include floatingUIArrow();\n\n.container {\n  @apply text-color-1\n    text-n2-wrap\n    relative\n    overflow-hidden\n    rounded\n    py-3\n    px-4\n    font-medium;\n  max-inline-size: 20rem;\n  max-block-size: 20rem;\n  text-align: start;\n}\n\n.calcite-floating-ui-anim {\n  @apply bg-foreground-1\n    border-color-3\n    rounded\n    border\n    border-solid;\n}\n\n.arrow::before {\n  outline: 1px solid var(--calcite-color-border-3);\n}\n\n@include base-component();\n","import {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Method,\n  Prop,\n  State,\n  VNode,\n  Watch,\n} from \"@stencil/core\";\nimport { toAriaBoolean } from \"../../utils/dom\";\nimport {\n  connectFloatingUI,\n  defaultOffsetDistance,\n  disconnectFloatingUI,\n  FloatingCSS,\n  FloatingLayout,\n  FloatingUIComponent,\n  LogicalPlacement,\n  OverlayPositioning,\n  ReferenceElement,\n  reposition,\n} from \"../../utils/floating-ui\";\nimport { guid } from \"../../utils/guid\";\nimport { onToggleOpenCloseComponent, OpenCloseComponent } from \"../../utils/openCloseComponent\";\nimport { FloatingArrow } from \"../functional/FloatingArrow\";\nimport { ARIA_DESCRIBED_BY, CSS } from \"./resources\";\nimport TooltipManager from \"./TooltipManager\";\nimport { getEffectiveReferenceElement } from \"./utils\";\n\nconst manager = new TooltipManager();\n\n/**\n * @slot - A slot for adding text.\n */\n@Component({\n  tag: \"calcite-tooltip\",\n  styleUrl: \"tooltip.scss\",\n  shadow: true,\n})\nexport class Tooltip implements FloatingUIComponent, OpenCloseComponent {\n  // --------------------------------------------------------------------------\n  //\n  //  Properties\n  //\n  // --------------------------------------------------------------------------\n\n  /** Closes the component when the `referenceElement` is clicked. */\n  @Prop({ reflect: true }) closeOnClick = false;\n\n  /**\n   * Accessible name for the component.\n   *\n   * @deprecated No longer necessary. Overrides the context of the component's description, which could confuse assistive technology users.\n   */\n  @Prop() label: string;\n\n  /**\n   * Offset the position of the component away from the `referenceElement`.\n   *\n   * @default 6\n   */\n  @Prop({ reflect: true }) offsetDistance = defaultOffsetDistance;\n\n  @Watch(\"offsetDistance\")\n  offsetDistanceOffsetHandler(): void {\n    this.reposition(true);\n  }\n\n  /**\n   * Offset the position of the component along the `referenceElement`.\n   */\n  @Prop({ reflect: true }) offsetSkidding = 0;\n\n  @Watch(\"offsetSkidding\")\n  offsetSkiddingHandler(): void {\n    this.reposition(true);\n  }\n\n  /**\n   * When `true`, the component is open.\n   */\n  @Prop({ reflect: true }) open = false;\n\n  @Watch(\"open\")\n  openHandler(): void {\n    onToggleOpenCloseComponent(this);\n    this.reposition(true);\n  }\n\n  /**\n   * Determines the type of positioning to use for the overlaid content.\n   *\n   * Using `\"absolute\"` will work for most cases. The component will be positioned inside of overflowing parent containers and will affect the container's layout.\n   *\n   * The `\"fixed\"` value should be used to escape an overflowing parent container, or when the reference element's `position` CSS property is `\"fixed\"`.\n   *\n   */\n  @Prop({ reflect: true }) overlayPositioning: OverlayPositioning = \"absolute\";\n\n  @Watch(\"overlayPositioning\")\n  overlayPositioningHandler(): void {\n    this.reposition(true);\n  }\n\n  /**\n   * Determines where the component will be positioned relative to the `referenceElement`.\n   */\n  @Prop({ reflect: true }) placement: LogicalPlacement = \"auto\";\n\n  @Watch(\"placement\")\n  placementHandler(): void {\n    this.reposition(true);\n  }\n\n  /**\n   * The `referenceElement` to position the component according to its `\"placement\"` value.\n   *\n   * Setting to the `HTMLElement` is preferred so the component does not need to query the DOM for the `referenceElement`.\n   *\n   * However, a string ID of the reference element can be used.\n   */\n  @Prop() referenceElement: ReferenceElement | string;\n\n  @Watch(\"referenceElement\")\n  referenceElementHandler(): void {\n    this.setUpReferenceElement();\n  }\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Properties\n  //\n  // --------------------------------------------------------------------------\n\n  @Element() el: HTMLCalciteTooltipElement;\n\n  @State() effectiveReferenceElement: ReferenceElement;\n\n  @State() floatingLayout: FloatingLayout = \"vertical\";\n\n  arrowEl: SVGElement;\n\n  guid = `calcite-tooltip-${guid()}`;\n\n  hasLoaded = false;\n\n  openTransitionProp = \"opacity\";\n\n  transitionEl: HTMLDivElement;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  // --------------------------------------------------------------------------\n\n  connectedCallback(): void {\n    this.setUpReferenceElement(true);\n    if (this.open) {\n      onToggleOpenCloseComponent(this);\n    }\n  }\n\n  async componentWillLoad(): Promise<void> {\n    if (this.open) {\n      onToggleOpenCloseComponent(this);\n    }\n  }\n\n  componentDidLoad(): void {\n    if (this.referenceElement && !this.effectiveReferenceElement) {\n      this.setUpReferenceElement();\n    }\n    this.hasLoaded = true;\n  }\n\n  disconnectedCallback(): void {\n    this.removeReferences();\n    disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Events\n  //\n  //--------------------------------------------------------------------------\n\n  /** Fires when the component is requested to be closed and before the closing transition begins. */\n  @Event({ cancelable: false }) calciteTooltipBeforeClose: EventEmitter<void>;\n\n  /** Fires when the component is closed and animation is complete. */\n  @Event({ cancelable: false }) calciteTooltipClose: EventEmitter<void>;\n\n  /** Fires when the component is added to the DOM but not rendered, and before the opening transition begins. */\n  @Event({ cancelable: false }) calciteTooltipBeforeOpen: EventEmitter<void>;\n\n  /** Fires when the component is open and animation is complete. */\n  @Event({ cancelable: false }) calciteTooltipOpen: EventEmitter<void>;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n\n  /**\n   * Updates the position of the component.\n   *\n   * @param delayed\n   */\n  @Method()\n  async reposition(delayed = false): Promise<void> {\n    const {\n      el,\n      effectiveReferenceElement,\n      placement,\n      overlayPositioning,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n    } = this;\n\n    return reposition(\n      this,\n      {\n        floatingEl: el,\n        referenceEl: effectiveReferenceElement,\n        overlayPositioning,\n        placement,\n        offsetDistance,\n        offsetSkidding,\n        arrowEl,\n        type: \"tooltip\",\n      },\n      delayed,\n    );\n  }\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Methods\n  //\n  // --------------------------------------------------------------------------\n\n  onBeforeOpen(): void {\n    this.calciteTooltipBeforeOpen.emit();\n  }\n\n  onOpen(): void {\n    this.calciteTooltipOpen.emit();\n  }\n\n  onBeforeClose(): void {\n    this.calciteTooltipBeforeClose.emit();\n  }\n\n  onClose(): void {\n    this.calciteTooltipClose.emit();\n  }\n\n  private setTransitionEl = (el): void => {\n    this.transitionEl = el;\n  };\n\n  setUpReferenceElement = (warn = true): void => {\n    this.removeReferences();\n    this.effectiveReferenceElement = getEffectiveReferenceElement(this.el);\n    connectFloatingUI(this, this.effectiveReferenceElement, this.el);\n\n    const { el, referenceElement, effectiveReferenceElement } = this;\n    if (warn && referenceElement && !effectiveReferenceElement) {\n      console.warn(`${el.tagName}: reference-element id \"${referenceElement}\" was not found.`, {\n        el,\n      });\n    }\n\n    this.addReferences();\n  };\n\n  getId = (): string => {\n    return this.el.id || this.guid;\n  };\n\n  addReferences = (): void => {\n    const { effectiveReferenceElement } = this;\n\n    if (!effectiveReferenceElement) {\n      return;\n    }\n\n    const id = this.getId();\n\n    if (\"setAttribute\" in effectiveReferenceElement) {\n      effectiveReferenceElement.setAttribute(ARIA_DESCRIBED_BY, id);\n    }\n\n    manager.registerElement(effectiveReferenceElement, this.el);\n  };\n\n  removeReferences = (): void => {\n    const { effectiveReferenceElement } = this;\n\n    if (!effectiveReferenceElement) {\n      return;\n    }\n\n    if (\"removeAttribute\" in effectiveReferenceElement) {\n      effectiveReferenceElement.removeAttribute(ARIA_DESCRIBED_BY);\n    }\n\n    manager.unregisterElement(effectiveReferenceElement);\n  };\n\n  // --------------------------------------------------------------------------\n  //\n  //  Render Methods\n  //\n  // --------------------------------------------------------------------------\n\n  render(): VNode {\n    const { effectiveReferenceElement, label, open, floatingLayout } = this;\n    const displayed = effectiveReferenceElement && open;\n    const hidden = !displayed;\n\n    return (\n      <Host\n        aria-hidden={toAriaBoolean(hidden)}\n        aria-label={label}\n        aria-live=\"polite\"\n        calcite-hydrated-hidden={hidden}\n        id={this.getId()}\n        role=\"tooltip\"\n      >\n        <div\n          class={{\n            [FloatingCSS.animation]: true,\n            [FloatingCSS.animationActive]: displayed,\n          }}\n          ref={this.setTransitionEl}\n        >\n          <FloatingArrow\n            floatingLayout={floatingLayout}\n            ref={(arrowEl: SVGElement) => (this.arrowEl = arrowEl)}\n          />\n          <div class={CSS.container}>\n            <slot />\n          </div>\n        </div>\n      </Host>\n    );\n  }\n}\n","import { getShadowRootNode } from \"../../utils/dom\";\nimport { ReferenceElement } from \"../../utils/floating-ui\";\nimport { TOOLTIP_OPEN_DELAY_MS, TOOLTIP_CLOSE_DELAY_MS } from \"./resources\";\nimport { getEffectiveReferenceElement } from \"./utils\";\n\nexport default class TooltipManager {\n  // --------------------------------------------------------------------------\n  //\n  //  Private Properties\n  //\n  // --------------------------------------------------------------------------\n\n  private registeredElements = new WeakMap<ReferenceElement, HTMLCalciteTooltipElement>();\n\n  private registeredShadowRootCounts = new WeakMap<ShadowRoot, number>();\n\n  private hoverOpenTimeout: number = null;\n\n  private hoverCloseTimeout: number = null;\n\n  private activeTooltip: HTMLCalciteTooltipElement = null;\n\n  private registeredElementCount = 0;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n\n  registerElement(referenceEl: ReferenceElement, tooltip: HTMLCalciteTooltipElement): void {\n    this.registeredElementCount++;\n    this.registeredElements.set(referenceEl, tooltip);\n    const shadowRoot = this.getReferenceElShadowRootNode(referenceEl);\n\n    if (shadowRoot) {\n      this.registerShadowRoot(shadowRoot);\n    }\n\n    if (this.registeredElementCount === 1) {\n      this.addListeners();\n    }\n  }\n\n  unregisterElement(referenceEl: ReferenceElement): void {\n    const shadowRoot = this.getReferenceElShadowRootNode(referenceEl);\n\n    if (shadowRoot) {\n      this.unregisterShadowRoot(shadowRoot);\n    }\n\n    if (this.registeredElements.delete(referenceEl)) {\n      this.registeredElementCount--;\n    }\n\n    if (this.registeredElementCount === 0) {\n      this.removeListeners();\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Methods\n  //\n  // --------------------------------------------------------------------------\n\n  private queryTooltip = (composedPath: EventTarget[]): HTMLCalciteTooltipElement => {\n    const { registeredElements } = this;\n\n    const registeredElement = (composedPath as HTMLElement[]).find((pathEl) => registeredElements.has(pathEl));\n\n    return registeredElements.get(registeredElement);\n  };\n\n  private keyDownHandler = (event: KeyboardEvent): void => {\n    if (event.key === \"Escape\" && !event.defaultPrevented) {\n      const { activeTooltip } = this;\n\n      if (activeTooltip?.open) {\n        this.clearHoverTimeout();\n        this.closeActiveTooltip();\n\n        const referenceElement = getEffectiveReferenceElement(activeTooltip);\n\n        if (referenceElement instanceof Element && referenceElement.contains(event.target as HTMLElement)) {\n          event.preventDefault();\n        }\n      }\n    }\n  };\n\n  private pointerMoveHandler = (event: PointerEvent): void => {\n    const composedPath = event.composedPath();\n    const { activeTooltip } = this;\n\n    const tooltip = this.queryTooltip(composedPath);\n\n    if (this.pathHasOpenTooltip(tooltip, composedPath)) {\n      this.clearHoverTimeout();\n      return;\n    }\n\n    if (tooltip) {\n      this.openHoveredTooltip(tooltip);\n    } else if (activeTooltip?.open) {\n      this.closeHoveredTooltip();\n    }\n  };\n\n  private pathHasOpenTooltip(tooltip: HTMLCalciteTooltipElement, composedPath: EventTarget[]): boolean {\n    const { activeTooltip } = this;\n\n    return (\n      (activeTooltip?.open && composedPath.includes(activeTooltip)) || (tooltip?.open && composedPath.includes(tooltip))\n    );\n  }\n\n  private clickHandler = (event: Event): void => {\n    const composedPath = event.composedPath();\n    const tooltip = this.queryTooltip(composedPath);\n\n    if (this.pathHasOpenTooltip(tooltip, composedPath)) {\n      this.clearHoverTimeout();\n      return;\n    }\n\n    this.closeActiveTooltip();\n\n    if (!tooltip) {\n      return;\n    }\n\n    this.clearHoverTimeout();\n\n    if (tooltip.closeOnClick) {\n      this.toggleTooltip(tooltip, false);\n      return;\n    }\n\n    this.toggleTooltip(tooltip, true);\n  };\n\n  private blurHandler = (): void => {\n    this.closeActiveTooltip();\n  };\n\n  private focusInHandler = (event: FocusEvent): void => {\n    const composedPath = event.composedPath();\n    const tooltip = this.queryTooltip(composedPath);\n\n    this.closeTooltipIfNotActive(tooltip);\n\n    if (!tooltip) {\n      return;\n    }\n\n    this.toggleFocusedTooltip(tooltip, true);\n  };\n\n  private addShadowListeners(shadowRoot: ShadowRoot): void {\n    shadowRoot.addEventListener(\"focusin\", this.focusInHandler, { capture: true });\n  }\n\n  private removeShadowListeners(shadowRoot: ShadowRoot): void {\n    shadowRoot.removeEventListener(\"focusin\", this.focusInHandler, { capture: true });\n  }\n\n  private addListeners(): void {\n    window.addEventListener(\"keydown\", this.keyDownHandler, { capture: true });\n    window.addEventListener(\"pointermove\", this.pointerMoveHandler, { capture: true });\n    window.addEventListener(\"click\", this.clickHandler, { capture: true });\n    window.addEventListener(\"focusin\", this.focusInHandler, { capture: true });\n    window.addEventListener(\"blur\", this.blurHandler);\n  }\n\n  private removeListeners(): void {\n    window.removeEventListener(\"keydown\", this.keyDownHandler, { capture: true });\n    window.removeEventListener(\"pointermove\", this.pointerMoveHandler, { capture: true });\n    window.removeEventListener(\"click\", this.clickHandler, { capture: true });\n    window.removeEventListener(\"focusin\", this.focusInHandler, { capture: true });\n    window.removeEventListener(\"blur\", this.blurHandler);\n  }\n\n  private clearHoverOpenTimeout(): void {\n    window.clearTimeout(this.hoverOpenTimeout);\n    this.hoverOpenTimeout = null;\n  }\n\n  private clearHoverCloseTimeout(): void {\n    window.clearTimeout(this.hoverCloseTimeout);\n    this.hoverCloseTimeout = null;\n  }\n\n  private clearHoverTimeout(): void {\n    this.clearHoverOpenTimeout();\n    this.clearHoverCloseTimeout();\n  }\n\n  private closeTooltipIfNotActive(tooltip: HTMLCalciteTooltipElement): void {\n    if (this.activeTooltip !== tooltip) {\n      this.closeActiveTooltip();\n    }\n  }\n\n  private closeActiveTooltip(): void {\n    const { activeTooltip } = this;\n\n    if (activeTooltip?.open) {\n      this.toggleTooltip(activeTooltip, false);\n    }\n  }\n\n  private toggleFocusedTooltip(tooltip: HTMLCalciteTooltipElement, open: boolean): void {\n    if (open) {\n      this.clearHoverTimeout();\n    }\n\n    this.toggleTooltip(tooltip, open);\n  }\n\n  private toggleTooltip(tooltip: HTMLCalciteTooltipElement, open: boolean): void {\n    tooltip.open = open;\n\n    this.activeTooltip = open ? tooltip : null;\n  }\n\n  private openHoveredTooltip = (tooltip: HTMLCalciteTooltipElement): void => {\n    this.hoverOpenTimeout = window.setTimeout(\n      () => {\n        if (this.hoverOpenTimeout === null) {\n          return;\n        }\n\n        this.clearHoverCloseTimeout();\n        this.closeTooltipIfNotActive(tooltip);\n        this.toggleTooltip(tooltip, true);\n      },\n      this.activeTooltip?.open ? 0 : TOOLTIP_OPEN_DELAY_MS,\n    );\n  };\n\n  private closeHoveredTooltip = (): void => {\n    this.hoverCloseTimeout = window.setTimeout(() => {\n      if (this.hoverCloseTimeout === null) {\n        return;\n      }\n\n      this.closeActiveTooltip();\n    }, TOOLTIP_CLOSE_DELAY_MS);\n  };\n\n  private registerShadowRoot(shadowRoot: ShadowRoot): void {\n    const { registeredShadowRootCounts } = this;\n\n    const count = registeredShadowRootCounts.get(shadowRoot);\n    const newCount = Math.min((typeof count === \"number\" ? count : 0) + 1, 1);\n\n    if (newCount === 1) {\n      this.addShadowListeners(shadowRoot);\n    }\n\n    registeredShadowRootCounts.set(shadowRoot, newCount);\n  }\n\n  private unregisterShadowRoot(shadowRoot: ShadowRoot): void {\n    const { registeredShadowRootCounts } = this;\n\n    const count = registeredShadowRootCounts.get(shadowRoot);\n    const newCount = Math.max((typeof count === \"number\" ? count : 1) - 1, 0);\n\n    if (newCount === 0) {\n      this.removeShadowListeners(shadowRoot);\n    }\n\n    registeredShadowRootCounts.set(shadowRoot, newCount);\n  }\n\n  private getReferenceElShadowRootNode(referenceEl: ReferenceElement): ShadowRoot | null {\n    return referenceEl instanceof Element ? getShadowRootNode(referenceEl) : null;\n  }\n}\n","import { readTask } from \"@stencil/core\";\nimport { whenTransitionDone } from \"./dom\";\n\n/**\n * Exported for testing purposes only\n */\nexport const internalReadTask = readTask;\n\n/**\n * Defines interface for components with open/close public emitter.\n * All implementations of this interface must handle the following events: `beforeOpen`, `open`, `beforeClose`, `close`.\n */\nexport interface OpenCloseComponent {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * When true, the component opens.\n   */\n  open?: boolean;\n\n  /**\n   * When true, the component is open.\n   */\n  opened?: boolean;\n\n  /**\n   *  Specifies the name of transitionProp.\n   */\n  transitionProp?: string;\n\n  /**\n   * Specifies property on which active transition is watched for.\n   */\n  openTransitionProp: string;\n\n  /**\n   * Specifies element that the transition is allowed to emit on.\n   */\n  transitionEl: HTMLElement;\n\n  /**\n   * Defines method for `beforeOpen` event handler.\n   */\n  onBeforeOpen: () => void;\n\n  /**\n   * Defines method for `open` event handler:\n   */\n  onOpen: () => void;\n\n  /**\n   * Defines method for `beforeClose` event handler:\n   */\n  onBeforeClose: () => void;\n\n  /**\n   * Defines method for `close` event handler:\n   */\n  onClose: () => void;\n}\n\nfunction isOpen(component: OpenCloseComponent): boolean {\n  return \"opened\" in component ? component.opened : component.open;\n}\n\n/**\n * Helper to determine globally set transition duration on the given openTransitionProp, which is imported and set in the @Watch(\"open\").\n * Used to emit (before)open/close events both for when the opacity transition is present and when there is none (transition-duration is set to 0).\n *\n * @example\n * import { onToggleOpenCloseComponent, OpenCloseComponent } from \"../../utils/openCloseComponent\";\n *\n * async componentWillLoad() {\n * // When component initially renders, if `open` was set we need to trigger on load as watcher doesn't fire.\n * if (this.open) {\n *    onToggleOpenCloseComponent(this);\n * }\n * @Watch(\"open\")\n * async toggleModal(value: boolean): Promise<void> {\n *    onToggleOpenCloseComponent(this);\n * }\n *\n * @param component - OpenCloseComponent uses `open` prop to emit (before)open/close.\n */\nexport function onToggleOpenCloseComponent(component: OpenCloseComponent): void {\n  internalReadTask((): void => {\n    if (!component.transitionEl) {\n      return;\n    }\n\n    whenTransitionDone(\n      component.transitionEl,\n      component.openTransitionProp,\n      () => {\n        if (isOpen(component)) {\n          component.onBeforeOpen();\n        } else {\n          component.onBeforeClose();\n        }\n      },\n      () => {\n        if (isOpen(component)) {\n          component.onOpen();\n        } else {\n          component.onClose();\n        }\n      },\n    );\n  });\n}\n"],"names":["CSS","ARIA_DESCRIBED_BY","getEffectiveReferenceElement","tooltip","referenceElement","queryElementRoots","id","manager","constructor","registeredElements","WeakMap","registeredShadowRootCounts","hoverOpenTimeout","hoverCloseTimeout","activeTooltip","registeredElementCount","queryTooltip","composedPath","this","registeredElement","find","pathEl","has","get","keyDownHandler","event","key","defaultPrevented","open","clearHoverTimeout","closeActiveTooltip","Element","contains","target","preventDefault","pointerMoveHandler","pathHasOpenTooltip","openHoveredTooltip","closeHoveredTooltip","clickHandler","closeOnClick","toggleTooltip","blurHandler","focusInHandler","closeTooltipIfNotActive","toggleFocusedTooltip","_this$activeTooltip","window","setTimeout","clearHoverCloseTimeout","registerElement","referenceEl","set","shadowRoot","getReferenceElShadowRootNode","registerShadowRoot","addListeners","unregisterElement","unregisterShadowRoot","delete","removeListeners","includes","addShadowListeners","addEventListener","capture","removeShadowListeners","removeEventListener","clearHoverOpenTimeout","clearTimeout","count","newCount","Math","min","max","getShadowRootNode","Tooltip","proxyCustomElement","HTMLElement","guid","concat","hasLoaded","openTransitionProp","setTransitionEl","el","transitionEl","setUpReferenceElement","warn","arguments","length","undefined","_this","removeReferences","effectiveReferenceElement","connectFloatingUI","console","tagName","addReferences","getId","setAttribute","removeAttribute","defaultOffsetDistance","offsetDistanceOffsetHandler","reposition","offsetSkiddingHandler","openHandler","onToggleOpenCloseComponent","overlayPositioningHandler","placementHandler","referenceElementHandler","connectedCallback","componentWillLoad","componentDidLoad","disconnectedCallback","disconnectFloatingUI","delayed","placement","overlayPositioning","offsetDistance","offsetSkidding","arrowEl","floatingEl","type","onBeforeOpen","calciteTooltipBeforeOpen","emit","onOpen","calciteTooltipOpen","onBeforeClose","calciteTooltipBeforeClose","onClose","calciteTooltipClose","render","label","floatingLayout","displayed","hidden","h","Host","toAriaBoolean","role","class","FloatingCSS","animation","animationActive","ref","FloatingArrow","internalReadTask","readTask","isOpen","component","opened","whenTransitionDone"],"sourceRoot":""}